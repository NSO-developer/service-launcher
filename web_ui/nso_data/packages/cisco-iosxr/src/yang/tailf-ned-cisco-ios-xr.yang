
module tailf-ned-cisco-ios-xr {
  namespace 'http://tail-f.com/ned/cisco-ios-xr';
  prefix cisco-ios-xr;

  import tailf-common {
    prefix tailf;
  }
  import ietf-inet-types {
    prefix inet;
  }


  // =========================================================================
  // REVISION
  // =========================================================================

  revision 2017-04-07 {
    description
      "5.2
       See CHANGES.
       ";
  }

  revision 2016-03-14 {
    description
      "4.1.0.3
      Enhancements:
       Support for EXEC proxy login configuration, which can be used to access
        a device through a terminal server which requires extra command.
        Configure cisco-iosxr-proxy-settings under ned-settings to enable.
        See README file for example.
         (IOSXR-15)
      Corrections:
       API CHANGE: router static / address-family ipv4|ipv6 unicast / *
       Did not support multiple entries in combo of net,interface and ip.
        (RT22185)
      ";
  }

  revision 2016-03-07 {
    description
      "4.1.0.2
      Enhancements:
       Do not log telnet login password in trace.
       Support for SSH/TELNET proxy login configuration.
        Configure cisco-iosxr-proxy-settings under ned-settings to enable.
        See new README file for example.
      Corrections:
       Fixed null pointer exception with no-statements in set's.
        (RT22047)
      ";
  }

  revision 2016-02-12 {
    description
      "4.1.0.1
      Enhancements:
       Additions to the YANG model:
        bfd / interface * / echo
        router ospf * / area * / fast-reroute per-prefix
        router ospf * / area * / stub
        router ospf * / area * / multi-area-interface *
         (RT21731)
        router isis * / address-family * / ispf level
         (RT21759)
        router hsrp / interface * / hsrp delay
         (RT21791)
      Corrections:
      ";
  }

  revision 2016-01-08 {
    description
      "4.1
      Enhancements:
       Additions to the YANG model:
        router ospf * / authentication
        router ospf * / message-digest-key
        router ospf * / timers pacing
        line * / escape-character
        router bgp * / address-family * / distance
        router bgp * / address-family ipv6 multicast
        router bgp * / neighbor * / address-family ipv6 multicast
        router bgp * / neighbor * / address-family ? / default-originate route-policy
        router bgp / bgp graceful-restart graceful-reset
        router bgp * / session-group * / use
        domain ipv4
        ntp server * key
        ntp authentication-key *
        ntp authenticate
        ntp trusted-key
        dhcp ipv4 / profile * / relay
        flow monitor-map * / record mpls
        flow monitor-map * / cache entries
        flow monitor-map * / cache timeout inactive
        flow monitor-map * / cache timeout rate-limit
        flow monitor-map * / cache timeout update
        as-path-set ios-regex
        mpls ldp / address-family ipv4 / label / local / advertise / disable
        l2vpn / bridge group * / bridge-domain * / flooding
        logging host * port
        ipv6 conflict-policy
        ipv6 prefix-list *
      Corrections:
        Replaced custom type ipv6-prefix with
        tailf:ipv6-address-and-prefix-length. This will take advantage of NCS
        built-in canonicalization of ipv6 addresses (i.e. case-insensitivity +
        compression).
      ";
  }

  revision 2015-12-22 {
    description
      "4.0.1.3
      Enhancements:
       Additions to the YANG model:
        l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / route-target *
        l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / signaling-protocol
        l2vpn / xconnect group * / mp2mp * / control-word
        l2vpn / xconnect group * / mp2mp * / l2-encapsulation
        l2vpn / xconnect group * / mp2mp * / mtu
        l2vpn / xconnect group * / mp2mp * / vpn-id
        l2vpn / xconnect group * / p2p * / neighbor * / tag-impose
       ";
  }

  revision 2015-12-09 {
    description
      "4.0.1.2
      Enhancements:
       Additions to the YANG model:
        interface * / ethernet cfm / ais
        interface tunnel-te* / autoroute destination *
        interface tunnel-te* / forward-class
        interface tunnel-mte*
        multicast-routing / address-family ipv4 / mdt data p2mp-te
        multicast-routing / address-family ipv4 / mdt default p2mp-te
        multicast-routing / address-family ipv4 / bgp
        router pim / address-family ipv4 / rpf
        router pim / address-family ipv4 / mdt
        ethernet cfm / domain * / service * / continuity-check interval loss-threshold
        ethernet cfm / domain * / service * / continuity-check archive
        ethernet cfm / domain * / service * / continuity-check loss
        ethernet cfm / domain * / service * / log ais
        ethernet cfm / domain * / service * / log crosscheck
        l2vpn / pw-class * / encapsulation mpls / preferred-path fallback
        mpls traffic-eng / attribute-set p2mp-te *

      Corrections:
       Changed 'ethernet cfm / domain * / service * / continuity-check interval'
       to container to be able to model containers archive and loss within
       continuity-check
      ";
  }

  revision 2015-12-07 {
    description
      "4.0.1.1
      Enhancements:
       Additions to the YANG model:
        router ospf * / area * / dead-interval
        router ospf * / distance ospf
        router ospf * / redistribute isis *
        router isis * / address-family * / mpls ldp sync level
        router isis * / address-family * / redistribute ospf
        router isis * / address-family * / redistribute ospfv3
        class-map * / match dei
        interface tunnel-te* / affinity-value
        interface tunnel-te* / path-option * attribute-set
        interface tunnel-te* / path-option * protected-by
        router bgp * / timers
        router bgp / bgp bestpath as-path
        multicast-routing / address-family ipv4 / interface-inheritance
        router pim / address-family ipv4 / interface * / enable
        explicit-path identifier *
        nv / satellite * / description
        nv / satellite * / secret
        snmp-server packetsize
        snmp-server ipv4 precedence
        snmp-server interface *
        spanning-tree mst * / instance * / vlan-ids
        hw-module mac-move
        router isis * / interface * / hello-interval
        mpls traffic-eng / interface * / attribute-flags
        mpls traffic-eng / interface * / backup-path
        mpls traffic-eng / attribute-set
        mpls ldp / address-family ipv4 / label / local / advertise

       Added enum value 'disable' to severity-type

      Corrections:
       Moved container bfd from non-subinterface-common-grouping to new grouping
       interface-bfd-grouping to be able to model interface
       tunnel-te correctly

       Added 'ordered-by user' to 'policy-map * / class *'
      ";
  }

  revision 2015-11-23 {
    description
      "4.0.0.5
      Enhancements:
       Expanded YANG model in:
        ipsla
       Additions to the YANG model:
        dhcp ipv4 / profile * / giaddr policy
        ethernet cfm / domain * / service * down-meps
        ethernet cfm / domain * / service * / mep crosscheck
        forward-protocol udp *
        ftp client password
        ftp client username
        multicast-routing / address-family ipv4 / mdt source
        performance-mgmt statistics
        router bgp * / address-family ipv4 multicast
        router ospf * / redistribute connected
        router-convergence / collect-diagnostics *
        rpl editor
        (RT20884)
       The NED is now configurable regarding the max number of command lines it
        shall send in a chunk to the device. Default is 100.
        A higher number usually gives better performance but can also
        have negative impact on the NEDs error detection ability. If an error
        occurs in the middle of the 'chunk' the execution will continue with the
        remaining lines. This can result in that for instance a config leaf is
        accidentally set.

        Note, the cisco-iosxr NED was previously hard coded to send chunks of
        1000 commands at a time.
n
        To set to one command per chunk, do as follows in the NCS/NSO CLI:
         $ devices device <name> ned-settings cisco-iosxr-number-of-lines-to-send-in-chunk 1
         $ commit
      Corrections:
        Fixed problem when config error and abort, dead locking ncs.
      ";
  }

  revision 2015-11-10 {
    description
      "4.0.0.4
      Enhancements:
       Additions to the YANG model:
        l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp /
         signaling-protocol
        interface * / nv / edge / interface
        l2vpn / autodiscovery bgp / signaling-protocol bgp
        mirror location *
        ospf name-lookup
        router bgp * / neighbor * / local-as
        router mld / vrf *
        router ospf * / ignore lsa mospf
        router ospf * / passive
        router ospf * / queue limit
        router static / maximum path
        taskgroup * / task debug *
      Corrections:
       router ospf * / default-information
      ";
  }

  revision 2015-11-02 {
    description
      "4.0.0.3
      Enhancements:
      Corrections:
       Removed choice from router bgp * / neighbor * / use neighbor-group
        and use session-group.
       (RT20723)
      ";
  }

  revision 2015-10-26 {
    description
      "4.0.0.2
      Enhancements:
       Additions to the YANG model:
        evpn / evi * / network-controller / host * / ipv4 address
        interface nve *
        l2vpn / bridge group * / bridge-domain * / member vni *
        l2vpn / router-id
        router bgp * / address-family * / advertise vpnv4|vpnv6 unicast
        neighbor * / address-family ? / import
        router bgp * / address-family * / label mode
        router bgp * / neighbor * /  ignore-connected-check
        vrf * / address-family ipvX unicast / XXport route-target / * stitching
      Corrections:
       Added netmask leaf: evpn / evi * / network-controller / host * / gateway
      ";
  }

  revision 2015-10-20 {
    description
      "4.0.0.1
      Enhancements:
       Additions to the YANG model:
        interface FortyGigE
        router ospf * / distribute-list
        router static / address-family ipv4 unicast / * vrf *
      Corrections:
      ";
  }

  revision 2015-09-30 {
    description
      "4.0
      Enhancements:
       Merged to master branch. Release 4.0.
      Corrections:
      ";
  }

  revision 2015-09-28 {
    description
      "3.11.0.8
      Enhancements:
      Corrections:
       Changed interface IPv4 address api. (RT20158)
      ";
  }

  revision 2015-09-21 {
    description
      "3.11.0.7
      Enhancements:
       Additions to the YANG model:
        interface * / encapsulation dot1ad * exact
      Corrections:
       Ignore trailing characters after end delimiter in banners.
      ";
  }

  revision 2015-09-16 {
    description
      "3.11.0.6
      Enhancements:
       Expanded segment routing support.
       Additions to the YANG model:
        interface tunnel-te* / path-selection / segment-routing adjacency
        mpls traffic-eng / auto-tunnel pcc / tunnel-id
        router bgp * / address-family link-state link-state
        router ospf * / segment-routing
      Corrections:
      ";
  }

  revision 2015-09-14 {
    description
      "3.11.0.5
      Enhancements:
       Implemented basic support for segment routing.
       Additions to the YANG model:
        icmp ipv4 rate-limit unreachable
        l2vpn / bridge group * / bridge-domain * / neighbor * / split-horizon
        mpls traffic-eng / interface * / attribute-names
        mpls traffic-eng / interface * / admin-weight
        mpls traffic-eng / pce
        router isis * / address-family * / segment-routing
        router isis * / interface * / address-family ipv4 unicast / prefix-sid
        segment-routing / global-block
      Corrections:
       Fixed yet another bug with reading/writing banners.
       Dirty 'mpls traffic-eng / auto-tunnel backup' fix
      ";
  }

  revision 2015-09-09 {
    description
      "3.11.0.4
      Enhancements:
       EPN 4.0 support for MEF and TI (Transport infrastructure).
       Additions to the YANG model:
        ethernet cfm / traceroute cache
        ipv4 prefix-list *
        l2vpn / pw-class * / encapsulation mpls / redundancy
        l2vpn / redundancy
        logging disable
       Expanded the YANG model in:
        mpls ldp
        router bgp
        router isis
      Corrections:
       clock-interface / frequency synchronization / quality
       Quote and dequote description strings.
      ";
  }

  revision 2015-08-25 {
    description
      "3.11.0.3
      Enhancements:
       Additions to the YANG model:
        router vrrp / interface * / address-family ipv6 / vrrp * / address linklocal
       Expanded the YANG model in:
        spanning-tree mst *
      Corrections:
      ";
  }

  revision 2015-08-20 {
    description
      "3.11.0.2
      Enhancements:
       Additions to the YANG model:
        class-map * / match vpls
        controller E3 *
        explicit-path name * / index * next-label
        interface FastEthernet*
        interface POS* (subinterface)
        interface * / dot1ad
        interface * / flow-control
        l2vpn / bridge group * / bridge-domain * / mac / learning
        l2vpn / bridge group * / bridge-domain * / pbb / edge *
        l2vpn / pw-class * / encapsulation mpls / preferred-path
        line * / secret
        mpls ldp / session protection
        multicast-routing / vrf *
        ntp interface * / broadcast
        policy-map * / class * / police * / child-conform-aware
        router bgp / bgp auto-policy-soft-reset disable
        router bgp / default-information originate
        router bgp / neighbor * / address-family ? / site-of-origin
        router pim / vrf *
        snmp-server entityindex
       Expanded the YANG model in:
        controller E1 *
        controller SONET *
        interface * / service-policy
        policy-map * / class * / random-detect
      Corrections:
       Changed network-controller / switch * from container to list.
       Corrected interface * / dot1q vlan, added second vlan id. API change.
       Use 'show version' if 'show version brief' fails in login check.
       Fixed regexp for exec commands when prompted to continue. [RT 19832]
       Fixed dependency problem when delete of class-map. [RT 19802]
      ";
  }

  revision 2015-07-17 {
    description
      "3.11.0.1
      Enhancements:
       Additions to the YANG model:
        router bgp * / neighbor * / ttl-security
      Corrections:
      ";
  }

  revision 2015-06-23 {
    description
      "3.10.0
      Enhancements:
       Support for NSO-4.0 (note: NSO is new name for NCS)
       The NED is now compliant with NSO 4.0 regarding registering
        platform information. Use this command to see:
         admin@ncs# show devices device platform
       Additions to the YANG model:
        evpn / evi *
        evpn / network-controller
        l2vpn / bridge group * / bridge-domain * / evpn evi
        router bgp * / address-family l2vpn evpn
        router bgp * / neighbor * / address-family l2vpn evpn
      Corrections:
       logging console disable always became logging console alerts
       Changed logging host * type to union of IPv4/IPv6 address.
      ";
  }


  revision 2015-06-12 {
    description
      "3.9.0.10
      Enhancements:
       Expanded controller SONET config.
        (RT 19125)
       Additions to the YANG model:
        snmp-server vrf *
        spanning-tree mst *
        control-plane / management-plane / out-of-band / interface * / ..
          allow * peer / address ipv4 *
      Corrections:
       Fixed bug with reading/writing banners.
      ";
  }

  revision 2015-05-15 {
    description
      "3.9.0.9
      Enhancements:
       Additions to the YANG model:
        bfd / interface *
        bfd / multihop|multipath
        class-map * / match source-address ipv4 *
        interface * / affinity include *
        interface * / affinity include-strict *
        line * / telnet transparent
        policy-map * / class * / random-detect default
        router bgp * / neighbor * / enforce-first-as
        router ospf * / mpls ldp auto-config
      Corrections:
       Updated class-map * / match protocol values.
       Updated policy-map * / class * / redirect nexthop
      ";
  }

  revision 2015-05-11 {
    description
      "3.9.0.8
      Enhancements:
       Added basic support for BGP flowspec.
       Additions to the YANG model:
        class-map * / match destination-address ipv4 *
        class-map * / match destination-port
        class-map type traffic
        flowspec / address-family ipv4 / service-policy
        interface * / encapsulation ambiguous dot1q
        interface * / service-policy input|output * subscriber-parent
        l2vpn / bridge group * / bridge-domain * / interface * / split-horizon
        netconf-yang agent ssh
        policy-map type
        policy-map * / class type traffic *
        policy-map * / class * / redirect nexthop
        router bgp * / address-family ipv4 flowspec
        router bgp * / address-family vpnv4 flowspec
        router bgp * / neighbor * / address-family ipv4 flowspec
        vrf * / address-family ipv4 flowspec
        xml agent / iteration
      Corrections:
       Fixed problem with replacing interface * / service-policy (API change!)
      ";
  }

  revision 2015-04-28 {
    description
      "3.9.0.7
      Enhancements:
       Additions to the YANG model:
        interface tunnel-te* / autoroute metric
        interface tunnel-te* / load-share
      Corrections:
       Fixed problems with the new annotation in description leaves.
      ";
  }

  revision 2015-04-23 {
    description
      "3.9.0.6
      Enhancements:
       Added 'IOS XR Configuration' version number to 'version' leaf.
      Corrections:
       Added 'tailf:cli-preformatted' to all description leaves to suppress
        quoting of non-config elements when displaying them.
      ";
  }

  revision 2015-04-21 {
    description
      "3.9.0.5
      Enhancements:
      Corrections:
       Fixed interface * / encapsulation dot1q|dot1ad vlan ranges.
      ";
  }

  revision 2015-04-17 {
    description
      "3.9.0.4
      Enhancements:
       Added NCS version and NETSIM confd&NED version in ned trace.
       Additions to the YANG model:
        vrf * / vpn id
        router bgp * / address-family * / bgp dampening
        router ospf * / area * / nssa
      Corrections:
      ";
  }

  revision 2015-04-08 {
    description
      "3.9.0.3
      Enhancements:
       Additions to the YANG model:
        l2vpn / bridge group * / bridge-domain * / neighbor * / storm-control
        router isis * / address-family * / redistribute connected
        router isis * / address-family * / advertise passive-only
      Corrections:
      ";
  }

  revision 2015-03-25 {
    description
      "3.9.0.2
      Enhancements:
       Additions to the YANG model:
        igmp snooping profile *
        interface * / nv / satellite-fabric-link # / redundancy
        l2vpn / bridge group * / bridge-domain * / igmp snooping
        l2vpn / bridge group * / bridge-domain * / storm-control
        mpls ldp / neighbor / * password
        mpls ldp / address-family ipv4
        nv / satellite * / redundancy
        nv / satellite * / serial-number
        redundancy / iccp / group * / backbone
        redundancy / iccp / group * / nv satellite
        .. and more minor additions ..
      Corrections:
      ";
  }

  revision 2015-03-18 {
    description
      "3.9.0.1
      Enhancements:
       Expanded and improved controller SONET config.
       Additions to the YANG model:
        cem
        controller E1 *
        ethernet sla
        ethernet cfm
        interface ATM *
        interface CEM *
        interface * / ethernet cfm
        ipsla / operation *
        ipsla / schedule operation *
         .. and more minor additions ..
        router bgp / neighbor / address-family / send-extended-community-ebgp
      Corrections:
       Fixed bug in l2vpn / bridge group * / bridge-domain * / routed interface
      ";
  }

  revision 2015-03-12 {
    description
      "3.8.0
      Enhancements:
       Support for NCS-3.4.
      Corrections:
      ";
  }

  revision 2015-02-19 {
    description
      "3.7.0.1
      Enhancements:
      - Added support for generic-interface-list / interface config.
        (#12557 / RT17938)
      Corrections:
      ";
  }

  revision 2015-02-11 {
    description
      "3.6.0
      Enhancements:
      Corrections:
      ";
  }

  revision 2015-02-11 {
    description
      "3.5.0.9
      Enhancements:
      Corrections:
       Bugfixed copy and reload commands under live-status exec.
       More work on prompt matching in java code.
      ";
  }

  revision 2015-02-10 {
    description
      "3.5.0.8
      Enhancements:
      Corrections:
       Improved prompt matching in java code to avoid deadlock when setting
        complex descriptions (e.g. with '#' and '(' etc).
      ";
  }

  revision 2015-02-09 {
    description
      "3.5.0.7
      Enhancements:
       Expanded router bgp.
       Added traceroute, copy and reload commands under live-status exec.
      Corrections:
      ";
  }

  revision 2015-02-04 {
    description
      "3.5.0.6
      Enhancements:
       Implemented basic support for router hsrp.
       Added timer config in bfd address-family ipv4 interface config.
       Added route-policy config to vrf address-family export/import.
      Corrections:
      ";
  }

  revision 2015-01-19 {
    description
      "3.5.0.5
      Enhancements:
       Expanded rewrite ingress tag sub-interface config.
       Added level option to isis router metric config.
       Added signalled-name to interface tunnel-te config.
      Corrections:
      ";
  }

  revision 2015-01-14 {
    description
      "3.5.0.4
      Enhancements:
       Expanded interface tunnel-te config.
      Corrections:
      ";
  }

  revision 2014-12-19 {
    description
      "3.5.0.3
      Enhancements:
       Added domain list config.
       Expanded ospf and ospfv3 config.
       Added generic snmp-server traps list accepting all entries.
      Corrections:
       Removed all 'tailf:cli-no-keyword' on non policy-map config.
      ";
  }

  revision 2014-12-10 {
    description
      "3.5.0.2
      Enhancements:
       Added support for explicit-path config.
      Corrections:
      ";
  }

  revision 2014-12-08 {
    description
      "3.5.0.1
      Enhancements:
       Added ping and clear exec commands under live-status, e.g.:
        devices device asr9k live-status exec ping 192.168.1.1
        devices device asr9k live-status exec clear ppp queues
       Added PW-Ether interface and sub-interface. (RT 17184)
       Send initial newline to device for terminal support. (RT 16500)
      Corrections:
       Strip no commands inside extcommunity-set, rd-set, prefix-set,
        as-path-set and community-set on real devices. (RT 17090)
      ";
  }

  revision 2014-11-26 {
    description
      "3.4.0
      Enhancements:
       The method to use by the NED for calculating transaction ID is now a
        configurable option.
        The config option cisco-iosxr-transaction-id-method is available under:
         /ncs:devices/global-settings/ned-settings/
         /ncs:devices/ncs:profiles/profile:cisco-iosxr/ned-settings/
         /ncs:/device/devices/device:<dev name>/ned-settings/
        Two values are supported:
         config-hash (default) : Use a snapshot of the running config for
                                 calculation.
         commit-list :           Use the configuration commit list time of
                                 the latest commit for calculation.
       Implemented support for 'crypto key' exec commands under live-status,
        e.g.: devices device asr9k live-status exec crypto key generate rsa
       Expanded router ospf, router pim, router igmp and router static.
       Numerous YANG model expansions in various areas.
       Implemented basic support for router ospfv3.
       YANG data model updates: class-map / match vlan
       YANG data model updates: l2vpn
      Corrections:
       Fixed two problem with class-map / match dscp, ordering and ipv4/ipv6.
      ";
  }


  // =========================================================================
  // TYPEDEF
  // =========================================================================

  typedef ifname {
    type string {
      tailf:info "WORD;;Interface name";
    }
  }

  typedef month-type {
    type enumeration {
      enum january;
      enum february;
      enum march;
      enum april;
      enum may;
      enum june;
      enum july;
      enum august;
      enum september;
      enum october;
      enum november;
      enum december;
    }
  }

  typedef percentage-type {
    type uint8 {
      tailf:info "<1-100>;;Percentage";
      range "1..100";
    }
  }

  typedef asn-ip-type {
    type string {
 pattern '(([0-9]+)|((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
        +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))):[0-9]+';
      tailf:info "ASN:nn or IP-address:nn";
    }
  }

  typedef ipv4-prefix {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
        +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
        + '/(([0-9])|([1-2][0-9])|(3[0-2]))';
    }
    description
      "The ipv4-prefix type represents an IPv4 address prefix.
    The prefix length is given by the number following the
    slash character and must be less than or equal to 32.

    A prefix length value of n corresponds to an IP address
    mask that has n contiguous 1-bits from the most
    significant bit (MSB) and all other bits set to 0.

    The canonical format of an IPv4 prefix has all bits of
    the IPv4 address set to zero that are not part of the
    IPv4 prefix.";
  }

  typedef task-type {
    type string {
    }
  }

  typedef severity-type {
    type enumeration {
      enum alerts {
        tailf:info "Immediate action needed           (severity=1)";
      }
      enum critical {
        tailf:info "Critical conditions               (severity=2)";
      }
      enum debugging {
        tailf:info "Debugging messages                (severity=7)";
      }
      enum emergencies {
        tailf:info "System is unusable                (severity=0)";
      }
      enum errors {
        tailf:info "Error conditions                  (severity=3)";
      }
      enum info {
      }
      enum informational {
        tailf:info "Informational messages            (severity=6)";
      }
      enum notifications {
        tailf:info "Normal but significant conditions (severity=5)";
      }
      enum warnings {
        tailf:info "Warning conditions                (severity=4)";
      }
      enum disable {
        tailf:info "Disable logging";
      }
    }
  }

  typedef dscp-type {
    type union {
      type uint8 {
        tailf:info "<0-63>;;Differentiated services codepoint value";
        range "0..63";
      }
      type enumeration {
        enum af11 {
          tailf:info "AF11 dscp (001010)";
          tailf:code-name "dscp_af11";
        }
        enum af12 {
          tailf:info "AF12 dscp (001100)";
          tailf:code-name "dscp_af12";
        }
        enum af13 {
          tailf:info "AF13 dscp (001110)";
          tailf:code-name "dscp_af13";
        }
        enum af21 {
          tailf:info "AF21 dscp (010010)";
          tailf:code-name "dscp_af21";
        }
        enum af22 {
          tailf:info "AF22 dscp (010100)";
          tailf:code-name "dscp_af22";
        }
        enum af23 {
          tailf:info "AF23 dscp (010110)";
          tailf:code-name "dscp_af23";
        }
        enum af31 {
          tailf:info "AF31 dscp (011010)";
          tailf:code-name "dscp_af31";
        }
        enum af32 {
          tailf:info "AF32 dscp (011100)";
          tailf:code-name "dscp_af32";
        }
        enum af33 {
          tailf:info "AF33 dscp (011110)";
          tailf:code-name "dscp_af33";
        }
        enum af41 {
          tailf:info "AF41 dscp (100010)";
          tailf:code-name "dscp_af41";
        }
        enum af42 {
          tailf:info "AF42 dscp (100100)";
          tailf:code-name "dscp_af42";
        }
        enum af43 {
          tailf:info "AF43 dscp (100110)";
          tailf:code-name "dscp_af43";
        }
        enum cs1 {
          tailf:info "CS1(precedence 1) dscp (001000)";
          tailf:code-name "dscp_cs1";
        }
        enum cs2 {
          tailf:info "CS2(precedence 2) dscp (010000)";
          tailf:code-name "dscp_cs2";
        }
        enum cs3 {
          tailf:info "CS3(precedence 3) dscp (011000)";
          tailf:code-name "dscp_cs3";
        }
        enum cs4 {
          tailf:info "CS4(precedence 4) dscp (100000)";
          tailf:code-name "dscp_cs4";
        }
        enum cs5 {
          tailf:info "CS5(precedence 5) dscp (101000)";
          tailf:code-name "dscp_cs5";
        }
        enum cs6 {
          tailf:info "CS6(precedence 6) dscp (110000)";
          tailf:code-name "dscp_cs6";
        }
        enum cs7 {
          tailf:info "CS7(precedence 7) dscp (111000)";
          tailf:code-name "dscp_cs7";
        }
        enum "default" {
          tailf:info "Default dscp (000000)";
          tailf:code-name "dscp_default";
        }
        enum ef {
          tailf:info "EF dscp (101110)";
          tailf:code-name "dscp_ef";
        }
      }
    }
  }

  typedef precedence-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;Precedence value";
        range "0..7";
      }
      type enumeration {
        enum routine {
          tailf:info "Set packets with routine precedence (0)";
          value 0;
        }
        enum priority {
          tailf:info "Set packets with priority precedence (1)";
          value 1;
        }
        enum immediate {
          tailf:info "Set packets with immediate precedence (2)";
          value 2;
        }
        enum flash {
          tailf:info "Set packets with flash precedence (3)";
          value 3;
        }
        enum flash-override {
          tailf:info "Set packets with flash override precedence (4)";
          value 4;
        }
        enum critical {
          tailf:info "Set packets with critical precedence (5)";
          value 5;
        }
        enum internet {
          tailf:info "Set packets with internetwork control "+
            "precedence (6)";
          value 6;
        }
        enum network {
          tailf:info "Set packets with network control precedence "+
            "(7)";
          value 7;
        }
      }
    }
  }

  typedef police-burst-units-type {
    type enumeration {
      enum bytes {
        tailf:info "Bytes (default)";
      }
      enum gbytes {
        tailf:info "Gigabytes";
      }
      enum kbytes {
        tailf:info "Kilobytes";
      }
      enum mbytes {
        tailf:info "Megabytes";
      }
      enum ms {
        tailf:info "Milliseconds";
      }
      enum packets {
        tailf:info "Packets";
      }
      enum us {
        tailf:info "Microseconds";
      }
    }
  }

  typedef police-rate-units-type {
    type enumeration {
      enum bps {
        tailf:info "Bits per second (default)";
      }
      enum gbps {
        tailf:info "Gigabits per second";
      }
      enum kbps {
        tailf:info "Kilobits per second";
      }
      enum mbps {
        tailf:info "Megabits per second";
      }
      enum pps {
        tailf:info "Packets per second";  //??
      }
    }
  }

  typedef ospf-area-type {
    type union {
      type uint32 {
        tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
        range "0 .. 4294967295";
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF area ID in IP address format";
      }
    }
  }

  typedef operator-type {
    type enumeration {
      enum eq {
        tailf:info "Equal to";
      }
      enum ge {
        tailf:info "Greater than or equal to";
      }
      enum gt {
        tailf:info "Greater than";
      }
      enum le {
        tailf:info "Less than or equal to";
      }
      enum lt {
        tailf:info "Less than";
      }
      enum ne {
        tailf:info "Not equal to";
      }
      enum rg {
        tailf:info "Not in range";
      }
    }
  }

  typedef control-plane-proto {
    type enumeration {
      enum HTTP {
        tailf:info "HTTP(S)";
      }
      enum NETCONF {
        tailf:info "NETCONF version 1.1 protocol";
      }
      enum SNMP {
        tailf:info "SNMP (all versions)";
      }
      enum SSH {
        tailf:info "Secure Shell (v1 & v2)";
      }
      enum TFTP {
        tailf:info "Enable TFTP";
      }
      enum Telnet {
        tailf:info "Telnet";
      }
      enum XML {
        tailf:info "XML";
      }
      enum all {
        tailf:info "All Protocols";
      }
    }
  }

  typedef vrf-type {
    type union {
      type string {
        tailf:info "WORD;;Name of VRF";
      }
      type enumeration {
        enum "default" {
          tailf:info "Default vrf";
        }
      }
    }
  }

  // aaa-group-type
  typedef aaa-group-type {
    type union {
      type string {
        tailf:info "WORD;;Server-group name";
      }
      type enumeration {
        enum ldap {
          tailf:info "Use list of all LDAP hosts.";
        }
        enum radius {
          tailf:info "Use list of all Radius hosts.";
        }
        enum "tacacs+" {
          tailf:info "Use list of all Tacacs+ hosts.";
        }
      }
    }
  }


  // =========================================================================
  // GROUPING
  // =========================================================================


  // description-grouping
  grouping description-grouping {
    leaf "description" {
      tailf:info "Description text";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description";
      }
    }
  }

  grouping password-grouping {
    leaf "type" {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type enumeration {
        enum clear {
          tailf:info "Save the community string in encrypted form";
        }
        enum encrypted {
          tailf:info "Specifies an ENCRYPTED community string";
        }
      }
    }
    leaf secret {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      tailf:cli-disallow-value "clear|encrypted";
      tailf:meta-data "secret-password";
      type string {
        tailf:info "WORD;;Specify an unencrypted password";
      }
    }
  }

  // key-grouping
  grouping key-grouping {
    leaf encryption {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum "0" {
          tailf:info "Specifies an UNENCRYPTED key will follow";
        }
        enum "7" {
          tailf:info "Specifies an ENCRYPTED key will follow";
        }
      }
    }
    leaf "key" {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      tailf:cli-disallow-value "0|7";
      tailf:meta-data "secret-password";
      type string {
        tailf:info "LINE;;The UNENCRYPTED key";
      }
    }
  }

  grouping banner-grouping {
    leaf start-marker {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;delimitting start character";
        length "1";
      }
    }
    leaf message {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;quoted banner message";
      }
    }
    leaf end-marker {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      must "../end-marker = ../start-marker" {
        tailf:dependency "../start-marker";
        tailf:dependency "../end-marker";
      }
      type string {
        tailf:info "WORD;;delimitting end character";
        length "1";
      }
    }
  }


  // vrf * / address-family ipv4 unicast / import route-target
  // vrf * / address-family ipv4 unicast / export route-target
  // vrf * / address-family ipv6 unicast / import route-target
  // vrf * / address-family ipv6 unicast / export route-target
  grouping vrf-route-target-grouping {

    // vrf * / address-family ipv6 unicast / export route-target / *
    list address-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "<1-65535>:<0-4294967295>;;ASN2:index\n"+
            "<65536-4294967295>:<0-65535>;;ASN4:index\n"+
            "<IP address>:<0-65535>;;IPAddress:index "+
            "(hex or decimal format)";
          pattern "[0-9]+.*";
        }
      }
    }

    // vrf * / address-family ipv6 unicast / export route-target / * stitching
    list stitching-address-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      key name;
      leaf name {
        type string {
          tailf:info "<1-65535>:<0-4294967295>;;ASN2:index\n"+
            "<65536-4294967295>:<0-65535>;;ASN4:index\n"+
            "<IP address>:<0-65535>;;IPAddress:index "+
            "(hex or decimal format)";
          pattern "[0-9]+.*";
        }
      }
      leaf stitching {
        tailf:info "These are stitching RTs";
        type empty;
      }
    }
  }

  // router-af-redistribute-grouping
  grouping router-af-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
      }
    }
    leaf route-policy {
      tailf:info "Route policy reference";
      type string {
        tailf:info "WORD;;Name of the policy";
      }
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:route-policy/name";
      }
    }
  }

  // router-ospf-af-redistribute-grouping
  grouping router-ospf-af-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
      }
    }
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      type uint32 {
        tailf:info "<0-4294967295>;;32-bit tag value";
      }
    }
    leaf metric-type {
      tailf:info "Metric type for redistributed routes";
      type enumeration {
        enum "1" {
          tailf:info "Set OSPF External Type 1 metrics";
        }
        enum "2" {
          tailf:info "Set OSPF External Type 2 metrics";
        }
      }
    }
    leaf route-policy {
      tailf:info "Route policy reference";
      type string {
        tailf:info "WORD;;Name of the policy";
      }
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:route-policy/name";
      }
    }
  }

  // router-isis-af-redistribute-grouping
  grouping router-isis-af-redistribute-grouping {
    leaf level {
      tailf:cli-drop-node-name;
      type enumeration {
        enum level-1 {
          tailf:info "Redistribute routes into level 1 only";
        }
        enum level-1-2 {
          tailf:info "Redistribute routes into both levels";
        }
        enum level-2 {
          tailf:info "Redistribute routes into level 2 only (the default)";
        }
      }
    }
    uses router-af-redistribute-grouping;
    leaf metric-type {
      tailf:info "Metric type for redistributed routes";
      type enumeration {
        enum external {
          tailf:info "External metric type";
        }
        enum internal {
          tailf:info "Internal metric type";
        }
        enum rib-metric-as-external {
          tailf:info "External metric type and use RIB metric";
        }
        enum rib-metric-as-internal {
          tailf:info "Internal metric type and use RIB metric";
        }
      }
    }
  }

  // router ospf * / authentication
  // router ospf * / message-digest-key
  // router-ospf-area-grouping
  grouping router-ospf-authentication-grouping {

    // router ospf * / authentication
    // router ospf * / area * / authentication
    container authentication {
      tailf:info "Enable authentication";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      choice  authentication-choice {
        container message-digest {
          tailf:info "Use message-digest authentication";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf keychain {
            tailf:info "Specify keychain name";
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:key/chain/name";
            }
            type string {
              tailf:info "WORD;;The keychain name";
            }
          }
        }
        leaf "null" {
          tailf:info "Use no authentication";
          type empty;
        }
      }
    }

    // router ospf * / message-digest-key
    // router ospf * / area * / message-digest-key
    list message-digest-key {
      tailf:info "Message digest authentication password (key)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:info "Key ID";
        tailf:cli-suppress-range;
        type uint8 {
          tailf:info "<1-255>;;Key ID";
          range "1..255";
        }
      }
      container md5 {
        tailf:info "Use MD5 algorithm";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping;
      }
    }
  }

  // router bgp * / neighbor * / bfd
  // router bgp * / session-group * / bfd
  // router ospf * / area * / bfd
  // router ospf * / area * / interface * / bfd
  // router pim / address-family ipv4 / interface * / bfd
  grouping bfd-common-parameters-grouping {
    container bfd {
      tailf:info "Configure BFD parameters";

      // ... bfd minimum-interval
      leaf minimum-interval {
        tailf:info "Hello interval";
        type uint16 {
          tailf:info "<3-30000>;;hello interval in milli-seconds";
          range "3..30000";
        }
      }

      // ... bfd fast-detect
      container fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf disable {
          tailf:info "Prevent bfd settings from being inherited "+
            "from the parent";
          type empty;
        }
      }

      // ... bfd multiplier
      leaf multiplier {
        tailf:info "Detect multiplier";
        type uint8 {
          tailf:info "<2-50>;;Detect multiplier";
          range "2..50";
        }
      }
    }
  }


  // router ospf *
  // router ospf * / area *
  // router ospf * / area * / interface *
  grouping router-ospf-common-area-grouping {

    // router ospf * / cost
    leaf cost {
      tailf:info "Interface cost";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-65535>;;Cost";
        range "1..65535";
      }
    }

    // router ospf * / passive
    container passive {
      tailf:info "Enable/Disable passive";
      presence true;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      leaf mode {
        tailf:info "Enable/Disable passive mode";
        tailf:cli-drop-node-name;
        type enumeration {
          enum disable {
            tailf:info "Disable passive";
          }
          enum enable {
            tailf:info "Enable passive";
          }
        }
      }
    }

    // router ospf * / priority
    leaf priority {
      tailf:info "Router priority";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Priority";
      }
    }

    // router ospf * / mtu-ignore
    container mtu-ignore {
      tailf:info "Enable/Disable ignoring of MTU in DBD packets";
      presence true;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      leaf mode {
        tailf:cli-drop-node-name;
        type enumeration {
          enum disable {
            tailf:info "Disable ignoring of MTU in DBD packets";
          }
          enum enable {
            tailf:info "Ignores the MTU in DBD packets";
          }
        }
      }
    }

    // router ospf * / dead-interval
    leaf dead-interval {
      tailf:info "Dead interval time";
      type uint16 {
        tailf:info "<1-65535>;;Seconds";
      }
    }

    // router ospf * / fast-reroute
    container fast-reroute {
      tailf:info "IP Fast Reroute";

      // router ospf * / fast-reroute per-link
      choice per-link-or-prefix {
        leaf disable {
          tailf:info "Disable IP Fast Reroute";
          type empty;
        }

        container per-link {
          tailf:info "Per-link Computation";
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          presence true;
          leaf enable {
            type empty;
          }
        }

        // router ospf * / fast-reroute per-prefix
        leaf per-prefix {
          tailf:info "Per-prefix Computation";
          type empty;
        }
      }

      // router ospf * / fast-reroute per-prefix remote-lfa tunnel
      container per-prefix-conf {
        tailf:cli-drop-node-name;
        container per-prefix {
          tailf:info "Per-prefix Computation";
          tailf:cli-incomplete-no;
          tailf:cli-incomplete-command;
          container remote-lfa {
            tailf:info "Remote LFA computation";
            container tunnel {
              tailf:info "Enable remote LFA computation using tunnels";
              leaf mpls-ldp {
                tailf:info "MPLS LDP tunnel";
                type empty;
              }
            }
          }
        }
      }
    }

    // router ospf * / hello-interval
    leaf hello-interval {
      tailf:info "Time between HELLO packets";
      type uint16 {
        tailf:info "<1-65535>;;Seconds";
      }
    }
  }

  // router ospf * / area * / X
  // router ospf * / area * / interface * / X
  grouping router-ospf-area-grouping {

    uses bfd-common-parameters-grouping;

    uses router-ospf-common-area-grouping;

    // FIXME: This shouldn't be shared between ospf and ospfv3
    // (but since it was here, we don't move it for now)
    uses router-ospf-authentication-grouping;

    // router ospf * / area * / network
    leaf network {
      tailf:info "Network type";
      tailf:cli-full-command;
      type enumeration {
        enum broadcast {
          tailf:info "Specify OSPF broadcast multi-access network";
        }
        enum non-broadcast {
          tailf:info "Specify OSPF NBMA network";
        }
        enum point-to-multipoint {
          tailf:info "Specify OSPF point-to-multipoint network";
        }
        enum point-to-point {
          tailf:info "Specify OSPF point-to-point network";
        }
      }
    }

    // router ospf * / area * / mpls
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";

      // router ospf * / area * / mpls ldp
      container ldp {
        tailf:info "Configure LDP parameters";

        // router ospf * / area * / mpls ldp sync
        container sync {
          tailf:info "Enable LDP IGP synchronization on interfaces";
          presence true;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          leaf disable {
            tailf:info "Disable MPLS LDP sync";
            type empty;
          }
        }

        // router ospf * / area * / mpls ldp auto-config
        leaf auto-config {
          tailf:info "Enable LDP IGP interface auto-configuration";
          tailf:cli-full-command;
          type empty;
        }

        // router ospf * / area * / mpls ldp sync-igp-shortcuts
        container sync-igp-shortcuts {
          tailf:info "LDP sync for igp-shortcut tunnels";
          presence true;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          leaf disable {
            tailf:info "Disable MPLS LDP sync igp-shortcuts";
            type empty;
          }
        }
      }

      // router ospf * / area * / mpls traffic-eng
      leaf traffic-eng {
        tailf:info "Configure an ospf area to run MPLS Traffic Engineering";
        type empty;
      }
    }

    // router ospf * / area * / prefix-sid
    container prefix-sid {
      tailf:info "Prefix SID Configuration";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      choice prefix-sid-choice {
        leaf absolute {
          tailf:info "SID value";
          tailf:cli-reset-container;
          type uint32 {
            tailf:info "<16000-1048575>;;SID label";
            range "16000..1048575";
          }
        }
        leaf index {
          tailf:info "SID Index";
          tailf:cli-reset-container;
          type uint32 {
            tailf:info "<0-1048575>;;SID Index";
            range "0..1048575";
          }
        }
      }
      leaf explicit-null {
        tailf:info "Force penultimate hop to send explicit-null label";
        type empty;
      }
    }

    // router ospf * / area * / distribute-list * in
    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Filter incoming routing updates";
          }
        }
      }
      leaf route-policy {
        tailf:info "Route Policy to filter OSPF prefixes";
        tailf:cli-prefix-key;
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Access-list name. "+
            "disable-inheritance means use no access list";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
        }
      }
    }

    // router ospf * / area * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key address;
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Neighbor address (name)";
        }
      }
      // router ospf * / area * / neighbor * priority
      leaf priority {
        tailf:info "OSPF priority of non-broadcast neighbor";
        type uint8 {
          tailf:info "<0-255>;;Priority";
        }
      }
    }

    // router ospf * / area * / nssa
    container nssa {
      tailf:info "Specify area as a NSSA area";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;

      // router ospf * / area * / nssa no-redistribution
      leaf no-redistribution {
        tailf:info "No redistribution into this NSSA area";
        type empty;
      }

      // router ospf * / area * / nssa default-information-originate
      leaf default-information-originate {
        tailf:info "Originate Type 7 default into NSSA area";
        type empty;
      }

      // router ospf * / area * / nssa metric
      leaf metric {
        tailf:info "OSPF default metric";
        when "../default-information-originate";
        type uint32 {
          tailf:info "<0-16777214>;;OSPF metric";
          range "0..16777214";
        }
      }

      // router ospf * / area * / nssa metric-type
      leaf metric-type {
        tailf:info "OSPF metric type for default routes";
        when "../default-information-originate";
        type uint8 {
          tailf:info "<1-2>;;Link State metric type";
          range "1..2";
        }
      }

      // router ospf * / area * / nssa no-summary
      leaf no-summary {
        tailf:info "Do not send summary LSA into NSSA";
        type empty;
      }
    }
  }

  // router ospf *
  // router ospfv3 *
  grouping router-ospfvx-common-pre-grouping {

    // router ospf * / nsr
    leaf nsr {
      tailf:info "Enable NSR for all VRFs in this process";
      tailf:cli-full-command;
      type empty;
    }

    // router ospf * / router-id
    leaf router-id {
      tailf:info "Specify the router-id for this OSPF process";
      tailf:cli-full-command;
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF router-id in IPv4 address format";
      }
    }

    // router ospf * / cost
    uses router-ospf-common-area-grouping;

    // router ospf * / log
    container log {
      tailf:info "Log ospf info";
      container adjacency {
        tailf:info "Log adjacency state info";
        container changes {
          tailf:info "Log changes";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf changes-state {
            tailf:info "Log all state changes or disable logging";
            tailf:cli-drop-node-name;
            type enumeration {
              enum detail {
                tailf:info "Log all state changes";
              }
              enum disable {
                tailf:info "Disable logging";
              }
            }
          }
        }
      }
    }

    // router ospf * / timers
    container timers {
      tailf:info "Adjust routing timers";

      // router ospf * / timers throttle
      container throttle {
        tailf:info "OSPF throttle timers";

        // router ospf * / timers throttle lsa all
        container lsa {
          tailf:info "LSA throttle timers";
          container all {
            tailf:info "For all types of OSPF LSAs";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf delay {
              tailf:info "Delay to generate first occurrence of LSA in milliseconds";
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<0-600000>;;Delay to generate first occurrence "
                  +"of LSA in milliseconds";
                range "0..600000";
              }
            }
            leaf min-delay {
              tailf:info "Minimum delay between originating the same LSA in milliseconds";
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-600000>;;Minimum delay between originating "
                  +"the same LSA in milliseconds";
                range "1..600000";
              }
            }
            leaf max-delay {
              tailf:info "Maximum delay between originating the same LSA in milliseconds";
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-600000>;;Maximum delay between originating "
                  +"the same LSA in milliseconds";
                range "1..600000";
              }
            }
          }
        }

        // router ospf * / timers throttle spf
        container spf {
          tailf:info "OSPF SPF throttle timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf delay {
            tailf:info "Delay between receiving a change to SPF calculation in milliseconds";
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-600000>;;Delay between receiving a change "
                +"to SPF calculation in milliseconds";
              range "1..600000";
            }
          }
          leaf min-delay {
            tailf:info "Delay between first and second SPF calculation in milliseconds";
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-600000>;;Delay between first and second SPF calculation in milliseconds";
              range "1..600000";
            }
          }
          leaf max-delay {
            tailf:info "Maximum wait time in milliseconds for SPF calculations";
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-600000>;;Maximum wait time in milliseconds for SPF calculations";
              range "1..600000";
            }
          }
        }
      }

      // router ospf * / timers lsa
      container lsa {
        tailf:info "OSPF global LSA timers";
        leaf min-arrival {
          tailf:info "OSPF MinLSArrival timer";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-600000>;;The minimum interval in millisec "+
              "between accepting the same LSA";
            range "0..600000";
          }
        }
      }

      // router ospf * / timers pacing floow
      container pacing {
        tailf:info "OSPF pacing timers";
        leaf flood {
          tailf:info "OSPF flood pacing timer";
          type uint8 {
            tailf:info "<5-100>;;Interval in msec to pace flooding on all interfaces";
            range "5..100";
          }
        }
      }
    }

    // router ospf * / auto-cost
    container auto-cost {
      tailf:info "Calculate OSPF interface cost according to bandwidth";
      tailf:cli-delete-when-empty;
      presence true;

      // router ospf * / auto-cost reference-bandwidth
      leaf reference-bandwidth {
        tailf:info "Specify reference bandwidth for OSPF cost computations";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967>;;The reference bandwidth in terms of "+
            "Mbits per second";
          range "1..4294967";
        }
      }
    }

    // router ospf * / maximum
    container maximum {
      tailf:info "Set OSPF limits";

      // router ospf * / maximum paths
      leaf paths {
        tailf:info "Limit number of paths";
        type uint8 {
          tailf:info "<1-64>;;Maximum number of paths per route";
          range "1..64";
        }
      }

      // router ospf * / maximum interfaces
      leaf interfaces {
        tailf:info "Limit number of interfaces";
        type uint32 {
          tailf:info "<1-4294967295>;;Maximum number of interfaces";
        }
      }

      // router ospf * / maximum redistributed-prefixes
      container redistributed-prefixes {
        tailf:info "Limit number of redistributed prefixes";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Maximum number of prefixes "+
              "redistributed into OSPF";
          }
        }
        leaf threshold-value {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
            range "1..100";
          }
        }
        leaf warning-only {
          tailf:info "Only give warning messsage when limit is exceeded";
          type empty;
        }
      }
    }

    // router ospf * / bfd
    container bfd {
      tailf:info "Configure BFD parameters";

      // router ospf * / bfd fast-detect
      leaf fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-full-command;
        type empty;
      }

      // router ospf * / bfd minimum-interval
      leaf minimum-interval {
        tailf:info "Hello interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-30000>;;hello interval in milli-seconds";
          range "0..30000";
        }
      }

      // router ospf * / bfd multiplier
      leaf multiplier {
        tailf:info "Detect multiplier";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-30>;;Detect multiplier";
        }
      }
    }

    // router ospf * / network
    container network {
      tailf:info "Network type";
      choice network-choice {
        leaf broadcast {
          tailf:info "Specify OSPF broadcast multi-access network";
          type empty;
        }
        leaf non-broadcast {
          tailf:info "Specify OSPF NBMA network";
          type empty;
        }
        container point-to-multipoint {
          tailf:info "Specify OSPF point-to-multipoint network";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf non-broadcast {
            tailf:info "Specify OSPF non-broadcast point-to-multipoint "+
              "network";
            type empty;
          }
        }
        leaf point-to-point {
          tailf:info "Specify OSPF point-to-point network";
          type empty;
        }
      }
    }

    // router ospf * / domain-id
    container domain-id {
      tailf:info "Specify domain id";

      // router ospf * / domain-id type
      container primary {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses router-ospf-domain-id-grouping;
      }

      // router ospf * / domain-id secondary
      container secondary {
        tailf:info "OSPF secondary domain-id";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses router-ospf-domain-id-grouping;
      }
    }

    // router ospf * / default-information originate
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf always {
          tailf:info "Always advertise default route";
          type empty;
        }
        uses router-ospf-af-redistribute-grouping;
      }
    }

    // router ospf * / spf prefix-priority
    container spf {
      tailf:info "SPF configuration";
      container prefix-priority {
        tailf:info "Configure SPF prefix priority route policy";
        leaf route-policy {
          tailf:info "Specify the route-policy to prioritize route install";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
        }
      }
    }

    // router ospf * / distance
    container distance {
      tailf:info "Define an administrative distance";

      // router ospf * / distance ?
      leaf weight {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Administrative distance";
          range "1..255";
        }
      }

      // router ospf * / distance *
      list distance-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip-address wildcard-mask";
        leaf weight {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Source address";
          }
        }
        leaf wildcard-mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Wild Card bits";
          }
        }
        leaf access-list-name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Access list";
          }
        }
      }

      // router ospf * / distance ospf
      container ospf {
        tailf:info "OSPF distance";
        container external {
          tailf:info "External type 5 and type 7 routes";
          leaf distance {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Distance for external type 5 and type 7 routes";
              range "1..255";
            }
          }
        }
      }
    }

    // router ospf * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router ospf * / redistribute connected
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-af-redistribute-grouping;
      }

      // router ospf * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF instance name";
          }
        }
        uses router-ospf-af-redistribute-grouping;
      }

      // router ospf * / redistribute bgp *
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:info "AS number in 2-byte, 4-byte asdot and asplain";
          type string {
            tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
          }
        }
        leaf preserve-med {
          tailf:info "Preserve med of BGP routes";
          type empty;
        }
        uses router-ospf-af-redistribute-grouping;
      }

      // router ospf * / redistribute static
      container static {
        tailf:info "Static route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-af-redistribute-grouping;
      }

      // router ospf * / redistribute isis *
      list isis {
        tailf:info "ISO IS-IS";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;IS-IS instance name";
          }
        }
        leaf level {
          tailf:cli-drop-node-name;
          type enumeration {
            enum level-1 {
              tailf:info "Redistribute routes into level 1 only";
            }
            enum level-1-2 {
              tailf:info "Redistribute routes into both levels";
            }
            enum level-2 {
              tailf:info "Redistribute routes into level 2 only (the default)";
            }
          }
        }
        uses router-ospf-af-redistribute-grouping;
      }
    }
  }


  // router ospf *
  // router ospfv3 *
  grouping router-ospfvx-common-post-grouping {

    // router ospf * / area *
    list area {
      tailf:info "Enter the OSPF area configuration submode";
      tailf:cli-mode-name "config-ospf-ar";
      key id;
      leaf id {
        tailf:info "Area id";
        tailf:cli-suppress-range;
        type ospf-area-type;
      }
      uses router-ospf-area-grouping;

      // router ospf * / area * / stub
      container stub {
        tailf:info "Specify the area as a stub area";
        tailf:cli-delete-when-empty;
        presence true;
        // router ospf * / area * / stub nu-summary
        leaf no-summary {
          tailf:info "Do not send summary LSA into stub area";
          type empty;
        }
      }

      // router ospf * / area * / multi-area-interface *
      list multi-area-interface {
        tailf:info "Enable multi-area adjacency on this interface";
        tailf:cli-mode-name "config-ospf-ar-mif";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        uses router-ospf-area-grouping;
      }

      // router ospf * / area * / interface *
      list interface {
        tailf:info "Enable routing on an interface";
        tailf:cli-mode-name "config-ospf-ar-if";
        key name;
        leaf name {
          tailf:info "Interface Name";
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        uses router-ospf-area-grouping;
      }
    }
  }


  // router ospf *
  // router ospf * / vrf *
  grouping router-ospf-grouping {

    // router ospf * / ?
    uses router-ospfvx-common-pre-grouping;

    // router ospf * / distribute-list
    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Filter incoming routing updates";
          }
          enum "out" {
            tailf:info "Filter outgoing routing updates";
          }
        }
      }
      leaf route-policy {
        tailf:info "Route Policy to filter OSPF prefixes";
        tailf:cli-prefix-key;
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Access-list name. "+
            "disable-inheritance means use no access list";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
        }
      }
    }

    // router ospf * / distribute-list * <proto>
    container distribute-list-proto {
      tailf:cli-drop-node-name;
      list distribute-list {
        tailf:info "Filter networks in routing updates";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        key direction;
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-disallow-value "out";
          type string {
            tailf:info "WORD;;Access-list name. "+
              "disable-inheritance means use no access list";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
          }
        }
        leaf direction {
          type enumeration {
            enum "out" {
              tailf:info "Filter outgoing routing updates";
            }
          }
        }
        leaf connected {
          tailf:cli-break-sequence-commands;
          tailf:info "Connected";
          type empty;
        }
        leaf static {
          tailf:info "Static routes";
          type empty;
        }
        leaf bgp {
          tailf:info "Border Gateway Protocol (BGP)";
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;Autonomous system number";
              range "1..4294967295";
            }
            type string {
              tailf:info "<1.0-XX.YY>;;Autonomous system number";
              pattern '[0-9]+\.[0-9]+';
            }
          }
        }
        leaf ospf {
          tailf:info "Open Shortest Path First (OSPF)";
          type string {
            tailf:info "WORD;;OSPF instance name";
          }
        }
      }
    }

    uses router-ospfvx-common-post-grouping;

    // router ospf * / nsf
    container nsf {
      tailf:info "Enable Cisco Non Stop Forwarding";
      // router ospf * / nsf ietf
      container ietf {
        tailf:info "Enable ietf graceful restart";
        tailf:cli-display-separated;
        presence true;
        container helper {
          tailf:info "router's helper support level";
          leaf disable {
            tailf:info "router's helper support disabled";
            type empty;
          }
        }
      }
      // router ospf * / nsf cisco
      container cisco {
        tailf:info "Enable Cisco Non Stop Forwarding";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        container enforce {
          tailf:info "Cancel NSF restart when non-NSF-aware "+
            "neighbors detected";
          leaf global {
            tailf:info "For the whole OSPF process";
            type empty;
          }
        }
      }
    }

    // router ospf * / queue
    container queue {
      tailf:info "Adjust OSPF input queue";

      // router ospf * / queue limit
      container limit {
        tailf:info "High watermark for incoming priority events";
        // router ospf * / queue limit low
        leaf low {
          tailf:info "High watermark for incoming low priority events "+
            "(DBD/LSUpd/Req)";
          type uint16 {
            tailf:info "<1000-30000>;;DBD/LS Update/Req packets are dropped "+
              "when incoming event queue exceeds this value";
            range "1000..30000";
          }
        }
        // router ospf * / queue limit high
        leaf high {
          tailf:info "High watermark for incoming high priority events "+
            "(hello)";
          type uint16 {
            tailf:info "<1000-30000>;;Hello events are dropped when incoming "+
              "event queue exceeds this value";
            range "1000..30000";
          }
        }
        // router ospf * / queue limit medium
        leaf medium {
          tailf:info "High watermark for incoming medium priority events "+
            "(LSA ACK)";
          type uint16 {
            tailf:info "<1000-30000>;;LSA ACKs are dropped when incoming "+
              "event queue exceeds this value";
            range "1000..30000";
          }
        }
      }
    }

    // router ospf * / ignore lsa mospf
    container ignore {
      tailf:info "Do not complain about specific event";
      container lsa {
        tailf:info "Do not complain upon receiving LSA of the specified type";
        leaf mospf {
          tailf:info "MOSPF Type 6 LSA";
          type empty;
        }
      }
    }

    // router ospf * / segment-routing
    container segment-routing {
      tailf:info "Segment Routing configuration";

      // router ospf * / segment-routing global-block
      container global-block {
        tailf:info "MPLS label range for SID allocation";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf lower-bound {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16000-1048574>;;The lower bound of the SRGB";
            range "16000..1048574";
          }
        }
        leaf upper-bound {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16001-1048575>;;The upper bound of the SRGB";
            range "16001..1048575";
          }
        }
      }

      // router ospf * / segment-routing mpls
      // router ospf * / segment-routing disable
      choice mpls-disable-choice {
        leaf mpls {
          tailf:info "SR using MPLS dataplane";
          type empty;
        }
        leaf disable {
          tailf:info "Disable Segment Routing";
          type empty;
        }
      }

      // router ospf * / segment-routing forwarding mpls
      leaf forwarding {
        tailf:info "Enable Segment-routing forwarding on interfaces";
        type enumeration {
          enum disable {
            tailf:info "Disable advertising loopback as a stub network";
          }
          enum mpls {
            tailf:info "Use MPLS for Segment-routing forwarding";
          }
        }
      }

      // router ospf * / segment-routing sr-prefer
      container sr-prefer {
        tailf:info "Prefer segment routing labels over LDP labels";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;

        // router ospf * / segment-routing sr-prefer prefix-list
        leaf prefix-list {
          tailf:info "Filter prefixes for which SR preference is applied";
          type string {
            tailf:info "WORD;;Prefix-list name";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ipv4/prefix-list/name";
          }
        }
      }

      // router ospf * / segment-routing prefix-sid-map
      container prefix-sid-map {
        tailf:info "Configuring segment routing mapping server";

        // router ospf * / address-family * / segment-routing prefix-sid-map receive
        container receive {
          tailf:info "Control the usage of remote mapping server advertisements";
          presence true;
          leaf disable {
            tailf:info "Disable the usage of remote mapping server advertisements";
            type empty;
          }
        }

        // router ospf * / address-family * / segment-routing prefix-sid-map advertise-local
        leaf advertise-local {
          tailf:info "Advertise and use local mapping server entries";
          type empty;
        }
      }
    }

    // router ospf * / address-family ipv4
    container address-family {
      tailf:info "OSPF address family";
      container ipv4 {
        tailf:info "IPV4 address family";
        tailf:cli-delete-when-empty;
        presence true;
        leaf unicast {
          tailf:info "unicast topology";
          type empty;
        }
      }
    }

    // router ospf * / max-metric
    container max-metric {
      tailf:info "Set maximum metric";

      // router ospf * / max-metric router-lsa
      container router-lsa {
        tailf:info "Maximum metric in self-originated router-LSAs";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-max-metric-grouping;
      }

      // router ospf * / max-metric router-lsa on-startup
      container route-lsa-on-startup {
        tailf:cli-drop-node-name;
        container router-lsa {
          tailf:info "Maximum metric in self-originated router-LSAs";
          container on-startup {
            tailf:info "On startup";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            choice on-startup-choice {
              leaf time {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<5-86400>;;Time in seconds to originate router-LSA with max-metric";
                  range "5..86400";
                }
              }
              leaf wait-for-bgp {
                tailf:info "Let BGP decide when to originate router-LSA with normal metric";
                type empty;
              }
            }
            uses router-ospf-max-metric-grouping;
          }
        }
      }
    }
  }

  // router ospfv3 *
  // router ospfv3 * / vrf *
  grouping router-ospfv3-grouping {

    // router ospfv3 * / graceful-restart
    container graceful-restart {
      tailf:info "Enable Graceful-Restart";
      presence true;
    }

    // router ospfv3 * / ?
    uses router-ospfvx-common-pre-grouping;
    uses router-ospfvx-common-post-grouping;

    // router ospfv3 * / address-family ipv6
    container address-family {
      tailf:info "OSPF address family";
      container ipv6 {
        tailf:info "IPV6 address family";
        tailf:cli-delete-when-empty;
        presence true;
        leaf unicast {
          tailf:info "unicast topology";
          type empty;
        }
      }
    }
  }


  grouping router-ospf-max-metric-grouping {

    // router ospf * / max-metric router-lsa include-stub
    leaf include-stub {
      tailf:info "Set maximum metric for stub links in router-LSAs";
      type empty;
    }

    // router ospf * / max-metric router-lsa summary-lsa
    choice summary-lsa-choice {
      container summary-lsa-container {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf summary-lsa {
          type uint32 {
            tailf:info "<1-16777215>;;Overriding metric in summary-LSAs (default 16711680)";
            range "1..16777215";
          }
        }
      }
      leaf summary-lsa {
        tailf:info "Override summary-lsa metric with max-metric value";
        type empty;
      }
    }

    // router ospf * / max-metric router-lsa external-lsa
    choice external-lsa-choice {
      container external-lsa-container {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf external-lsa {
          type uint32 {
            tailf:info "<1-16777215>;;Overriding metric in external-LSAs (default 16711680)";
            range "1..16777215";
          }
        }
      }
      leaf external-lsa {
        tailf:info "Override external-lsa metric with max-metric";
        type empty;
      }
    }
  }


  // router isis * / address-family ipv4 unicast /
  // router isis * / address-family ipv6 unicast /
  // router isis * / interface * / address-family ipv4 unicast /
  // router isis * / interface * / address-family ipv6 unicast /
  grouping router-isis-common-af-grouping {

    // router isis * / address-family * / metric
    leaf metric {
      tailf:info "Configure metric";
      tailf:cli-full-command;
      type union {
        type uint32 {
          tailf:info "<1-16777214>;;Default metric: <1-63> "+
            "for narrow, <1-16777214> for wide";
          range "1..16777214";
        }
        type enumeration {
          enum maximum {
            tailf:info "Maximum wide metric. All routers will exclude "+
              "this link from their SPF";
          }
        }
      }
    }

    // router isis * / address-family * / metric * level *
    container metric-level {
      tailf:cli-drop-node-name;
      list metric {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key level;
        leaf level {
          tailf:info "Set metric for one level only";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-2>;;Set metric at this level only";
            range "1..2";
          }
        }
        leaf "value" {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<1-16777214>;;Default metric: <1-63> "+
                "for narrow, <1-16777214> for wide";
              range "1..16777214";
            }
            type enumeration {
              enum maximum {
                tailf:info "Maximum wide metric. All routers will exclude "+
                  "this link from their SPF";
              }
            }
          }
        }
      }
    }

    // router isis * / address-family * / fast-reroute
    container fast-reroute {
      tailf:info "Configure Fast ReRoute";

      choice fast-reroute-choice {
        // router isis * / address-family * / fast-reroute disable
        leaf disable {
          tailf:info "Disable IP Fast Reroute";
          type empty;
        }

        // router isis * / address-family * / fast-reroute per-prefix
        container per-prefix {
          tailf:info "Prefix dependent computation";
          tailf:cli-display-separated;
          presence true;

          // router isis * / address-family * / fast-reroute per-prefix level *
          leaf-list level {
            tailf:info "Configure FRR for one level only";
            tailf:cli-list-syntax;
            type uint8 {
              tailf:info "<1-2>;;Level";
              range "1..2";
            }
          }

          // router isis * / address-family * / fast-reroute per-prefix remote-lfa
          container remote-lfa {
            tailf:info "Enable remote LFA computation";
            container tunnel {
              tailf:info "Enable remote LFA computation using tunnels";
              container mpls-ldp {
                tailf:info "Use MPLS LDP tunnel to reach the remote LFA node";
                tailf:cli-display-separated;
                presence true;
              }
            }
          }

          // router isis * / address-family * / fast-reroute per-prefix ti-lfa
          container ti-lfa {
            tailf:info "Enable TI LFA computation";
            presence true;
          }
        }
      }
    }

    // router isis * / address-family * / mpls
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";

      // router isis * / address-family * / mpls ldp
      container ldp {
        tailf:info "Configure LDP parameters";
        leaf auto-config {
          tailf:info "Enable LDP IGP interface auto-configuration";
          type empty;
        }
        // router isis * / address-family * / mpls ldp sync
        container sync {
          tailf:info "Configure LDP ISIS synchronization";
          presence true;
          leaf level {
            type uint8 {
              tailf:info "<1-2>;;Set LDP synchronization at this level only";
              range "1..2";
            }
          }
        }
      }

      // router isis * / address-family * / mpls traffic-eng
      container traffic-eng {
        tailf:info "Routing protocol commands for MPLS Traffic "+
          "Engineering";

        // router isis * / address-family * / mpls traffic-eng level
        leaf level {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type enumeration {
            enum level-1 {
              tailf:info "Enable mpls traffic-eng at level 1";
            }
            enum level-1-2 {
              tailf:info "Enable mpls traffic-eng at both level 1 and 2";
            }
            enum level-2-only {
              tailf:info "Enable mpls traffic-eng at level 2";
            }
          }
        }

        // router isis * / address-family * / mpls traffic-eng router-id
        container router-id {
          tailf:info "Traffic Engineering stable IP address for system";
          uses interface-name-grouping;
        }

        // router isis * / address-family * / mpls traffic-eng multicast-intact
        leaf multicast-intact {
          tailf:info "Install non-TE nexthops in the RIB for use by multicast";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // router isis * / address-family * / monitor-convergence
    container monitor-convergence {
      tailf:info "Enables convergence monitoring";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-isis-af-rcmd";
      tailf:cli-delete-when-empty;
      presence true;

      // router isis * / address-family * / monitor-convergence / track-ip-frr
      leaf track-ip-frr {
        tailf:info "Enables Tracking IP-Frr Convergence";
        type empty;
      }
    }

    // router isis * / interface * / address-family ? unicast / tag
    leaf tag {
      tailf:info "Set interface tag";
      type uint32 {
        tailf:info "<1-4294967295>;;Interface tag";
      }
    }
  }

  // router isis * / address-family ipv4 unicast /
  // router isis * / address-family ipv6 unicast /
  grouping router-isis-af-grouping {

    // router isis * / address-family * / advertise passive-only
    container advertise {
      tailf:info "Control the advertisement of prefixes in LSPs";
      leaf passive-only {
        tailf:info "advertise prefixes of passive interfaces only";
        type empty;
      }
    }

    // router isis * / address-family * / ispf
    leaf ispf {
      tailf:info "Use incremental SPF (ISPF) to calculate network topology";
      type empty;
    }

    // router isis * / address-family * / ispf level
    container ispf-conf {
      tailf:cli-drop-node-name;
      container ispf {
        tailf:info "Use incremental SPF (ISPF) to calculate network topology";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf-list level {
          tailf:info "Enable ISPF for one level only";
          tailf:cli-list-syntax;
          type uint8 {
            tailf:info "<1-2>;;Enable ISPF for this level onl";
            range "1..2";
          }
        }
      }
    }

    // router isis * / address-family * / spf-interval
    container spf-interval {
      tailf:info "Route calculation scheduling parameters (FSPF, ISPF, PRC)";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf maximum-wait {
        tailf:info "Maximum delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
      leaf initial-wait {
        tailf:info "Initial delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
      leaf secondary-wait {
        tailf:info "Secondary delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
    }

    // router isis * / address-family ipv6 * / single-topology
    leaf single-topology {
      tailf:info "Run IPv6 Unicast using the standard (IPv4 Unicast) topology";
      type empty;
    }

    // router isis * / address-family * / adjacency-check disable
    container adjacency-check {
      tailf:info "Suppress checking of consistent AF support on received IIHs";
      leaf disable {
        tailf:info "Disable adjacency-checking";
        type empty;
      }
    }

    // router isis * / address-family * / spf
    container spf {
      tailf:info "SPF configuration";

      // router isis * / address-family * / spf prefix-priority *
      list prefix-priority {
        tailf:info "Configure a prefix priority list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key priority;
        leaf priority {
          type enumeration {
            enum critical {
              tailf:info "Specify critical priority prefixes";
            }
            enum high {
              tailf:info "Specify critical priority prefixes";
            }
            enum medium {
              tailf:info "Specify critical priority prefixes";
            }
          }
        }
        choice priority-type {
          leaf access-list {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Access-list name";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:ethernet-services/access-list/name";
            }
          }
          leaf tag {
            tailf:info "Specify a tag to indicate priority";
            type uint32 {
              tailf:info "<1-4294967295>;;The tag to indicate priority";
            }
          }
        }
      }
    }

    // router isis * / address-family * / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf external {
          tailf:info "Originate default prefix as an external route";
          type empty;
        }
        leaf route-policy {
          tailf:info "Route policy reference";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
        }
      }
    }

    // router isis * / address-family * / maximum-paths
    leaf maximum-paths {
      tailf:info "Maximum number of active parallel paths per route";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-64>;;Number of paths";
        range "1..64";
      }
    }

    // router isis * / address-family * / propagate level
    container propagate {
      tailf:info "Propagate routes between IS-IS levels";
      list level {
        tailf:info "Source level";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key "from level";
        leaf from {
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf into {
          tailf:info "into";
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          type empty;
        }
        leaf level {
          tailf:info "Destination level";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf route-policy {
          tailf:info "Propagate only specified routes";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
        }
      }
    }

    // router isis * / address-family * / microloop avoidance
    container microloop {
      tailf:info "Enable microloop protection feature";
      container avoidance {
        tailf:info "Enable local microloop avoidance";
        leaf rib-update-delay {
          tailf:info "Delay in milliseconds";
          type uint16 {
            tailf:info "<1000-65535>;;Set value of delay";
            range "1000..65535";
          }
        }
      }
    }

    // router isis * / address-family * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router isis * / address-family * / redistribute connected
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-isis-af-redistribute-grouping;
      }

      // router isis * / address-family * / redistribute static
      container static {
        tailf:info "Static route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-isis-af-redistribute-grouping;
      }

      // router isis * / address-family * / redistribute isis *
      list isis {
        tailf:info "IS-IS";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "IS-IS instance identifier";
          }
        }
        uses router-isis-af-redistribute-grouping;
      }

      // router isis * / address-family * / redistribute ospf
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF process ID";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type enumeration {
            enum "external" {
              tailf:info "Redistribute OSPF external routes";
            }
            enum "internal" {
              tailf:info "Redistribute OSPF internal routes";
            }
            enum "nssa-external" {
              tailf:info "Redistribute OSPF NSSA external routes";
            }
          }
        }
        uses router-isis-af-redistribute-grouping;
      }

      // router isis * / address-family * / redistribute ospfv3
      list ospfv3 {
        tailf:info "Open Shortest Path First (OSPFv3)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF process ID";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type enumeration {
            enum "external" {
              tailf:info "Redistribute OSPF external routes";
            }
            enum "internal" {
              tailf:info "Redistribute OSPF internal routes";
            }
            enum "nssa-external" {
              tailf:info "Redistribute OSPF NSSA external routes";
            }
          }
        }
        uses router-isis-af-redistribute-grouping;
      }
    }

    // router isis * / address-family * / segment-routing
    container segment-routing {
      tailf:info "Enable Segment Routing Feature";

      // router isis * / address-family * / segment-routing mpls
      container mpls {
        tailf:info "Enable Segment Routing Feature using MPLS encapsulation";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;

        // router isis * / address-family * / segment-routing mpls sr-prefer
        leaf sr-prefer {
          tailf:info "Prefer segment routing labels over LDP labels";
          type empty;
        }
      }

      // router isis * / address-family * / segment-routing prefix-sid-map
      container prefix-sid-map {
        tailf:info "Enable prefix-sid-map";

        // router isis * / address-family * / segment-routing prefix-sid-map receive
        container receive {
          tailf:info "Use remote mapping server advertisements";
          presence true;
        }

        // router isis * / address-family * / segment-routing prefix-sid-map advertise-local
        leaf advertise-local {
          tailf:info "Advertise active local prefix-SID mappings";
          type empty;
        }
      }
    }
  }

  // router isis *
  // router isis * / address-family ipv4 unicast /
  // router isis * / address-family ipv6 unicast /
  grouping router-isis-common-grouping {

    // router isis * / metric-style
    leaf metric-style {
      tailf:info "Use old-style (ISO 10589) or new-style packet formats";
      tailf:cli-full-command;
      type enumeration {
        enum narrow {
          tailf:info "Use old style of TLVs with narrow metric";
        }
        enum transition {
          tailf:info "Send and accept both styles of TLVs "
          +"during transition";
        }
        enum wide {
          tailf:info "Use new style of TLVs to carry wider metric";
        }
      }
    }

    // router isis * / metric-style ? level *
    container metric-style-list {
      tailf:cli-drop-node-name;
      list metric-style {
        tailf:info "Use old-style (ISO 10589) or new-style packet formats";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands;
        key level;
        leaf level {
          tailf:cli-expose-key-name;
          tailf:info "Set metric-style for one level only";
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf style {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum narrow {
              tailf:info "Use old style of TLVs with narrow metric";
            }
            enum transition {
              tailf:info "Send and accept both styles of TLVs "
              +"during transition";
            }
            enum wide {
              tailf:info "Use new style of TLVs to carry wider metric";
            }
          }
        }
      }
    }
  }

  // router isis * / interface * / address-family ipv4 unicast /
  // router isis * / interface * / address-family ipv6 unicast /
  grouping router-isis-if-af-grouping {

    // router isis * / interface * / address-family ipv4 unicast / prefix-sid
    container prefix-sid {
      tailf:info "Specify the Prefix Segment ID";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice value-choice {
        leaf absolute {
          tailf:info "Specify the absolute value of Prefix Segement ID";
          type uint32 {
            tailf:info "<0-1048575>;;The Prefix Segment ID value";
            range "0..1048575";
          }
        }
        leaf index {
          tailf:info "Specify the index of Prefix Segement ID";
          type uint32 {
            tailf:info "<0-1048575>;;The Prefix Segment ID value";
            range "0..1048575";
          }
        }
      }
      leaf explicit-null {
        tailf:info "Upstream neighbor must replace prefix-sid with explicit null label";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf n-flag-clear {
        tailf:info "Clear N-flag for the prefix-SID ";
        type empty;
      }
    }
  }

  // vty-pool-grouping
  grouping vty-pool-grouping {
    leaf first-vty {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<5-99>;;First VTY number";
      }
    }
    leaf last-vty {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<5-99>;;Last VTY number";
      }
    }
    leaf line-template {
      tailf:info "Line template to configure VTYs";
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;Name of line template";
      }
    }
  }


  // line console /
  // line default /
  // line template * /
  grouping line-grouping {

    // line * / flowcontrol hardware
    container flowcontrol {
      tailf:info "Configure flow control.";
      container hardware {
        tailf:info "Hardware flow control.";
        leaf direction {
          tailf:cli-drop-node-name;
          type enumeration {
            enum in {
              tailf:info "Inbound flow control.";
            }
            enum none {
              tailf:info "No flow control.";
            }
            enum out {
              tailf:info "Outbound flow control.";
            }
          }
        }
      }
    }

    // line * / parity
    leaf parity {
      tailf:info "Set the parity used.";
      type enumeration {
        enum even {
          tailf:info "Even parity.";
        }
        enum none {
          tailf:info "No parity.";
        }
        enum odd {
          tailf:info "Odd parity.";
        }
      }
    }

    // line * / databits
    leaf databits {
      tailf:info "Set the number of databits.";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<5-8>;;Number of databits the serial connection should use.";
      }
    }

    // line * / stopbits
    leaf stopbits {
      tailf:info "Set the stopbits used.";
      tailf:cli-full-command;
      type enumeration {
        enum "1" {
          tailf:info "One stopbit.";
        }
        enum "2" {
          tailf:info "Two stopbits.";
        }
      }
    }

    // line * / access-class
    container access-class {
      tailf:info "Filter connections based on an IP access list";
      leaf egress {
        tailf:info "Filter outgoing connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;IP access list name";
        }
      }
      leaf ingress {
        tailf:info "Filter incoming connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;IP access list name";
        }
      }
    }

    // line * / secret
    container secret {
      tailf:info "Provide a secure one way encrypted password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf "type" {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "5" {
            tailf:info "Specifies an ENCRYPTED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "LINE;;The ENCRYPTED 'enable' secret string";
        }
      }
    }

    // line * / password
    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum 0 {
            tailf:info "Specifies that an UNENCRYPTED password will follow";
          }
          enum 7 {
            tailf:info "Specifies that an encrypted password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) user password";
        }
      }
    }

    // line * / users group *
    container users {
      tailf:info "Users characteristics";
      list group {
        tailf:info "Group to which the user will belong";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the user group";
          }
        }
      }
    }

    // line * / accounting
    container accounting {
      tailf:info "Accounting parameters";
      //tailf:cli-diff-dependency "/cisco-ios-xr:aaa/accounting";

      // line * / accounting commands
      leaf commands {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default accounting list";
            }
          }
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
        }
      }

      // line * / accounting exec
      leaf exec {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default accounting list";
            }
          }
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
        }
      }
    }

    // line * / authorization
    container authorization {
      tailf:info "Authorization parameters";
      //tailf:cli-diff-dependency "/cisco-ios-xr:aaa/authorization";

      // line * / authorization commands
      leaf commands {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }

      // line * / authorization exec
      leaf exec {
        tailf:info "For starting an exec (shell)";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
    }

    // line * / timeout login response
    container timeout {
      tailf:info "Timeouts for the line";
      container login {
        tailf:info "Timeouts related to the login sequence";
        leaf response {
          tailf:info "Timeouts for any user input during login sequence";
          type uint16 {
            tailf:info "<0-300>;;Timeout in seconds (default 30 seconds)";
            range "0..300";
          }
        }
      }
    }

    // line * / timestamp
    container timestamp {
      tailf:info "To enable timestamp printing before each command.";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf disable {
        tailf:info "To disable timestamp printing before each command.";
        type empty;
      }
    }

    // line * / transport
    container transport {
      tailf:info "Define transport protocols for line";

      // line * / transport input
      leaf-list "input" {
        tailf:info "Define which protocols to use when connecting to the terminal server";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
          enum lat {
            //tailf:info
          }
          enum pad {
            tailf:info "X.3 PAD";
          }
          enum udptn {
            tailf:info "UDPTN async via UDP protocol";
          }
          enum rlogin {
            tailf:info "Unix rlogin protocol";
          }
        }
      }

      // line * / transport output
      leaf-list "output" {
        tailf:info "Define which protocols to use for outgoing connections";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }

      // line * / transport preferred
      leaf preferred {
        tailf:info "Specify the preferred protocol to use";
        tailf:cli-full-command;
        type enumeration {
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "Unix ssh protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
    }

    // line * / exec-timeout
    container exec-timeout {
      tailf:info "Set the EXEC timeout";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf minutes {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-35791>;;Timeout in minutes";
          range "0..35791";
        }
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-2147483>;;Timeout in seconds";
          range "0..2147483";
        }
      }
    }

    // line * / length
    leaf "length" {
      tailf:info "Set number of lines on a screen.";
      type uint16 {
        tailf:info "<0-512>;;Number of lines on screen (0 for no pausing).";
        range "0..512";
      }
    }

    // line * / width
    leaf width {
      tailf:info "Set width of the display terminal.";
      type uint16 {
        tailf:info "<0-512>;;Number of characters on a screen line.";
        range "0..512";
      }
    }

    // line * / login authentication
    container login {
      tailf:info "Enable password checking";
      //tailf:cli-diff-dependency "/cisco-ios-xr:aaa/authentication";
      leaf authentication {
        tailf:info "Authentication parameters";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
    }

    // line * / session-limit
    leaf session-limit {
      tailf:info "Set the number of outgoing connections";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-20>;;Number of outgoing connections";
        range "0..20";
      }
    }

    // line * / absolute-timeout
    leaf absolute-timeout {
      tailf:info "Set absolute timeout for line disconnection.";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-10000>;;Absolute timeout interval in minutes.";
        range "0..10000";
      }
    }

    // line * / telnet transparent
    container telnet {
      tailf:info "Telnet protocol-specific configuration";
      leaf transparent {
        tailf:info "Send a CR as a CR followed by a NULL instead of a CR followed by a LF";
        type empty;
      }
    }

    // line * / session-timeout
    container session-timeout {
      tailf:info "Set interval for closing connection when there is no input traffic";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf minutes {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-35791>;;Session timeout interval in minutes";
          range "0..35791";
        }
      }
      leaf "output" {
        tailf:info "Include output traffic as well as input traffic";
        type empty;
      }
    }

    // line * / escape-character
    leaf escape-character {
      tailf:info "Change the current line template's escape character";
      type string {
        tailf:info "WORD;;Escape character or its ASCII decimal equivalent";
      }
    }
  }

  // lpts-grouping
  grouping lpts-grouping {
    list flow {
      tailf:info "lpts flow type";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;flow type";
        }
      }
      leaf ospf-type {
        when "../name = 'ospf'";
        tailf:cli-drop-node-name;
        type enumeration {
          enum multicast {
            tailf:info "Multicast";
          }
          enum unicast {
            tailf:info "Unicast";
          }
        }
      }
      leaf ldp-type {
        when "../name = 'ldp'";
        tailf:cli-drop-node-name;
        type enumeration {
          enum tcp {
            tailf:info "TCP";
          }
          enum udp {
            tailf:info "UDP";
          }
        }
      }
      leaf rsvp-type {
        when "../name = 'rsvp'";
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum udp {
            tailf:info "UDP";
          }
        }
      }
      leaf raw-type {
        when "../name = 'raw'";
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum listen {
            tailf:info "Listen";
          }
        }
      }
      leaf udp-tcp-type {
        when "../name = 'udp' or ../name = 'tcp'" {
          tailf:dependency "../name";
        }
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum configured {
            tailf:info "Config peer";
          }
          enum listen {
            tailf:info "Listen";
          }
        }
      }
      leaf icmp-type {
        when "../name = 'icmp'";
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum application {
            tailf:info "Specific application packets";
          }
          enum control {
            tailf:info "Control packets";
          }
          enum generic {
            tailf:info "Generic application packets";
          }
          enum local {
            tailf:info "Local interest packets";
          }
        }
      }
      leaf "which" {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence; // not avail for all types
        tailf:cli-incomplete-command;
        type enumeration {
          enum "default" {
            tailf:info "Default";
          }
          enum known {
            tailf:info "Known";
          }
        }
      }
      leaf rate {
        tailf:info "Rate in PPS";
        type uint32 {
          tailf:info "<0-4294967295>;;Packets Per Second";
        }
      }
    }
  }

  grouping class-random-detect-grouping {
    leaf min-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-1073741823>;;Minimum threshold";
        range "0..1073741823";
      }
    }
    leaf min-threshold-unit {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type police-burst-units-type;
    }
    leaf max-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-1073741823>;;Maximum threshold";
        range "0..1073741823";
      }
    }
    leaf max-threshold-unit {
      tailf:cli-drop-node-name;
      type police-burst-units-type;
    }
  }

  // class-map-match-grouping
  grouping class-map-match-grouping {

    // class-map * / match access-group
    container access-group {
      tailf:info "Match access group";
      // class-map * / match access-group ipv4
      leaf ipv4 {
        tailf:info "IPv4 access list";
        tailf:cli-remove-before-change;
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
        }
      }
      // class-map * / match access-group ipv6
      leaf ipv6 {
        tailf:info "IPv6 access list";
        tailf:cli-remove-before-change;
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:ipv6/access-list/named-acl/name";
        }
      }
    }

    // class-map * / match any
    leaf any {
      tailf:info "Any packets";
      type empty;
    }

    // class-map * / match cos
    container cos {
      tailf:info "Match based on IEEE 802.1Q/ISL Class Of Service value";
      leaf-list cos-value {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
      // class-map * / match cos inner
      leaf-list inner {
        tailf:info "Match inner cos values (Upto 8 values)";
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
    }

    // class-map * / match destination-address
    container destination-address {
      tailf:info "Match based on destination address";

      // class-map * / match destination-address ipv4 *
      list ipv4 {
        tailf:info "IPv4 address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address mask";
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Address";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP subnet mask";
          }
        }
      }

      // class-map * / match destination-address mac
      leaf mac {
        tailf:info "MAC address";
        type string {
          tailf:info "H.H.H;;MAC Address to match";
        }
      }
    }

    // class-map * / match destination-port
    leaf-list destination-port {
      tailf:info "Match based on destination port";
      tailf:cli-flat-list-syntax;
      type string {
        tailf:info "<0-65535>;;Port or range x-y";
      }
    }

    // class-map * / match discard-class
    leaf-list discard-class {
      tailf:info "Match based on discard class (upto 8 Ids)";
      tailf:cli-flat-list-syntax;
      type uint16 {
        tailf:info "<0-7>;;Discard Class Id";
        range "0..7";
      }
    }

    // class-map * / match dscp
    container dscp {
      tailf:info "Match based on IP DSCP value (upto 8 values or ranges)";

      // class-map * / match dscp *
      leaf-list dscp-list {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        tailf:cli-full-command;
        ordered-by user;
        type dscp-type;
      }

      // class-map * / match dscp ipv4 *
      leaf-list ipv4 {
        tailf:info "IPV4 DSCP";
        tailf:cli-flat-list-syntax;
        tailf:cli-full-command;
        ordered-by user;
        type dscp-type;
      }

      // class-map * / match dscp ipv6 *
      leaf-list ipv6 {
        tailf:info "IPV6 DSCP";
        tailf:cli-flat-list-syntax;
        tailf:cli-full-command;
        ordered-by user;
        type dscp-type;
      }
    }

    // class-map * / match fr-de
    container fr-de {
      tailf:info "Match on Frame-relay DE bit";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf fr-de-value {
        tailf:cli-drop-node-name;
        type enumeration {
          enum "1" {
            tailf:info "<1-1>;;FR DE value";
          }
        }
      }
    }

    // class-map * / match frame-relay
    container frame-relay {
      tailf:info "Match based on frame-relay specific criteria";
      leaf-list dlci {
        tailf:info "Match frame-relay dlci value(s)";
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<16-1007>;;DLCI number";
          range "16..1007";
        }
      }
    }

    // class-map * / match mpls
    container mpls {
      tailf:info "Match based on MPLS specific values";
      container experimental {
        tailf:info "Match MPLS experimental values";
        leaf-list topmost {
          tailf:info "Match topmost label (Upto 8 values)";
          tailf:cli-flat-list-syntax;
          type uint8 {
            tailf:info "<0-7>;;MPLS experimental topmost label";
            range "0..7";
          }
        }
      }
    }

    // class-map * / match packet length
    container packet {
      tailf:info "Layer 3 Packet length";
      leaf-list "length" {
        tailf:info "Layer 3 Packet length";
        tailf:cli-flat-list-syntax;
        type string {
          tailf:info "<0-65535>;;IP packet length, value or range x-y";
        }
      }
    }

    // class-map * / match precedence
    container precedence {
      tailf:info "Match based on IP precedence values";

      // class-map * / match precedence ipv4
      leaf-list ipv4 {
        tailf:info "IPV4 precedence";
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }

      // class-map * / match precedence ipv6
      leaf-list ipv6 {
        tailf:info "IPV6 precedence";
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }

      // class-map * / match precedence
      leaf-list "list" {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }
    }

    // class-map * / match protocol
    leaf-list protocol {
      tailf:info "Match based on L3 protocol (Upto 8 values or ranges)";
      tailf:cli-flat-list-syntax;
      max-elements 8;
      type union {
        type uint8 {
          tailf:info "<0-255>;;An IP Protocol Number";
        }
        type string {
          tailf:info "<0-255>-<0-255>;;Lower-Upper limit of protocol range "+
            "to match";
          pattern '[0-9]+\-[0-9]+';
        }
        type enumeration {
          enum ahp {
            tailf:info "Authentication Header Protocol";
            value 51;
          }
          enum eigrp {
            tailf:info "Cisco's EIGRP Routing Protocol";
            value 88;
          }
          enum esp {
            tailf:info "Encapsulation Security Payload";
            value 50;
          }
          enum gre {
            tailf:info "Cisco's GRE Tunneling";
            value 47;
          }
          enum icmp {
            tailf:info "Internet Control Message Protocol";
            value 1;
          }
          enum igmp {
            tailf:info "Internet Gateway Message Protocol";
            value 2;
          }
          enum igrp {
            tailf:info "Cisco's IGRP Routing Protocol";
            value 9;
          }
          enum ipinip {
            tailf:info "IP in IP tunneling";
            value 1001;
            //fixme:value?
          }
          enum ipv4 {
            tailf:info "Any IPv4 Protocol";
            value 0;
          }
          enum ipv6 {
            tailf:info "Any IPv6 Protocol";
            value 41;
          }
          enum ipv6icmp {
            tailf:info "IPV6Internet Control Message Protocol";
            value 58;
          }
          enum mpls {
            tailf:info "Any MPLS Packet";
            value 137;
          }
          enum nos {
            tailf:info "KA9Q NOS Compatible IP over IP Tunneling";
            value 94;
          }
          enum ospf {
            tailf:info "OSPF Routing Protocol";
            value 89;
          }
          enum pcp  {
            tailf:info "Payload Compression Protocol";
            value 108;
          }
          enum pim {
            tailf:info "Protocol Independent Multicast";
            value 103;
          }
          enum sctp {
            tailf:info "Stream Control Transmission Protocol";
            value 132;
          }
          enum tcp {
            tailf:info "Transport Control Protocol";
            value 6;
          }
          enum udp {
            tailf:info "User Datagram Protocol";
            value 17;
          }
        }
      }
    }

    // class-map * / match qos-group
    leaf-list qos-group {
      tailf:info "Match based on QoS Group (upto 8 Ids or ranges)";
      tailf:cli-flat-list-syntax;
      type uint16 {
        tailf:info "<0-63>;;Qos Group Id";
        range "0..63";
      }
    }

    // class-map * / match source-address
    container source-address {
      tailf:info "Match based on source address";

      // class-map * / match source-address ipv4 *
      list ipv4 {
        tailf:info "IPv4 address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address mask";
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Address";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP subnet mask";
          }
        }
      }

      // class-map * / match source-address mac
      leaf mac {
        tailf:info "MAC address";
        type string {
          tailf:info "H.H.H;;MAC Address to match";
        }
      }
    }

    // class-map * / match source-port
    leaf-list source-port {
      tailf:info "Match based on source port";
      tailf:cli-flat-list-syntax;
      type string {
        tailf:info "<0-65535>;;Port or range x-y";
      }
    }

    // class-map * / match vlan
    container vlan {
      tailf:info "Match based on Vlan Ids (Upto 8 values or ranges)";

      // class-map * / match vlan *
      leaf-list vlan-list {
        tailf:cli-drop-node-name;
        tailf:cli-range-list-syntax;
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-4094>;;Vlan Id";
          range "1..4094";
        }
      }

      // class-map * / match vlan inner *
      leaf-list inner {
        tailf:cli-range-list-syntax;
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-4094>;;Vlan Id";
          range "1..4094";
        }
      }
    }

    // class-map * / match vpls
    container vpls {
      tailf:info "Match based on VPLS fields";
      // class-map * / match vpls control
      leaf control {
        tailf:info "VPLS Control";
        tailf:cli-full-command;
        type empty;
      }
      // class-map * / match vpls broadcast
      leaf broadcast {
        tailf:info "VPLS Broadcast";
        tailf:cli-full-command;
        type empty;
      }
      leaf known {
        tailf:info "VPLS Known";
        type empty;
      }
      leaf multicast {
        tailf:info "VPLS Multicast";
        type empty;
      }
      leaf unknown {
        tailf:info "VPLS Unknown";
        type empty;
      }
    }

    // class-map * / match dei
    leaf dei {
      tailf:info "Match based on DEI bit (0/1)";
      type uint8 {
        tailf:info "0-1;;DEI value";
        range "0..1";
      }
    }
  }


  // interface * / logging events lsp-status
  // mpls traffic-eng / attribute-set * logging events lsp-status
  grouping logging-events-lsp-status-grouping {
    container lsp-status {
      tailf:info "Enable interface LSP state change alarms";
      leaf reoptimize {
        tailf:info "Enable interface LSP REOPT change alarms";
        type empty;
      }
      leaf state {
        tailf:info "Enable interface LSP UP/DOWN change alarms";
        type empty;
      }
      leaf reroute {
        tailf:info "Enable interface LSP REROUTE change alarms";
        type empty;
      }
      leaf insufficient-bandwidth {
        tailf:info "Enable Syslog for setup/reopt failure due to bandwidth";
        type empty;
      }
      leaf bw-change {
        tailf:info "Enable interface LSP BANDWIDTH change alarms";
        type empty;
      }
    }
  }

  // grouping interface-ipv6-nd-prefix-list-grouping
  grouping interface-ipv6-nd-prefix-list-grouping {
    choice prefix-choices {
      container prefix-lifetime {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf valid-lifetime {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;Valid Lifetime (secs)";
              range "0..4294967295";
            }
            type enumeration {
              enum infinite {
                tailf:info "Infinite Valid Lifetime";
              }
            }
          }
        }
        leaf preferred-lifetime {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;Preferred Lifetime (secs) "+
                "must be <= Valid Lifetime";
              range "0..4294967295";
            }
            type enumeration {
              enum infinite {
                tailf:info "Infinite Preferred Lifetime";
              }
            }
          }
        }
      }
      //TODO: at - Expire prefix at a specific time/date
      leaf no-adv {
        tailf:info "Do not advertise prefix";
        tailf:cli-full-command;
        type empty;
      }
      container options {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        leaf no-autoconfig {
          tailf:info "Do not use prefix for autoconfiguration";
          type empty;
        }
        leaf off-link {
          tailf:info "Do not use prefix for onlink determination";
          type empty;
        }
      }
    }
  }


  grouping interface-service-policy-content-grouping  {

    container account {
      tailf:info "Turn off layer specific accounting";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-optional-in-sequence;
      choice account-choice {
        leaf nolayer2 {
          tailf:info "Turn off l2 accounting";
          type empty;
        }
        leaf user-defined {
          tailf:info "User defined accounting";
          type int8 {
            tailf:info "<-63,+63>;;Overhead accounting value";
            range "-63..63";
          }
        }
      }
    }

    leaf subscriber-parent {
      tailf:info "Configure an svlan policy";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    leaf resource-id {
      when "../subscriber-parent";
      tailf:info "Configure a resource-id";
      tailf:cli-optional-in-sequence;
      type uint8 {
        tailf:info "<0-3>;;resource-id value";
        range "0..3";
      }
    }

    leaf shared-policy-instance {
      tailf:info "Configure a shared-policy-instance";
      type string {
        tailf:info "WORD;;Name of the shared-policy-instance";
      }
    }
  }

  // grouping interface-service-policy-grouping
  grouping interface-service-policy-grouping  {
    container service-policy {
      tailf:info "Configure QoS Service Policy";

      // interface * / service-policy input
      container "input" {
        tailf:info "Configure a policy in the input direction";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:info "Name of the service policy";
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:policy-map/name";
          }
        }
        uses interface-service-policy-content-grouping;
      }

      // interface * / service-policy output
      container "output" {
        tailf:info "direction of service policy application";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:info "Name of the service policy";
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:policy-map/name";
          }
        }
        uses interface-service-policy-content-grouping;
      }

      // interface * / service-policy type
      container "type" {
        tailf:info "Enter service policy type (default: qos)";

        // interface * / service-policy type lan-queuing
        container lan-queuing {
          tailf:info "Configure Lan Queuing Policy Map";
          leaf "input" {
            tailf:info "Assign policy-map to the input of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf "output" {
            tailf:info "Assign policy-map to the output of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
        }

        // interface * / service-policy type performance-monitor
        container performance-monitor {
          tailf:info "Configure media monitor service-policy type";
          leaf "input" {
            tailf:info "Assign policy-map to the input of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf "output" {
            tailf:info "Assign policy-map to the output of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf inline {
            tailf:info "Configure inline Service Policy";
            type enumeration {
              enum input {
                tailf:info "Assign policy-map to the input of an interface";
              }
              enum output {
                tailf:info "Assign policy-map to the output of an interface";
              }
            }
          }
        }

        // interface * / service-policy type test
        container test {
          tailf:info "Configure Test Policy Map";
          leaf "input" {
            tailf:info "Assign policy-map to the input of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf "output" {
            tailf:info "Assign policy-map to the output of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf "inline" {
            tailf:info "Configure inline Service Policy";
            type enumeration {
              enum input {
                tailf:info "Assign policy-map to the input of an interface";
              }
              enum output {
                tailf:info "Assign policy-map to the output of an interface";
              }
            }
          }
        }

        // interface * / service-policy type pbr
        container pbr {
          tailf:info "Policy based routing Service policy";
          leaf "input" {
            tailf:info "Configure a policy in the input direction";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
        }

        // interface * / service-policy control subscriber
        container control {
          tailf:info "control policy";
          leaf subscriber {
            tailf:info "subscriber policy";
            type string {
              tailf:info "WORD;;Policy name";
            }
          }
        }
      }
    }
  }

  // grouping interface-isis-grouping
  grouping interface-isis-grouping {
    // interface * / isis
    container isis {
      tailf:info "IS-IS commands";
      // interface * / isis authentication
      container authentication {
        tailf:info "ISIS authentication for interface related PDUs";
        // interface * / isis authentication mode
        container mode {
          tailf:info "Authentication mode for PDUs";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          leaf crypt {
            tailf:cli-drop-node-name;
            type enumeration {
              enum md5 {
                tailf:info "Keyed message digest";
              }
              enum text {
                tailf:info "Clear text password";
              }
            }
          }
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "ISIS authentication for level-1 PDUs";
              }
              enum level-2 {
                tailf:info "ISIS authentication for level-2 PDUs";
              }
            }
          }
        }
        // interface * / isis authentication key-chain
        leaf key-chain {
          tailf:info "Authentication key-chain";
          type string {
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:key/chain/name";
          }
        }
        // interface * / isis authentication send-only
        container send-only {
          tailf:info "Authentication send only, receive ignore";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "ISIS authentication for level-1 PDUs";
              }
              enum level-2 {
                tailf:info "ISIS authentication for level-2 PDUs";
              }
            }
          }
        }
      }
      // interface * / isis circuit-type
      leaf circuit-type {
        tailf:info "Configure circuit type for interface";
        tailf:cli-reset-container;
        type enumeration {
          enum level-1 {
            tailf:info "Level-1 only adjacencies are formed";
          }
          enum level-1-2 {
            tailf:info "Level-1-2 adjacencies are formed";
          }
          enum level-2-only {
            tailf:info "Level-2 only adjacencies are formed";
          }
        }
      }
      // interface * / isis hello
      container hello {
        tailf:info "Add padding to IS-IS hello packets";
        leaf padding {
          tailf:info "Pad hello packets";
          type empty;
        }
      }
      // interface * / isis metric
      container metric {
        tailf:info "Configure the metric for interface";
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf metric {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<1-16777214>;;Default metric";
              range "1..16777214";
            }
            type enumeration {
              enum maximum {
                tailf:info "Maximum metric. All routers will exclude "
                  +"this link from their SPF";
              }
            }
          }
        }
        leaf delay {
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Delay metric";
              range "1..16777214";
            }
          }
        }
        leaf expense {
          when "../delay != 'level-1' and ../delay != 'level-2'" {
            tailf:dependency "../delay";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Expense metric";
              range "1..16777214";
            }
          }
        }
        leaf error {
          when "../delay != 'level-1' and ../delay != 'level-2' "
            +"and ../expense != 'level-1' and ../expense != 'level-2'" {
            tailf:dependency "../delay";
            tailf:dependency "../expense";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Error metric";
              range "1..16777214";
            }
          }
        }
        leaf rest {
          when "../delay != 'level-1' and ../delay != 'level-2' "
            +"and ../expense != 'level-1' and ../expense != 'level-2'"
            +"and ../error != 'level-1' and ../error != 'level-2'" {
            tailf:dependency "../delay";
            tailf:dependency "../expense";
            tailf:dependency "../error";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
          }
        }
      }
    }
  }

  // grouping interface-switch-grouping
  grouping interface-switch-grouping {

    // interface * / channel-protocol
    container channel-protocol {
      tailf:info "Select the channel protocol (LACP, PAgP)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-512>;;Channel group number";
          range "1..512";
        }
      }
      leaf mode {
        tailf:info "Etherchannel Mode of the interface";
        type enumeration {
          enum active {
            tailf:info "Enable LACP unconditionally";
          }
          enum auto {
            tailf:info "Enable PAgP only if a PAgP device is detected";
          }
          enum desirable {
            tailf:info "Enable PAgP unconditionally";
          }
          enum on {
            tailf:info "Enable Etherchannel only";
          }
          enum passive {
            tailf:info "Enable LACP only if a LACP device is detected";
          }
        }
      }
    }

    // interface * / switch
    container "switch" {
      tailf:info "Configure switch link";
      container virtual {
        tailf:info "Configure virtual switch values";
        leaf link {
          tailf:info "Configure virtual switch number";
          type uint8 {
            tailf:info "<1-2>;;core switch number";
            range "1..2";
          }
        }
      }
    }

    // interface * / switchport
    // interface * / no switchport
    container switchport-conf {
      tailf:cli-drop-node-name;
      leaf switchport {
        tailf:info "Set switching mode characteristics";
        tailf:cli-boolean-no;
        type boolean;
      }
    }

    // interface * / switchport
    container switchport {
      tailf:info "Set switching mode characteristics";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // interface * / switchport access
      container access {
        tailf:info "Set access mode characteristics of the interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          //tailf:cli-diff-dependency "/cisco-ios-xr:vlan/vlan-list";
          type uint16 {
            tailf:info "<1-4094>;;VLAN ID of the VLAN when this port is in access mode";
            range "1..4094";
          }
        }
      }

      // interface * / switchport block
      container block {
        tailf:info "Disable forwarding of unknown uni/multi cast addresses";
        leaf multicast {
          tailf:info "Block unknown multicast addresses";
          tailf:cli-full-command;
          type empty;
        }
        leaf unicast {
          tailf:cli-full-command;
          tailf:info "Block unknown unicast addresses";
          type empty;
        }
      }

      // interface * / switchport mode
      container mode {
        tailf:info "Set trunking mode of the interface";
        choice mode-choice {
          leaf access {
            tailf:info "Set trunking mode to ACCESS unconditionally";
            type empty;
          }
          leaf dot1q-tunnel {
            tailf:info "set trunking mode to TUNNEL unconditionally";
            type empty;
          }
          leaf dynamic {
            tailf:info "Set trunking mode to dynamically negotiate "+
              "access or trunk mode";
            type enumeration {
              enum auto {
                tailf:info "Set trunking mode dynamic negotiation "+
                  "parameter to AUTO";
              }
              enum desirable {
                tailf:info "Set trunking mode dynamic negotiation "+
                  "parameter to DESIRABLE";
              }
            }
          }
          leaf trunk {
            tailf:info "Set trunking mode to TRUNK unconditionally";
            type empty;
          }
        }
      }

      // interface * / switchport nonegotiate
      leaf nonegotiate {
        tailf:info "Device will not engage in negotiation protocol on this interface";
        type empty;
      }

      // interface * / switchport trunk
      container trunk {
        tailf:info "Set trunking characteristics of the interface";
        container allowed {
          tailf:info "Set allowed VLAN characteristics when interface is "
            +"in trunking mode";
          container vlan {
            tailf:info "Set allowed VLANs when interface is in trunking "
              +"mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf all {
                tailf:info "all VLANs";
                type empty;
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
        container native {
          tailf:info "Set trunking native characteristics "
            +"when interface is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in trunking mode";
            type union {
              type enumeration {
                enum tag {
                  tailf:info "Set native VLAN tagging state";
                }
              }
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID of the native VLAN when "
                  +"this port is in trunking mode";
                range "1..4094";
              }
            }
          }
        }

        container pruning {
          tailf:info "Set pruning VLAN characteristics when interface is in"
            +" trunking mode";
          container vlan {
            tailf:info "Set VLANs enabled for pruning when interface is in "
              +"trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
      }
    }

    // interface * / spanning-tree
    container spanning-tree {
      tailf:info "Spanning Tree Subsystem";
      leaf bpdufilter {
        tailf:info "Don't send or receive BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU filtering for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU filtering for this interface";
          }
        }
      }
      leaf bpduguard {
        tailf:info "Don't accept BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU guard for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU guard for this interface";
          }
        }
      }
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        type enumeration {
          enum loop {
            tailf:info "Set guard mode to loop guard on interface";
          }
          enum none {
            tailf:info "Set guard mode to none";
          }
          enum root {
            tailf:info "Set guard mode to root guard on interface";
          }
        }
      }
      leaf portfast {
        tailf:info "Spanning tree portfast options";
        type enumeration {
          enum disable {
            tailf:info "Disable portfast for this interface";
          }
          enum edge {
            tailf:info "Enable portfast edge on the interface";
          }
          enum network {
            tailf:info "Enable portfast network on the interface";
          }
        }
      }
    }

  }


  // grouping interface-bundle-grouping
  grouping interface-bundle-grouping {

    // interface * / bundle
    container bundle {
      tailf:info "Bundle interface commands";

      // interface * / bundle wait-while
      leaf wait-while {
        tailf:info "Set the wait-while timeout for members of this bundle";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-2000>;;Wait-while timeout in milliseconds "+
            "(default: 2000)";
          range "0..2000";
        }
      }

      // interface * / bundle load-balancing
      container load-balancing {
        tailf:info "Load balancing commands on a bundle";

        // interface * / bundle load-balancing hash
        leaf hash {
          tailf:info "Select the hash function used for traffic forwarded over the bundle";
          type enumeration {
            enum dst-ip {
              tailf:info "Use the destination IP as the hash function";
            }
            enum src-ip {
              tailf:info "Use the source IP as the hash function";
            }
          }
        }

        // interface * / bundle load-balancing localize threshold links
        container localize {
          tailf:info "Restrict forwarding to members in the same rack where possible";
          container threshold {
            tailf:info "The threshold below which traffic is no longer localized";
            leaf links {
              tailf:info "Set a threshold of active member links per rack";
              type uint8 {
                tailf:info "<1-64>;;The number of links required on each rack to localize";
                range "1..64";
              }
            }
          }
        }
      }

      // interface * / bundle maximum-active
      container maximum-active {
        tailf:info "Set a limit on the number of links that can be active";
        container links {
          tailf:info "Set the number of active links needed to bring up "+
            "this bundle";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf number {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-64>;;Number of active links needed to bring "+
                "up this bundle";
              range "1..64";
            }
          }
          leaf hot-standby {
            tailf:info "Hot-standby behaviour (non-standard, only "+
              "effective on links with LACP enabled)";
            type empty;
          }
        }
      }

      // interface * / bundle minimum-active
      container minimum-active {
        tailf:info "Set the minimum criteria for the bundle to be active";
        leaf links {
          tailf:info "Set the number of active links needed to bring up "+
            "this bundle";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-64>;;Number of active links needed to bring up "+
              "this bundle";
          }
        }
      }
    }

    // interface * / lacp
    container lacp {
      tailf:info "Bundle interface LACP commands";
      container switchover {
        tailf:info "Modify behavior for switching between links in this "+
          "bundle";
        leaf suppress-flaps {
          tailf:info "Set the time for which to suppress flaps during a "+
            "LACP switchover";
          type uint16 {
            tailf:info "<100-65535>;;The longest down flap which "+
              "should be suppressed (milliseconds)";
            range "100..65535";
          }
        }
      }
    }

    // interface * / mlacp
    container mlacp {
      tailf:info "Multi-chassis LACP per-interface commands";

      // interface * / mlacp iccp-group
      leaf iccp-group {
        tailf:info "ICCP redundancy group related commands for this bundle.";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967295>;;The ICCP redundancy group in which "+
            "this bundle should operate.";
          range "1..4294967295";
        }
      }

      // interface * / mlacp port-priority
      leaf port-priority {
        tailf:info "Set the priority for all member links on this device "+
          "when running mLACP.";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Priority for member ports. Lower value "+
            "is higher priority.";
          range "1..65535";
        }
      }

      // interface * / mlacp switchover
      container switchover {
        tailf:info "Set the parameters for performing a switchover "+
          "to/from the mLACP peer";

        // interface * / mlacp switchover maximize
        container maximize {
          tailf:info "Parameters for switchover behavior to maximize "+
            "operational links/bandwidth";
          container links {
            tailf:info "Compare the number of operational links";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf threshold {
              tailf:info "Set the threshold below which to switch to the "+
                "peer if it has more links available";
              type uint8 {
                tailf:info "<1-64>;;The number of links below which to "+
                  "switch to the peer if it has more links available";
                range "1..64";
              }
            }
          }
        }

        // interface * / mlacp switchover recovery-delay
        leaf recovery-delay {
          tailf:info "Specify delay before bundle becoming active after "+
            "recovery from failure";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-65535>;;Recovery delay in seconds.";
          }
        }

        // interface * / mlacp switchover type
        leaf "type" {
          tailf:info "Set the type of switchover operation to use";
          tailf:cli-full-command;
          type enumeration {
            enum brute-force {
              tailf:info "Force switchover by disabling all local member "+
                "links";
            }
            enum revertive {
              tailf:info "Revert based on configured priority values";
            }
          }
        }
      }
    }
  }

  // grouping interface-non-bundle-grouping
  grouping interface-non-bundle-grouping {

    // interface * / bundle
    container bundle {
      tailf:info "Link aggregation per-interface commands";
      // interface * / bundle id
      container id {
        tailf:info "Add the port to an aggregated interface.";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf id-value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;Identifier of the bundle to add the port to.";
          }
        }
        leaf mode {
          tailf:info "Specify the mode of operation.";
          type enumeration {
            enum active {
              tailf:info "Run LACP in active mode over the port.";
            }
            enum on {
              tailf:info "Do not run LACP over the port.";
            }
            enum passive {
              tailf:info "Run LACP in passive mode over the port.";
            }
          }
        }
      }
      // interface * / bundle port-priority
      leaf port-priority {
        tailf:info "Priority for this port. Lower value is higher priority.";
        type uint16 {
          tailf:info "<1-65535>;;Priority for this port. "+
            "Lower value is higher priority.";
          range "1..65535";
        }
      }
    }

    // interface * / lacp
    container lacp {
      tailf:info "Link Aggregation Control Protocol per-interface commands";

      // interface * / lacp period
      container period {
        tailf:info "Configure the rate at which packets are sent or received";
        leaf period-value {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint16 {
            tailf:info "Specify the requested transmission period "+
              "(in milliseconds) for the partner system "+
              "(must be multiple of 100; default 1000)";
            range "100..1000";
          }
        }
        // interface * / lacp period short
        container short {
          tailf:info "Configure usage of the LACP short interval";
          tailf:cli-delete-when-empty;
          presence true;

          // interface * / lacp period short receive
          leaf receive {
            tailf:info "Expected period for rx packets if LACP short is enabled "+
              "(NOTE: This CLI is deprecated and will be removed in future releases. "+
              "Use the CLI 'lacp period <time in milliseconds>' to configure short periods)";
            type uint16 {
              tailf:info "<100-1000>;;Period in milliseconds(must be multiple of 100; default 1000)";
              range "100..1000" {
                tailf:step 100;
              }
            }
          }

          // interface * / lacp period short transmit
          leaf transmit {
            tailf:info "Period for tx packets if the peer is using LACP short "+
              "(NOTE: This CLI is deprecated and will be removed in future releases. "+
              "Use the CLI 'lacp period <time in milliseconds>' to configure short periods)";
            type uint16 {
              tailf:info "<100-1000>;;Period in milliseconds(must be multiple of 100; default 1000)";
              range "100..1000" {
                tailf:step 100;
              }
            }
          }
        }
      }
    }
  }

  // interface-pointtopoint-grouping
  grouping interface-pointtopoint-grouping {

    // interface * / keepalive
    container keepalive {
      tailf:info "Set the keepalive interval, or disable keepalives";
      choice keepalive-choice {
        container values {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf interval {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-30>;; Enable keepalives with this interval (default is 10 seconds)";
              range "1..30";
            }
          }
          leaf retry {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Set the keepalive retry count "+
                "(default is 3 for HDLC, 5 for PPP)";
              range "1..255";
            }
          }
        }
        leaf disable {
          tailf:info "Disable keepalives";
          type empty;
        }
      }
    }

    // interface * / pvc *
    list pvc {
      tailf:info "Configure a pvc on this interface";
      tailf:cli-mode-name "config-fr-vc";
      key dlci;
      leaf dlci {
        type uint16 {
          tailf:info "<16-1007>;;DLCI Number";
          range "16..1007";
        }
      }
      uses interface-service-policy-grouping;
      leaf encap {
        tailf:info "Set the Encapsulation of this PVC";
        type enumeration {
          enum cisco {
            tailf:info "Use Cisco encapsulation for this PVC";
          }
          enum ietf {
            tailf:info "Use RFC1490/RFC2427 encapsulation for this PVC";
          }
        }
      }
      container fragment {
        tailf:info "Enable FRF.12 fragmentation and define fragment size";
        tailf:cli-compact-syntax;
        leaf end-to-end {
          tailf:info "Choose end-to-end FRF.12 fragmentation";
          type uint16 {
            tailf:info "<16-1600>;;fragment size in bytes";
            range "16..1600";
          }
        }
        leaf fragment-counter {
          tailf:info "Enable fragmentation counters";
          type empty;
        }
      }
    }

    // interface * / ppp
    container ppp {
      tailf:info "Point-to-Point Protocol";

      // interface * / ppp multilink
      container multilink {
        tailf:info "Configure PPP Multilink settings";

        // interface * / ppp multilink minimum-active links
        container minimum-active {
          tailf:info "Configure the minimum requirements to activate the interface";
          leaf links {
            tailf:info "Configure the minimum number of active links required";
            type uint16 {
              tailf:info "<1-65535>;;Number of links";
              range "1..65535";
            }
          }
        }
      }
    }
  }

  // interface-multilink-grouping
  grouping interface-multilink-grouping {

    // interface * / multilink
    container multilink {
      tailf:info "Modify Multilink parameters!";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-multilink";

      // interface * / multilink / fragment-size
      container fragment-size {
        tailf:info "Fragment size (some fragment sizes may not be supported)";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-multilink-frag";
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        leaf size {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<64-512>;;Size of fragments";
            range "64..512";
          }
        }
        // interface * / multilink / fragment-size / fragment-counter
        leaf fragment-counter {
          tailf:info "Enable/Disable the fragmentation counters";
          type empty;
        }
      }

      // interface * / multilink / fragment
      container fragment {
        tailf:info "Set the fragmentation";

        // interface * / multilink / fragment size
        leaf size {
          tailf:info "Set the fragmentation size";
          type uint16 {
            tailf:info "<64-9216>;;Fragmentation size in bytes";
            range "64..9216";
          }
        }
      }
    }
  }

  // grouping interface-ethernet-grouping
  grouping interface-ethernet-grouping {

    // interface * / carrier-delay
    container carrier-delay {
      tailf:info "Set the carrier delay on an interface";
      tailf:cli-compact-syntax;
      leaf up {
        tailf:info "Set the carrier delay up value";
        type uint32 {
          tailf:info "<0-2147483647>;;Delay in milliseconds";
          range "0..2147483647";
        }
      }
      leaf down {
        tailf:info "Set the carrier delay down value";
        type uint32 {
          tailf:info "<0-2147483647>;;Delay in milliseconds";
          range "0..2147483647";
        }
      }
    }

    // interface * / duplex
    leaf duplex {
      tailf:info "Configure duplex operational mode";
      tailf:cli-full-command;
      type enumeration {
        enum full {
          tailf:info "Full duplex";
          tailf:code-name "duplex_full";
        }
        enum half {
          tailf:info "Half duplex";
          tailf:code-name "duplex_half";
        }
      }
    }

    //  interface * / ethernet
    container ethernet {
      tailf:info "Ethernet per-interface configuration commands";

      //  interface * / ethernet udld
      container udld {
        tailf:info "Enable the UniDirectional Link Detection protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-udld";

        //  interface * / ethernet udld / mode
        leaf mode {
          tailf:info "Set the mode in which to run the UDLD protocol";
          tailf:cli-full-command;
          type enumeration {
            enum aggressive {
              tailf:info "Run UDLD in aggressive mode";
            }
            enum normal {
              tailf:info "Run UDLD in normal mode";
            }
          }
        }
      }

      //  interface * / ethernet cfm
      container cfm {
        tailf:info "802.1ag Connectivity Fault Management configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-cfm";

        //  interface * / ethernet cfm / mep
        container mep {
          tailf:info "CFM Maintenance End Point configuration";

          //  interface * / ethernet cfm / mep domain *
          list domain {
            tailf:info "Specify the Maintenance Domain the MEP operates in";
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Maintenance Domain name";
              }
            }
            leaf service {
              tailf:info "Specify the Maintenance Service the MEP operates in";
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Maintenance Service name";
              }
            }
            leaf mep-id {
              tailf:info "Specify the MEP ID to assign to the MEP";
              tailf:cli-hide-in-submode;
              type uint16 {
                tailf:info "<1-8191>;;MEP ID";
                range "1..8191";
              }
            }

            //  interface * / ethernet cfm / mep domain * / cos
            leaf cos {
              tailf:info "Specify CoS bits for messages initiated by this MEP";
              type uint8 {
                tailf:info "<0-7>;;Class of Service";
                range "0..7";
              }
            }

            //  interface * / ethernet cfm / mep domain * / sla
            container sla {
              tailf:info "Service Level Agreement configuration";
              container operation {
                tailf:info "SLA operation configuration";
                list profile {
                  tailf:info "Specify the SLA profile for this operation";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  key "name mep-id";
                  leaf name {
                    type string {
                      tailf:info "WORD;;Profile name";
                    }
                  }
                  leaf target {
                    tailf:info "Specify the target for the SLA operation";
                    tailf:cli-prefix-key {
                      tailf:cli-before-key 2;
                    }
                    type empty;
                  }
                  leaf mep-id {
                    tailf:cli-expose-key-name;
                    tailf:info "Specify a target MEP";
                    type uint16 {
                      tailf:info "<1-8191>;;Target MEP ID";
                    }
                  }
                }
              }
            }
          }
        }

        //  interface * / ethernet cfm / ais
        container ais {
          tailf:info "CFM Alarm Indication Signal configuration";
          container transmission {
            tailf:info "CFM AIS transmission configuration";
            container up {
              tailf:info "Up configuration";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              presence true;
              leaf cos {
                tailf:info "Specify CoS bits for AIS messages";
                type uint8 {
                  tailf:info "<0-7>;;Class of Service";
                  range "0..7";
                }
              }
              leaf interval {
                tailf:info "Specify the AIS transmission interval";
                type enumeration {
                  enum "1s" {
                    tailf:info "Interval of 1 second";
                  }
                  enum "1m" {
                    tailf:info "Interval of 1 minute";
                  }
                }
              }
            }
          }
        }
      }

      //  interface * / ethernet egress-filter
      leaf egress-filter {
        tailf:info "Override default egress-filter configuration on this interface";
        type enumeration {
          enum disable {
            tailf:info "No egress filtering, regardless of the global "+
            "configuration";
          }
          enum strict {
            tailf:info "Strict egress filtering, regardless of the global "+
            "configuration";
          }
        }
      }

    }

    //  interface * / ethernet-services
    container ethernet-services {
      tailf:info "Ethernet related services";
      //  interface * / ethernet-services access-group
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-remove-before-change;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Access-list name";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ethernet-services/access-list/name";
          }
        }
      }
    }

    //  interface * / mac-address
    leaf mac-address {
      tailf:info "Set the Mac address(xxxx.xxxx.xxxx) on an interface";
      type string {
        pattern '[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+';
      }
    }

    // interface * / speed
    leaf speed {
      tailf:info "Set the ethernet speed on an interface";
      tailf:cli-full-command;
      type enumeration {
        enum "10" {
          tailf:info "Ethernet is 10Mb";
        }
        enum "100" {
          tailf:info "Ethernet is 100Mb";
        }
        enum "1000" {
          tailf:info "Ethernet is 1Gb";
        }
      }
    }

    //  interface * / transceiver
    container transceiver {
      tailf:info "transceiver commands";
      container permit {
        tailf:info "permit";
        container pid {
          tailf:info "Permit pluggable pid (Product ID) all";
          leaf all {
            tailf:info "all";
            type empty;
          }
        }
      }
    }

    //  interface * / nv
    container nv {
      tailf:info "Network Virtualisation interface configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-nV";

      //  interface * / nv / edge
      container edge {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-nV-Edge";
        //  interface * / nv / edge / interface
        leaf interface {
          tailf:info "nV Edge inter-rack interconnect interface";
          type empty;
        }
      }

      //  interface * / nv / satellite-fabric-link #
      container satellite-fabric-link {
        tailf:info "Satellite Fabric Link configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-satellite-fabric-link";
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf satellite {
          tailf:info "Satellite ID";
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<100-65534>;;Satellite ID";
            range "100..65534";
          }
        }

        //  interface * / nv / satellite-fabric-link # / redundancy
        container redundancy {
          tailf:cli-break-sequence-commands;
          tailf:info "Redundancy configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-nV-red";
          //  interface * / nv / satellite-fabric-link # / redundancy / iccp-group
          leaf iccp-group {
            tailf:info "Redundancy group ID";
            type uint32 {
              tailf:info "<1-4294967295>;;Redundancy group ID";
            }
          }
        }

        //  interface * / nv / satellite-fabric-link # / remote-ports
        container remote-ports {
          tailf:info "Remote ports configuration";
          leaf GigabitEthernet {
            tailf:info "Remote ports type";
            type string {
              tailf:info "Slot/Subslot/Port(s)";
            }
          }
        }
      }
    }
  }

  // grouping interface-common-grouping
  grouping interface-common-grouping {

    // interface * / apply-group *
    uses apply-group-grouping;

    // interface * / description
    leaf "description" {
      tailf:info "Set description for this interface";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description for this interface";
      }
    }

    // interface * / bandwidth
    leaf bandwidth {
      tailf:info "Set the bandwidth of an interface";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;bandwidth in kbps";
      }
    }

    // interface * / loopback
    leaf loopback {
      tailf:info "Set the loopback mode on an interface";
      tailf:cli-full-command;
      type enumeration {
        enum "external" {
          tailf:info "Enable external loopback (requires loopback connector)";
        }
        enum "internal" {
          tailf:info "Enable internal loopback";
        }
        enum "line" {
          tailf:info "Enable line loopback";
        }
      }
    }

    // interface * / mtu
    leaf mtu {
      tailf:info "Set the MTU on an interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<64-65535>;;MTU size in bytes";
        range "64..65535";
      }
    }

    // interface * / negotiation auto
    container negotiation {
      tailf:info "Select autonegotiation mode";
      container auto {
        tailf:info "Perform link autonegotiation";
        tailf:cli-delete-when-empty;
        presence true;
        leaf allow-overrides {
          tailf:info "Allow configured values to override negotiated settings";
          type empty;
        }
      }
    }

    // interface * / monitor-session *
    list monitor-session {
      tailf:info "Monitor-session configuration commands";
      tailf:cli-mode-name "config-if-mon";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Session Name";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:monitor-session/name";
        }
      }

      // interface * / monitor-session * ethernet
      leaf ethernet {
        tailf:info "Replicate Ethernet traffic";
        tailf:cli-hide-in-submode;
        type empty;
      }

      // interface * / monitor-session * direction
      leaf direction {
        tailf:info "Specify the direction of traffic to replicate";
        tailf:cli-hide-in-submode;
        type enumeration {
          enum rx-only {
            tailf:info "Replicate only received (ingress) traffic";
          }
          enum tx-only {
            tailf:info "Replicate only transmitted (egress) traffic";
          }
        }
      }

      // interface * / monitor-session * / acl
      leaf acl {
        tailf:info "Enable acl based mirroring";
        type empty;
      }
    }

    // interface * / encapsulation
    container encapsulation {
      tailf:info "Set the encapsulation on an (sub)interface";
      choice encapsulation-choice {

        // interface * / encapsulation frame-relay
        container frame-relay {
          tailf:info "Frame Relay networks";
          tailf:cli-delete-when-empty;
          presence true;
          leaf IETF {
            tailf:info "Use RFC1490/RFC2427 encapsulation";
            type empty;
          }
        }

        // interface * / encapsulation hdlc
        leaf hdlc {
          tailf:info "Serial HDLC synchronous";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / encapsulation mfr
        leaf mfr {
          tailf:info "Multilink Frame Relay Member Link";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / encapsulation ppp
        leaf ppp {
          tailf:info "Point-to-Point protocol";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / encapsulation default
        leaf "default" {
          tailf:info "Packets unmatched by other service instances";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / encapsulation untagged
        container untagged {
          tailf:info "Packets with no explicit VLAN tag";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
          // +ingress
        }

        // interface * / encapsulation ambiguous
        container ambiguous {
          tailf:info "Ambiguous L3 VLAN configuration";

          // interface * / encapsulation ambiguous dot1q
          container dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf-list vlan-id {
              tailf:cli-drop-node-name;
              tailf:cli-range-list-syntax;
              tailf:cli-replace-all;
              type union {
                type uint16 {
                  tailf:info "<1-4094>;;Single VLAN id";
                  range "1..4094";
                }
                type enumeration {
                  enum any {
                    tailf:info "Match any VLAN id";
                  }
                }
              }
            }
            leaf-list second-dot1q {
              tailf:info "IEEE 802.1Q VLAN-tagged packets";
              tailf:cli-optional-in-sequence;
              tailf:cli-range-list-syntax;
              tailf:cli-replace-all;
              type union {
                type uint16 {
                  tailf:info "<1-4094>;;Single VLAN id";
                  range "1..4094";
                }
                type enumeration {
                  enum any {
                    tailf:info "Match any VLAN id";
                  }
                }
              }
            }
          }
        }

        // interface * / encapsulation dot1q
        container dot1q {
          tailf:info "IEEE 802.1Q VLAN-tagged packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf-list vlan-id {
            tailf:cli-drop-node-name;
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
                enum priority-tagged {
                  tailf:info "IEEE 802.1ad priority-tagged packets";
                }
              }
            }
          }
          leaf-list second-dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            tailf:cli-optional-in-sequence;
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
              }
            }
          }
          leaf exact {
            tailf:info "Do not allow further inner tags";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          container ingress {
            tailf:info "Perform MAC-based matching";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf source-mac {
              tailf:info "Perform source MAC-based matching";
              type string {
                tailf:info "H.H.H;;MAC Address";
              }
            }
          }
        }

        // interface * / encapsulation dot1ad
        container dot1ad {
          tailf:info "IEEE 802.1ad VLAN-tagged packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf-list vlan-id {
            tailf:cli-drop-node-name;
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
                enum priority-tagged {
                  tailf:info "IEEE 802.1ad priority-tagged packets";
                }
              }
            }
          }

          // interface * / encapsulation dot1ad * dot1q
          leaf-list dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            tailf:cli-optional-in-sequence;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
              }
            }
          }

          // interface * / encapsulation dot1ad * exact
          leaf exact {
            tailf:info "Do not allow further inner tags";
            type empty;
          }
        }
      }
    }

    // interface * / pppoe enable
    container pppoe {
      tailf:info "PPP over Ethernet";
      container enable {
        tailf:info "Enable PPPoE on the interface";
        tailf:cli-delete-when-empty;
        presence true;

        // interface * / pppoe enable group
        leaf bba-group {
          tailf:info "Specify the bba-group to use with the interface";
          type string {
            tailf:info "WORD;;The bba-group to use";
          }
        }
      }
    }

    // interface * / frame-relay
    container frame-relay {
      tailf:info "Frame Relay interface configuration commands";

      // interface * / frame-relay lmi disable
      container lmi {
        tailf:info "Disable LMI";
        leaf disable {
          tailf:info "Disable LMI";
          type empty;
        }
      }

      // interface * / frame-relay lmi-type
      container lmi-type {
        tailf:info "Use CISCO-ANSI-CCITT type LMI to select type";
        tailf:cli-delete-when-empty;
        presence true;
        leaf "type" {
          tailf:cli-drop-node-name;
          type enumeration {
            enum ansi {
              tailf:info "Use ANSI type LMI";
            }
            enum cisco {
              tailf:info "Use CISCO type LMI";
            }
            enum q933a {
              tailf:info "Use CCITT type LMI";
            }
          }
        }
      }

      // interface * / frame-relay intf-type
      container intf-type {
        tailf:info "Use DTE/DCE mode for LMI";
        tailf:cli-delete-when-empty;
        presence true;
        leaf "type" {
          tailf:cli-drop-node-name;
          type enumeration {
            enum dce {}
          }
        }
      }

      // interface * / frame-relay multilink
      container multilink {
        tailf:info "Multilink Frame Relay interface configuration commands";
        leaf bandwidth-class {
          tailf:info "Multilink Frame Relay bandwidth class";
          type enumeration {
            enum "a" {
              tailf:info "Bandwidth class A";
            }
            enum "b" {
              tailf:info "Bandwidth class B";
            }
            enum "c" {
              tailf:info "Bandwidth class C";
            }
          }
        }
      }
    }

    // interface * / frequency synchronization
    container frequency {
      tailf:info "Frequency Synchronization configuration";

      // interface * / frequency synchronization
      container synchronization {
        tailf:info "Frequency Synchronization configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-freqsync";

        // interface * / frequency synchronization / selection
        container selection {
          tailf:info "Selection configuration commands";
          leaf "input" {
            tailf:info "Enable this source for selection";
            type empty;
          }
        }

        // interface * / frequency synchronization / priority
        leaf priority {
          tailf:info "Source priority";
          type uint8 {
            tailf:info "<1-254>;;Source priority";
            range "1..254";
          }
        }

        // interface * / frequency synchronization / wait-to-restore
        leaf wait-to-restore {
          tailf:info "Set the wait-to-restore time";
          type uint8 {
            tailf:info "<0-12>;;Wait-to-restore time, in minutes";
            range "0..12";
          }
        }

        // interface * / frequency synchronization / quality
        container quality {
          tailf:info "Quality level configuration";
          container receive {
            tailf:info "Adjust the received quality level";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses freqsync-quality-grouping;
          }
          container transmit {
            tailf:info "Set the quality level to be transmitted";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses freqsync-quality-grouping;
          }
        }
      }
    }

    // interface * / service-policy
    uses interface-service-policy-grouping;

    // interface * / vrf
    leaf vrf {
      tailf:info "Set VRF in which the interface operates";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "/cisco-ios-xr:vrf";
      type vrf-type;
    }

    // interface * / aaa radius attribute
    container aaa {
      tailf:info "AAA configuration";
      container radius {
        tailf:info "AAA radius configuration";
        container attribute {
          tailf:info "AAA radius attribute";
          leaf nas-port-type {
            tailf:info "AAA nas-port-type attribute";
            type union {
              type uint8 {
                tailf:info "<0-44>;;Nas Port Type value";
              }
              type string {
                tailf:info "WORD;;Nas Port Type name";
              }
            }
          }
        }
      }
    }

    // interface * / ipv4
    container ipv4 {
      tailf:info "IPv4 interface subcommands";

      // interface * / ipv4 point-to-point
      leaf point-to-point {
        tailf:info "Enable point-to-point handling for this interface.";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / ipv4 address
      choice address-choice {
        case no {
          // interface * / no ipv4 address
          container no-address {
            tailf:cli-drop-node-name;
            leaf address {
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }
        case yes {
          // interface * / ipv4 address [mask]
          container address {
            tailf:info "Set the IPv4 address of an interface";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf ip {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf mask {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "A.B.C.D or /X;;IP subnet mask or /prefix";
              }
            }
            leaf route-tag {
              tailf:info "Route-tag to be associated with this address";
              type uint32 {
                tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
                range "1..4294967295";
              }
            }
          }
          // interface * / ipv4 address [mask] secondary
          container address-secondary-list {
            tailf:cli-drop-node-name;
            list address {
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key "ip secondary";
              leaf ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                }
              }
              leaf secondary {
                type enumeration {
                  enum secondary {
                    tailf:info "Make this IPv4 address a secondary address";
                  }
                }
              }
              leaf mask {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key {
                  tailf:cli-before-key 2;
                }
                type string {
                  tailf:info "A.B.C.D or /X;;IP subnet mask or /masklength";
                }
              }
              leaf route-tag {
                tailf:info "Route-tag to be associated with this address";
                type uint32 {
                  tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
                  range "1..4294967295";
                }
              }
            }
          }
        }
      }

      // interface * / ipv4 access-group * ingress
      // interface * / ipv4 access-group * egress
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
          }
          type string {
            tailf:info "WORD;;access-list name";
          }
        }
        leaf hardware-count {
          tailf:cli-break-sequence-commands;
          tailf:info "Count packets in hardware";
          type empty;
        }
        leaf interface-statistics {
          tailf:info "Per interface statistics in hardware";
          type empty;
        }
      }

      // interface * / ipv4 helper-address
      container helper-address {
        tailf:info "Specify a destination address for UDP broadcasts";
        choice helper-address-choice {
          leaf local {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
          leaf global {
            tailf:info "Helper-address is global";
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
          container vrf {
            tailf:info "VRF name for helper-address (if different from interface VRF)";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;VPN Routing/Forwarding instance name";
              }
            }
            leaf address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP destination address";
              }
            }
          }
        }
      }

      // interface * / ipv4 redirects
      leaf redirects {
        tailf:info "Enable sending ICMP Redirect messages";
        type empty;
      }

      // interface * / ipv4 directed-broadcast
      leaf directed-broadcast {
        tailf:info "Enable forwarding of directed broadcasts";
        type empty;
      }

      // interface * / ipv4 mtu
      leaf mtu {
        tailf:info "Set IPv4 Maximum Transmission Unit";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<68-65535>;;MTU (bytes)";
          range "68..65535";
        }
      }

      // interface * / ipv4 bgp policy
      container bgp {
        tailf:info "Enable BGP policy based feature";
        container policy {
          tailf:info "BGP policy";

          // interface * / ipv4 bgp policy propagation input
          container propagation {
            tailf:info "BGP QoS policy propagation";
            container "input" {
              tailf:info "QPPB on input";


              // interface * / ipv4 bgp policy propagation input qos-group
              container qos-group {
                tailf:info "QPPB using Qos Group";

                // interface * / ipv4 bgp policy propagation input qos-group destination
                container destination {
                  tailf:info "QPPB on destination IP address ";
                  presence true;
                }
              }
            }
          }
        }
      }

      // interface * / ipv4 pim
      container pim {
        tailf:info "PIM interface commands";
        leaf bidir-neighbor-filter {
          tailf:info "PIM bidir capable peering filter";
          type union {
            type uint8 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP Named Standard Access list";
            }
          }
        }
        leaf bsr-border {
          tailf:info "Border of PIM domain";
          type empty;
        }
        leaf dr-priority {
          tailf:info "PIM router DR priority";
          type uint32 {
            tailf:info "<0-4294967294>;;DR priority, preference"
              +" given to larger value";
            range "0..4294967294";
          }
        }
        leaf nbma-mode {
          tailf:info "Use Non-Broadcast Multi-Access (NBMA) mode"
            +" on interface";
          type empty;
        }
        leaf neighbor-filter {
          tailf:info "PIM peering filter";
          type union {
            type uint8 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP Named Standard Access list";
            }
          }
        }
        container query-interval {
          tailf:info "PIM router query interval";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice interval-choice {
            case secs {
              leaf secs {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Query interval in seconds or"
                    +" milliseconds";
                  range "1..65535";
                }
              }
            }
            case msec {
              leaf msecs {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-65535>;;Query interval in seconds or"
                    +" milliseconds";
                  range "100..65535";
                }
                must "../msec";
              }
              leaf msec {
                type empty;
              }
            }
          }
        }
        choice pim-mode {
          leaf sparse-dense-mode {
            tailf:info "Enable PIM sparse-dense-mode operation";
            type empty;
          }
          container dense-mode {
            tailf:cli-reset-container;
            tailf:info "Enable PIM dense-mode operation";
            presence true;
            container proxy-register {
              tailf:cli-reset-container;
              tailf:info "Send proxy registers";
              choice proxy-mode {
                leaf "list" {
                  tailf:info "Access list";
                  type union {
                    type uint16 {
                      tailf:info "<100-199>;;Extended access list number";
                      range "100..199";
                    }
                    type uint16 {
                      tailf:info "<2000-2699>;;Extended access list "
                        +"number (expanded range)";
                      range "2000..2699";
                    }
                    type string {
                      tailf:info "WORD;;IP named extended access list";
                    }

                  }
                }
                leaf route-map {
                  tailf:info "Route-map";
                  type string {
                    tailf:info "WORD;;Route-map reference";
                  }
                }
              }
            }
          }
          leaf sparse-mode {
            tailf:info "Enable PIM sparse-mode operation";
            type empty;
          }
        }
        container state-refresh {
          tailf:info "PIM DM State-Refresh configuration";
          container origination-interval {
            tailf:info "PIM State-Refresh origination interval";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf secs {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Interval in seconds";
                range "1..100";
              }
            }
          }
        }
      }

      // interface * / ipv4 verify unicast
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";

          // interface * / ipv4 verify unicast notification
          container "notification" {
            tailf:info "drop-rate notify";
            leaf threshold {
              tailf:info "Urpf NOTIFY drop rate threshold";
              type uint32 {
                tailf:info "<0-4294967295>;;Drop rate in pps triggering"
                  +" notify - 0 is any drops";
                range "0..4294967295";
              }
            }
          }

          // interface * / ipv4 verify unicast source
          container source {
            tailf:info "Validation of source address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the "
                +"source address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on which"
                    +" packet was received";
                }
              }
            }
            leaf allow-self-ping {
              tailf:cli-break-sequence-commands;
              tailf:info "Allow router to ping itself (opens vulnerability "+
                "in verification)";
              type empty;
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking "+
                "source address";
              type empty;
            }
          }
        }
      }

      // interface * / ipv4 router
      container router {
        tailf:info "IP router interface commands";
        container isis {
          tailf:info "IS-IS Routing for IP";
          presence true;
          tailf:cli-reset-container;
          leaf routing-process {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }

      // interface * / ipv4 unnumbered
      container unnumbered {
        tailf:info "Enable IPv4 processing without an explicit address";
        uses interface-name-grouping;
      }

      // interface * / ipv4 unreachables disable
      container unreachables {
        tailf:info "Enable sending ICMP Unreachable messages";
        leaf disable {
          tailf:info "Override sending of ICMP Unreachable messages";
          type empty;
        }
      }
    }

    // interface * / arp
    container arp {
      tailf:info "Configure Address Resolution Protocol";

      // interface * / arp timeout
      leaf timeout {
        tailf:info "Set ARP cache timeout";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<30-2144448000>;;Seconds";
          range "30..2144448000";
        }
      }

      // interface * / arp learning
      leaf learning {
        tailf:info "Configuration for dynamic learning of ARP entries";
        tailf:cli-full-command;
        type enumeration {
          enum disable {
            tailf:info "Disable dynamic learning of ARP entries";
          }
          enum local {
            tailf:info "Enable dynamic learning only for local subnet only";
          }
        }
      }
    }

    // interface * / proxy-arp
    leaf proxy-arp {
      tailf:info "Enable proxy ARP";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / ipv6
    container ipv6 {
      tailf:info "IPv6 interface subcommands";

      // interface * / ipv6 mtu
      leaf mtu {
        tailf:info "Set IPv6 Maximum Transmission Unit";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1280-65535>;;MTU (bytes)";
          range "1280..65535";
        }
      }

      // interface * / ipv6 nd
      container nd {
        tailf:info "IPv6 interface Neighbor Discovery subcommands";

        // interface * / ipv6 nd cache-limit
        leaf cache-limit {
          tailf:info "Set Cache Limit for neighbor entry";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-10000>;;Cache Limit";
            range "1..10000";
          }
        }

        // interface * / ipv6 nd dad attempts
        container dad {
          tailf:info "Duplicate Address Detection";
          leaf attempts {
            tailf:info "Set IPv6 Duplicate Address Detection Transmits";
            type uint16 {
              tailf:info "<0-600>;;Number of attempts";
              range "0..600";
            }
          }
        }

        // interface * / ipv6 nd managed-config-flag
        leaf managed-config-flag {
          tailf:info "Hosts should use stateful protocol for address config";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ipv6 nd ns-interval
        leaf ns-interval {
          tailf:info "Set advertised NS retransmission interval";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<1000-4294967295>;;Retransmission interval in"
              +" milliseconds";
            range "1000..4294967295";
          }
        }

        // interface * / ipv6 nd other-config-flag
        leaf other-config-flag {
          tailf:info "Hosts should use stateful protocol for non-address config";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ipv6 nd prefix
        container "prefix" {
          tailf:info "Configure IPv6 Routing Prefix Advertisement";
          list prefix-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key "prefix";
            leaf prefix {
              type union {
                type tailf:ipv6-address-and-prefix-length {
                  tailf:info "X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
                }
                type string; // for %zone support
              }
            }
            uses interface-ipv6-nd-prefix-list-grouping;
          }
          container "default" {
            tailf:info "Specify prefix default parameters";
            uses interface-ipv6-nd-prefix-list-grouping;
          }
        }

        // interface * / ipv6 nd ra
        container ra {
          tailf:info "IPv6 interface ND RA subcommands";

          // interface * / ipv6 nd ra hoplimit
          leaf hoplimit {
            tailf:info "IPv6 ND RA hoplimit";
            tailf:cli-full-command;
            type enumeration {
              enum "unspecified" {
                tailf:info "Unspecified IPv6 ND RA hop-limit value";
              }
            }
          }

          // interface * / ipv6 nd ra mtu
          leaf mtu {
            tailf:info "IPv6 ND RA mtu option configuration";
            tailf:cli-full-command;
            type enumeration {
              enum "unspecified" {
                tailf:info "Unspecified IPv6 ND RA hop-limit value";
              }
            }
          }
        }

        // interface * / ipv6 nd ra-interval
        container ra-interval {
          tailf:info "Set IPv6 Router Advertisement Interval";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf maximum {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<4-1800>;;Maximum RA Interval (sec)";
              range "4..1800";
            }
          }
          leaf minimum {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<3-1800>;;Minimum RA Interval (sec)";
              range "3..1800";
            }
          }
        }

        // interface * / ipv6 nd ra-lifetime
        leaf ra-lifetime {
          tailf:info "Set IPv6 Router Advertisement Lifetime";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-9000>;;RA Lifetime (seconds)";
            range "0..9000";
          }
        }

        // interface * / ipv6 nd reachable-time
        leaf reachable-time {
          tailf:info "Set advertised reachability time";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-3600000>;;Reachability time in milliseconds";
            range "0..3600000";
          }
        }

        // interface * / ipv6 nd redirects
        leaf redirects {
          tailf:info "Enable sending of ICMP Redirect messages";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ipv6 nd suppress-ra
        leaf suppress-ra {
          tailf:info "Suppress IPv6 Router Advertisements";
          tailf:cli-full-command;
          type empty;
        }
      }

      // interface * / ipv6 verify unicast source
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";
          container source {
            tailf:info "Validation of source address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the"
                +" source address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on "+
                    "which packet was received";
                }
              }
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking "+
                "source address";
              tailf:cli-break-sequence-commands;
              type empty;
            }
            leaf allow-self-ping {
              tailf:info "Allow router to ping itself "+
                "(opens vulnerability in verification)";
              type empty;
            }
          }
        }
      }

      // interface * / ipv6 address
      container address {
        tailf:info "Configure IPv6 address on interface";
        list prefix-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          key "prefix";
          leaf "prefix" {
            type union {
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;IPv6 prefix";
              }
              type string {
                tailf:info "X:X::X%zone;;IPv6 name or address";
              }
            }
          }
          leaf eui-64 {
            tailf:info "Use eui-64 interface identifier";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf link-local {
            tailf:info "Use link-local address";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf route-tag {
            tailf:info "Route-tag to be associated with this address";
            type uint32 {
              tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
              range "1..4294967295";
            }
          }
        }
      }

      // interface * / ipv6 enable
      leaf enable {
        tailf:info "Enable IPv6 on interface";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / ipv6 access-group
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;access-list name";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ipv6/access-list/named-acl/name";
          }
        }
        leaf interface-statistics {
          type empty;
        }
      }

      // interface * / ipv6 unreachables disable
      container unreachables {
        tailf:info "Enable sending ICMP Unreachable messages";
        leaf disable {
          tailf:info "Override sending of ICMP Unreachable messages";
          type empty;
        }
      }
    }

    // interface * / lldp
    container lldp {
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-lldp";
      // interface * / lldp / receive disable
      container receive {
        tailf:info "Disable LLDP RX on an interface";
        leaf disable {
          tailf:info "Disable LLDP RX on an interface";
          type empty;
        }
      }
      // interface * / lldp / transmit disable
      container transmit {
        tailf:info "Disable LLDP TX on an interface";
        leaf disable {
          tailf:info "Disable LLDP TX on an interface";
          type empty;
        }
      }
    }

    // interface * / mpls
    container mpls {
      tailf:info "MPLS interface subcommands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-mpls";
      leaf ip {
        tailf:info "Configure dynamic MPLS forwarding for IP";
        type empty;
      }
      container label-security {
        tailf:info "MPLS label-security for the interface";
        leaf rpf {
          tailf:info "MPLS RPF for incoming packets";
          tailf:cli-full-command;
          type empty;
        }
        leaf multi-label-packet {
          tailf:info "Handling incoming packets with multiple labels on the "
            +"stack";
          tailf:cli-full-command;
          type enumeration {
            enum drop {
              tailf:info "Drop packets with multiple labels on the stack";
            }
          }
        }
      }
      leaf mtu {
        tailf:info "Set the MPLS MTU for the interface";
        type uint16 {
          tailf:info "<68-65535>;;MTU size in bytes";
          range "68..65535";
        }
      }
    }

    // interface * / backup-bw
    container backup-bw {
      tailf:info "Fast-reroute backup bandwidth requirement";

      // interface * / backup-bw unlimited
      container unlimited {
        tailf:info "Unlimited backup bandwidth";
        choice unlimited-choice {
          leaf any-class-type {
            tailf:info "Specify any bandwidth class type";
            type empty;
          }
          leaf class-type {
            tailf:info "Specify the bandwidth class type";
            type uint8 {
              tailf:info "<0-1>;;Class type number";
              range "0..1";
            }
          }
        }
      }
    }

    // interface * / shutdown
    leaf shutdown {
      tailf:info "shutdown the given interface";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / isis
    uses interface-isis-grouping;

    // interface * / load-interval
    leaf load-interval {
      tailf:info "Specify interval for load calculation for an interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-600>;;Number of seconds";
        range "0..600" {
          tailf:step 30;
        }
      }
    }

    // interface * / capture software packets
    container capture {
      tailf:info "capture interface packets (platform)(cisco-support)";
      container software {
        tailf:info "capture software switched packets(cisco-support)";
        leaf packets {
          tailf:info "turns on both ingress and egress (platform)(cisco-support)";
          type empty;
        }
      }
    }

    // interface * / transport-mode
    container transport-mode {
      tailf:info "Set the transport mode on an interface";
      choice transport-mode-choice {
        leaf wan {
          tailf:info "10GBASE-W WAN SONET/SDH (9.95328Gb/s)";
          type empty;
        }
        container otn {
          tailf:info "10GE over Optical Transport Network (G.709)";
          leaf bit-transparent {
            tailf:info "10GBASE-R transparently mapped into OTU-2";
            type enumeration {
              enum opu1e {
                tailf:info "10GBASE-R over OPU1e without fixed stuffing "+
                  "(11.0491Gb/s)";
              }
              enum opu2e {
                tailf:info "10GBASE-R over OPU2e with fixed stuffing "+
                  "(11.0957Gb/s)";
              }
            }
          }
        }
        leaf rx-only {
          tailf:info "10GE UDLR Mode, Receive Only";
          type empty;
        }
        leaf tx-only {
          tailf:info "10GE UDLR Mode, Transmit Only";
          type empty;
        }
      }
    }

    // interface * / flow-control
    leaf flow-control {
      tailf:info "configure flow-control on the given interface";
      tailf:cli-full-command;
      type enumeration {
        enum bidirectional {
          tailf:info "Enable bidirectional flow-control on an interface";
        }
        enum egress {
          tailf:info "Enable egress flow-control on an interface";
        }
        enum ingress {
          tailf:info "Enable ingress flow-control on an interface";
        }
      }
    }

    // interface * / flow
    // flow [ ipv4 | ipv6 | mpls ] monitor name sampler name { egress | ingress }
    list flow {
      tailf:info "Netflow configuration";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      key "proto monitor direction";
      leaf proto {
        type enumeration {
          enum ipv4 {
            tailf:info "IPV4 netflow configuration";
          }
          enum ipv6 {
            tailf:info "IPV6 netflow configuration";
          }
          enum mpls {
            tailf:info "MPLS netflow configuration";
          }
        }
      }
      leaf monitor {
        tailf:info "Specify a flow monitor for packets";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Flow monitor map name";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:flow/monitor-map/name";
        }
      }
      leaf sampler {
        tailf:info "Specify a sampler for packets";
        tailf:cli-prefix-key {
          tailf:cli-before-key 3;
        }
        type string {
          tailf:info "WORD;;Sampler map name";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:sampler-map/name";
        }
      }
      leaf direction {
        type enumeration {
          enum egress {
            tailf:info "Apply flow monitor on outgoing packets";
          }
          enum ingress {
            tailf:info "Apply flow monitor on incoming packets";
          }
        }
      }
    }

    // interface * / dampening
    container dampening {
      tailf:info "configure state dampening on the given interface";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      presence true;
      leaf half-life {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-45>;;Decay half life (in minutes)";
          range "1..45";
        }
      }
      leaf reuse {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-20000>;;Reuse threshold";
          range "1..20000";
        }
      }
      leaf suppress {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-20000>;;Suppress threshold";
          range "1..20000";
        }
      }
      leaf max-suppress-time {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Max suppress time (in minutes)";
          range "1..255";
        }
      }
    }

    // interface * / logging
    container logging {
      tailf:info "Configure logging for interface";

      // interface * / logging events
      container events {
        tailf:info "Interface events";

        // interface * / logging events bundle-status
        leaf bundle-status {
          tailf:info "BUNDLE/UNBUNDLE messages";
          type empty;
        }

        // interface * / logging events link-status
        leaf link-status {
          tailf:info "UPDOWN and CHANGE messages";
          type empty;
        }

        // interface * / logging events nfas-status
        leaf nfas-status {
          tailf:info "NFAS D-channel status messages";
          type empty;
        }

        // interface * / logging events spanning-tree status
        container spanning-tree {
          tailf:info "Spanning-tree Interface events";
          leaf "status" {
            tailf:info "Spanning-tree state change messages";
            type empty;
          }
        }

        // interface * / logging events subif-link-status
        container subif-link-status {
          tailf:info "Sub-interface UPDOWN and CHANGE messages";
          tailf:cli-delete-when-empty;
          presence true;
          leaf ignore-bulk {
            tailf:info "Do not log messages when the main interface is transitioning";
            type empty;
          }
        }

        // interface * / logging events trunk-status
        leaf trunk-status {
          tailf:info "TRUNK status messages";
          type empty;
        }

        // interface * / logging events lsp-status
        uses logging-events-lsp-status-grouping;

        // interface * / logging events sub-lsp-status state
        container sub-lsp-status {
          tailf:info "Enable all sub-LSP state change alarms";
          leaf state {
            tailf:info "Enable all sub-LSP UP/DOWN change alarms";
            type empty;
          }
        }

        // interface * / logging events pcalc-failure
        leaf pcalc-failure {
          tailf:info "Enable logging for path calculation failures";
          tailf:cli-full-command;
          type empty;
        }
      }

      // interface * / logging ip access-list cache
      container ip {
        tailf:info "IP configuration";
        container access-list {
          tailf:info "Access-list";
          container cache {
            tailf:info "Optimized logging";
            leaf in {
              tailf:info "inbound packet logs";
              type empty;
            }
            leaf out {
              tailf:info "outbound packet logs";
              type empty;
            }
          }
        }
      }
    }

    // interface * / storm-control
    container storm-control {
      tailf:info "storm configuration";

      // interface * / storm-control action level
      container action {
        tailf:info "Action to take for storm..control;";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "
              +"of bandwidth";
            range "0..100";
          }
        }
      }

      // interface * / storm-control broadcast level
      container broadcast {
        tailf:info "Broadcast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "
              +"of bandwidth";
            range "0..100";
          }
        }
      }

      container multicast {
        tailf:info "Multicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "
              +"of bandwidth";
            range "0..100";
          }
        }
      }
      container unicast {
        tailf:info "Unicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "
              +"of bandwidth";
            range "0..100";
          }
        }
      }
    }
  }

  // grouping subinterface-common-grouping
  grouping subinterface-common-grouping {

    // interface * / rewrite
    container rewrite {
      tailf:info "Set the tag rewriting policy for this EFP";
      container ingress {
        tailf:info "Set the tag rewriting policy for this EFP";
        container tag {
          tailf:info "Set the tag rewriting policy for this EFP";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice tag-choice {
            // interface * / rewrite ingress tag pop
            leaf pop {
              tailf:info "Remove one or more tags";
              type enumeration {
                enum "1" {
                  tailf:info "Remove outer tag only";
                }
                enum "2" {
                  tailf:info "Remove two outermost tags";
                }
              }
            }
            // interface * / rewrite ingress tag push
            leaf push {
              tailf:info "Push one or more tags";
              tailf:cli-incomplete-command;
              type empty;
            }
            // interface * / rewrite ingress tag translate
            leaf translate {
              tailf:info "Replace tags with other tags";
              tailf:cli-incomplete-command;
              type enumeration {
                enum "1-to-1" {
                  tailf:info "Replace the outermost tag with another tag";
                }
                enum "1-to-2" {
                  tailf:info "Replace the outermost tag with two tags";
                }
                enum "2-to-1" {
                  tailf:info "Replace the outermost two tags with one tag";
                }
                enum "2-to-2" {
                  tailf:info "Replace the outermost two tags with two "+
                    "other tags";
                }
              }
            }
          }

          leaf dot1ad {
            when "not(../pop)" {
              tailf:dependency "../pop";
            }
            tailf:info "Push a Dot1ad tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }
          leaf dot1q {
            when "not(../pop)" {
              tailf:dependency "../pop";
            }
            tailf:info "Push a Dot1Q tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }
          leaf second-dot1q {
            when "(../dot1q and not(../dot1ad))" {
              tailf:dependency "../dot1ad";
              tailf:dependency "../dot1q";
            }
            tailf:info "Push another Dot1Q tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }

          // [symmetric]
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum symmetric {
                tailf:info "All rewrites must be symmetric";
              }
            }
          }
        }
      }
    }

    // interface * / dot1q vlan
    container dot1q {
      tailf:info "802.1Q VLAN configuration";
      container vlan {
        tailf:info "Configure a VLAN ID on the subinterface";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf vlan-id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4094>;;Single VLAN id";
            range "1..4094";
          }
        }
        leaf second-dot1q {
          tailf:cli-drop-node-name;
          type union {
            type uint16 {
              tailf:info "<1-4094>;;Configure second (inner 802.1Q) VLAN ID on the subinterface";
              range "1..4094";
            }
            type string {
              // VLAN range
            }
            type enumeration {
              enum any {
                tailf:info "Match any VLAN id";
              }
            }
          }
        }
      }
    }

      // interface * / dot1ad
    container dot1ad {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf vlan-id {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-4094>;;Single VLAN id";
          range "1..4094";
        }
      }
      leaf second-dot1d {
        tailf:cli-drop-node-name;
        type union {
          type uint16 {
            tailf:info "<1-4094>;;Single VLAN id";
            range "1..4094";
          }
          type string {
            // VLAN range
          }
          type enumeration {
            enum any {
              tailf:info "Match any VLAN id";
            }
          }
        }
      }
    }

    // interface * / l2protocol cpsv
    container l2protocol {
      tailf:info "Layer 2 protocol handling";
      leaf cpsv {
        tailf:info "CDP, PVST+, STP, and VTP protocols";
        type enumeration {
          enum drop {
            tailf:info "Drop these protocol packets";
          }
          enum reverse-tunnel {
            tailf:info "Tunnel at egress";
          }
          enum tunnel {
            tailf:info "Tunnel at ingress";
          }
        }
      }
    }

    // interface * / ipsubscriber
    container ipsubscriber {
      tailf:info "Configure IP Subscriber settings";

      // interface * / ipsubscriber ipv4
      container ipv4 {
        tailf:info "Enable IPv4 Subscriber";

        // interface * / ipsubscriber ipv4 l2-connected
        container l2-connected {
          tailf:info "Enable L2-connected IP Subscriber";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-if-ipsub-ipv4-l2conn";

          // interface * / ipsubscriber ipv4 l2-connected / initiator
          container initiator {
            tailf:info "Configure IP Subscriber initiator";

            // interface * / ipsubscriber ipv4 l2-connected / initiator dhcp
            leaf dhcp {
              tailf:info "Configure DHCP as first-sign-of-life protocol for IPv4 subscriber";
              type empty;
            }
          }
        }
      }

      // interface * / ipsubscriber ipv6
      container ipv6 {
        tailf:info "Enable Ipv6 Subscriber";

        // interface * / ipsubscriber ipv6 l2-connected
        container l2-connected {
          tailf:info "Enable L2-connected IP Subscriber";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-if-ipsub-ipv6-l2conn";

          // interface * / ipsubscriber ipv6 l2-connected / initiator dhcp
          container initiator {
            tailf:info "Configure IP Subscriber initiator";
            leaf dhcp {
              tailf:info "Configure DHCP as first-sign-of-life protocol for Ipv6 subscriber";
              type empty;
            }
          }
        }
      }
    }
  }

  grouping interface-bfd-grouping {

    // interface * / bfd
    container bfd {
      tailf:info "BFD interface configuration commands";
      // interface * / bfd address-family
      container address-family {
        tailf:info "Set configuration for a given address family";
        container ipv4 {
          tailf:info "Set configuration for the IPv4 address family";
          // interface * / bfd address-family timers
          container timers {
            tailf:info "Set the timers that determine when a BFD session "+
              "defaults to down";
            // interface * / bfd address-family timers start
            leaf start {
              tailf:info "The time since starting a BFD session before it "+
                "is considered to have gone down";
              type uint16 {
                tailf:info "<60-3600>;;Time in seconds";
                range "60..3600";
              }
            }
            // interface * / bfd address-family timers nbr-unconfig
            leaf nbr-unconfig {
              tailf:info "The time since a BFD signalled that a peer session"+
                "is unconfigured before it is considered to have gone down";
              type uint16 {
                tailf:info "<60-3600>;;Time in seconds";
                range "60..3600";
              }
            }
          }
          // interface * / bfd address-family multiplier
          leaf multiplier {
            tailf:info "Set the preferred multiplier for the BFD session";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<2-50>;;The preferred multiplier for the BFD "+
                "session";
              range "2..50";
            }
          }
          // interface * / bfd address-family destination
          leaf destination {
            tailf:info "Set the destination address for the BFD session";
            tailf:cli-full-command;
            type inet:ipv4-address {
              tailf:info "IPv4 destination address for the BFD session";
            }
          }
          // interface * / bfd address-family fast-detect
          leaf fast-detect {
            tailf:info "Enable fast detection using BFD on bundle members";
            tailf:cli-full-command;
            type empty;
          }
          // interface * / bfd address-family minimum-interval
          leaf minimum-interval {
            tailf:info "Set the preferred minimum interval for the BFD "+
              "session";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<15-30000>;;The preferred minimum interval "+
                "(in ms) for the BFD session";
              range "15..30000";
            }
          }
        }
      }

      // interface * / bfd echo
      leaf echo {
        tailf:info "Use echo adjunct as bfd detection mechanism";
        type empty;
      }

      // interface * / bfd interval
      container interval {
        tailf:info "Transmit interval between BFD packets";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-reset-container;
        leaf msecs {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<750-999>;;Milliseconds";
            range "750..999";
          }
        }
        leaf min_rx {
          tailf:info "Minimum receive interval capability";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<750-999>;;Milliseconds";
            range "750..999";
          }
        }
        leaf multiplier {
          tailf:info "Multiplier value used to compute holddown";
          type uint8 {
            tailf:info "<3-50>;;value used to multiply the interval";
            range "3..50";
          }
        }
      }
    }
  }

  // grouping non-subinterface-common-grouping
  grouping non-subinterface-common-grouping {

    // interface * / backup
    container backup {
      tailf:info "Modify backup parameters";
      container interface {
        tailf:info "Configure an interface as a backup";
        uses interface-name-grouping;
      }
    }

    // interface * / cdp
    leaf cdp {
      tailf:info "Enable CDP on an interface";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / dual-active
    container dual-active {
      tailf:info "VS dual-active configuration command";
      leaf fast-hello {
        tailf:info "dual-active fast-hello detection method";
        type empty;
      }
    }

    // interface * / l2transport
    container l2transport {
      tailf:info "Enable Layer 2 transport and enter its "+
        "configuration submode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-l2";
      presence true;

      // interface * / l2transport / service-policy
      uses interface-service-policy-grouping;

      // interface * / l2transport / l2protocol cpsv
      container l2protocol {
        tailf:info "Layer 2 protocol handling";
        leaf cpsv {
          tailf:info "CDP, PVST+, STP, and VTP protocols";
          type enumeration {
            enum drop {
              tailf:info "Drop these protocol packets";
            }
            enum reverse-tunnel {
              tailf:info "Tunnel at egress";
            }
            enum tunnel {
              tailf:info "Tunnel at ingress";
            }
          }
        }
      }
    }

    // interface * / platform
    container platform {
      tailf:info "platform specific interface configuration";
      container qos {
        tailf:info "qos command keyword";
        leaf channel-consistency {
          tailf:info "enable or disable qos consistency checks";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }

    // interface * / xconnect
    container xconnect {
      tailf:info "Xconnect commands";
      leaf vfi {
        tailf:info "connect to a virtual forwarding instance";
        type string {
          tailf:info "WORD;;VFI name";
        }
      }
    }

    uses interface-switch-grouping;
  }


  // interface tunnel-te*
  // interface tunnel-mte*
  grouping interface-tunnel-te-grouping {

    // interface tunnel-te* / signalled-name
    leaf signalled-name {
      tailf:info "The signaling name to assign to tunnel";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;The name to be included in signaling";
      }
    }

    // interface tunnel-te* / signalled-bandwidth
    container signalled-bandwidth {
      tailf:info "Tunnel bandwidth requirement to be signalled";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf sub-pool {
        tailf:info "Specify sub-pool bandwidth";
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf bandwidth {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-4294967295>;;Bandwidth requirement in kbps";
        }
      }
      leaf class-type {
        when "not(../sub-pool)" {
          tailf:dependency "../sub-pool";
        }
        tailf:info "Specify the bandwidth class type";
        type uint8 {
          tailf:info "<0-1>;;Class type number";
          range "0..1";
        }
      }
    }

    // interface tunnel-te* / priority
    container priority {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf setup {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-7>;;Setup Priority";
          range "0..7";
        }
      }
      leaf hold-value {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-7>;;Hold Priority";
        }
      }
    }

    // interface tunnel-te* / fast-reroute
    leaf fast-reroute {
      tailf:info "Specify MPLS tunnel can be fast-rerouted";
      tailf:cli-full-command;
      type empty;
    }

    // interface tunnel-te* / record-route
    leaf record-route {
      tailf:info "Record the route used by the tunnel";
      tailf:cli-full-command;
      type empty;
    }

    // interface tunnel-te* / affinity
    container affinity {
      tailf:info "Link attributes for links traversed by tunnel";

      // interface tunnel-te* / affinity-value
      container "affinity-value" {
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        tailf:cli-drop-node-name;
        leaf "value" {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<0x0-0xffffffff>;;Affinity value";
            pattern "0x[0-9a-fA-F]+";
          }
        }
        leaf mask {
          type string {
            tailf:info "<0x0-0xffffffff>;;Affinity mask value";
            pattern "0x[0-9a-fA-F]+";
          }
        }
      }

      // interface * / affinity include *
      list "include" {
        tailf:info "Affinity to include in the loose sense";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;Affinity name";
          }
        }
      }

      // interface * / affinity include-strict *
      list include-strict {
        tailf:info "Affinity to include in the strict sense";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;Affinity name";
          }
        }
      }

      // interface * / affinity exclude *
      list exclude {
        tailf:info "Affinity to exclude";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;Affinity name";
          }
        }
      }
    }
  }


  // used for:
  // interface tunnel-te* / path-option *
  // interface tunnel-mte* / destination * / path-option *
  grouping interface-tunnel-path-option-grouping {
    list path-option {
      tailf:info "Primary or fallback path setup option";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-incomplete-command;
      key preference-priority;
      leaf preference-priority {
        type uint16 {
          tailf:info "<1-1000>;;Preference for this path option";
          range "1..1000";
        }
      }

      choice path-option-choice {
        container dynamic {
          tailf:info "Setup based on dynamically allocated path";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          presence true;
        }
        container explicit {
          tailf:info "Setup based on preconfigured path";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice path-choice {
            leaf identifier {
              tailf:info "Specify an IP explicit path by number";
              type uint32 {
                tailf:info "<1-4294967295>;;Specify an IP explicit path "+
                  "by number";
              }
            }
            leaf name {
              tailf:info "Specify an IP explicit path by name";
              type string {
                tailf:info "WORD;;Specify an IP explicit path by name";
              }
            }
          }
        }
      }
      leaf pce {
        tailf:info "Use Path Computation Element";
        tailf:cli-break-sequence-commands;
        type empty;
      }
      leaf segment-routing {
        tailf:info "Require segment routing`";
        type empty;
      }
      leaf verbatim {
        tailf:info "Do not require topology database for explicit path";
        type empty;
      }
      leaf lockdown {
        tailf:info "Not a candidate for reoptimization";
        type empty;
      }
      // [ ospf instance-name area { value | address } ]
      container ospf {
        tailf:info "Limit CSPF to a single OSPF instance and area";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf instance-name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;OSPF instance name";
          }
        }
        leaf area {
          tailf:info "OSPF area";
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;OSPF area ID in IP address format";
            }
          }
        }
      }
      // interface * / path-option * attribute-set
      leaf attribute-set {
        tailf:info "Attribute set for this LSP";
        type string {
          tailf:info "WORD;;Specify attribute-set name (max 64 char)";
          length "1..64";
        }
      }
      // interface * / path-option * protected-by
      leaf protected-by {
        tailf:info "Index of the protecting path-option";
        type uint32 {
          tailf:info "<1-1000>;;Index of the protecting path-option";
          range "1..1000";
        }
      }
    }
  }


  // interface-name-grouping - all interface lists collected
  grouping interface-name-grouping {
    choice interface-choice {

      leaf Bundle-Ether {
        tailf:info "Aggregated Ethernet interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-65535>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Bundle-Ether/id";
        }
      }
      container Bundle-Ether-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Bundle-Ether {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/Bundle-Ether-subinterface/Bundle-Ether/id";
          }
        }
      }

      leaf BVI {
        tailf:info "Bridge-Group Virtual Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-65535>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/BVI/id";
        }
      }

      leaf FastEthernet {
        tailf:info "FastEthernet IEEE 802.3";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/FastEthernet/id";
        }
      }
      container FastEthernet-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf FastEthernet {
          tailf:info "FastEthernet IEEE 802.3";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subid";
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/FastEthernet-subinterface/"+
              "FastEthernet/id";
          }
        }
      }

      leaf GigabitEthernet {
        tailf:info "GigabitEthernet IEEE 802.3z";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/GigabitEthernet/id";
        }
      }
      container GigabitEthernet-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf GigabitEthernet {
          tailf:info "GigabitEthernet IEEE 802.3z";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subif";
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/GigabitEthernet-subinterface/GigabitEthernet/id";
          }
        }
      }

      leaf TenGigE {
        tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/TenGigE/id";
        }
      }
      container TenGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf TenGigE {
          tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/TenGigE-subinterface/TenGigE/id";
          }
        }
      }

      leaf FortyGigE {
        tailf:info "FortyGigabitEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/FortyGigE/id";
        }
      }
      container FortyGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf FortyGigE {
          tailf:info "FortyGigabitEthernet/IEEE 802.3 interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/FortyGigE-subinterface/FortyGigE/id";
          }
        }
      }

      leaf HundredGigE {
        tailf:info "HundredGigEthernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/HundredGigE/id";
        }
      }
      container HundredGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf HundredGigE {
          tailf:info "HundredGigEthernet";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subif";
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/HundredGigE-subinterface/HundredGigE/id";
          }
        }
      }

      leaf PW-Ether {
        tailf:info "Pseudo-Wire Ethernet interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-32768>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/PW-Ether/id";
        }
      }
      //todo: subinterface PW-Ether

      leaf Loopback {
        tailf:info "Loopback interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info "<0-2147483647>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Loopback/id";
        }
      }
      leaf MgmtEth {
        tailf:info "Ethernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/MgmtEth/id";
        }
      }
      leaf Multilink {
        tailf:info "Multilink network interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Multilink/id";
        }
      }
      container Multilink-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Multilink {
          tailf:info "Multilink network interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/Multilink-subinterface/Multilink/id";
          }
        }
      }

      leaf SRP {
        tailf:info "SRP interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/SRP/id";
        }
        type string {
          pattern "[0-9]+.*";
        }
      }

      leaf Null {
        tailf:info "Null interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-0>";
          pattern "0";
        }
      }

      leaf Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info "<1-512>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Port-channel/id";
        }
      }

      leaf POS {
        tailf:info "Packet over SONET/SDH network interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in "+
            "Rack/Slot/Instance/Port format";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/POS/id";
        }
      }

      container POS-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf POS {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern '[0-9]+/[0-9]+/[0-9]+/[0-9]+\.[0-9]+';
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/POS-subinterface/POS/id";
          }
        }
      }

      leaf Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in "+
            "Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+(:[0-9]+)?";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Serial/id";
        }
      }

      container Serial-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Serial {
          tailf:info "Serial interface";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            tailf:info "R/S/I/P;;Forward interface in "+
              "Rack/Slot/Instance/Port format";
            pattern '[0-9]+(/[0-9]+)+(:[0-9]+)?\.[0-9]+';
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/Serial-subinterface/Serial/id";
          }
        }
      }

      leaf tunnel-ip {
        tailf:info "GRE/IPinIP Tunnel Interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<0-65535>";
        }
        tailf:non-strict-leafref {
           path "/cisco-ios-xr:interface/tunnel-ip/id";
        }
      }

      leaf tunnel-te {
        tailf:info "MPLS Traffic Engineering Tunnel interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<0-65535>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/tunnel-te/id";
        }
      }

      leaf tunnel-tp {
        tailf:info "MPLS Transport Protocol Tunnel interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<0-65535>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/tunnel-tp/id";
        }
      }

      leaf tunnel-mte {
        tailf:info "MPLS Traffic Engineering P2MP Tunnel interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<0-65535>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/tunnel-mte/id";
        }
      }

      leaf tunnel-ipsec {
        tailf:info "IPSec Tunnel interface(s)";
        //tailf:cli-allow-join-with-value {
        //tailf:cli-display-joined;
        //}
        type uint32 {
          tailf:info "<0-4294967295>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/tunnel-ipsec/id";
        }
      }

      leaf ATM {
        tailf:info "ATM Network Interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port"+
            "format";
          pattern "[0-9]+.*";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/ATM/id";
        }
      }

      container ATM-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf ATM {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+.*";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/ATM-subinterface/ATM/id";
          }
        }
      }

      leaf Vlan {
        tailf:info "Iosxr Vlans";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Vlan/id";
        }
      }

      leaf CEM {
        tailf:info "Circuit Emulation interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port"+
            "format";
          pattern "[0-9]+.*";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/CEM/id";
        }
      }
    }
  }


  // interface-grouping
  grouping interface-grouping {

    // interface Loopback*
    list Loopback {
      tailf:info "Loopback interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Loopback interface number";
        type uint32 {
          tailf:info "<0-2147483647>;;Loopback interface number";
          range "0..2147483647";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface Bundle-Ether*
    list Bundle-Ether {
      tailf:info "Aggregated Ethernet interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Bundle-Ether interface id";
        type uint16 {
          tailf:info "<1-65535>";
          range "1..65535";
        }
      }

      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-bundle-grouping;
    }

    // interface Bundle-Ether-subinterface*
    container Bundle-Ether-subinterface {
      tailf:cli-drop-node-name;
      list Bundle-Ether {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Bundle-Ether sub-interface id";
          //tailf:cli-diff-dependency "../../../ Bundle-Ether";
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
        uses interface-bundle-grouping;
      }
    }

    // interface MgmtEth*
    list MgmtEth {
      tailf:info "Ethernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Ethernet/IEEE 802.3 interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/.+/.+/.+";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // interface TenGigE*
    list TenGigE {
      tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Ten Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface TenGigE*
    container TenGigE-subinterface {
      tailf:cli-drop-node-name;
      list TenGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Ten Gigabit Ethernet sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface FortyGigE #/#/#/#
    list FortyGigE {
      tailf:info "FortyGigEthernet";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Forty Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface FortyGigE #/#/#/#.#
    container FortyGigE-subinterface {
      tailf:cli-drop-node-name;
      list FortyGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Forty Gigabit Ethernet sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface HundredGigE*
    list HundredGigE {
      tailf:info "HundredGigEthernet";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Hundred Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface HundredGigE*
    container HundredGigE-subinterface {
      tailf:cli-drop-node-name;
      list HundredGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Hundred Gigabit Ethernet sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface FastEthernet*
    list FastEthernet {
      tailf:info "FastEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Fast Ethernet interface id";
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface FastEthernet*
    container FastEthernet-subinterface {
      tailf:cli-drop-node-name;
      list FastEthernet {
        tailf:info "FastEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name "config-if";
        key id;
        leaf id {
          tailf:info "Fast Ethernet sub-interface id";
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subid";
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport {
              tailf:info "Treat as an attachment circuit";
            }
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface GigabitEthernet*
    list GigabitEthernet {
      tailf:info "GigabitEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface GigabitEthernet*
    container GigabitEthernet-subinterface {
      tailf:cli-drop-node-name;
      list GigabitEthernet {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Gigabit Ethernet sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface nve *
    list nve {
      tailf:info "Network Virtualization Endpoint Interface(s)";
      tailf:cli-mode-name "config-if-nve";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        tailf:info "nve interface name";
        type uint16 {
          tailf:info "<0-65535>;;Config allowed on NVEs, range is 0-65535";
          range "0..65535";
        }
      }

      uses interface-common-grouping;

      // interface nve* / redundancy
      container redundancy {
        tailf:info "Redundancy";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-nve-red";

        // interface nve* / redundancy / backbone
        container backbone {
          tailf:info "Configure ICCP backbone";

          // interface nve* / redundancy / backbone mpls
          container mpls {
            tailf:info "ICCP MPLS backbone";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-nve-red-backbone-mpls";
            // interface nve* / redundancy / backbone mpls / iccp
            container iccp {
              tailf:info "Inter-Chassis Communication Protocol";
              leaf group {
                tailf:info "Configure ICCP group number";
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter group number";
                  range "1..4294967295";
                }
              }
            }
          }

          // interface nve* / redundancy / backbone vxlan
          container vxlan {
            tailf:info "ICCP VXLAN backbone";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-nve-red-backbone-vxlan";
            // interface nve* / redundancy / backbone vxlan / iccp
            container iccp {
              tailf:info "Inter-Chassis Communication Protocol";
              leaf group {
                tailf:info "Configure ICCP group number";
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter group number";
                  range "1..4294967295";
                }
              }
            }
          }
        }
      }

      // interface nve* / member vni *
      container member {
        tailf:info "NVE VN-Segment Membership";
        list vni {
          tailf:info "Virtual Network Identifier";
          tailf:cli-mode-name "config-nve-vni";
          tailf:cli-range-list-syntax;
          key id;
          leaf id {
            type union {
              type uint32 {
                tailf:info "<1-16777215>;;Single VNI";
                range "1..16777215";
              }
              type string {
                tailf:info "<1-X>;;VNI range";
              }
            }
          }

          // interface nve* / member vni * / vrf
          leaf vrf {
            tailf:info "Associate a VRF with VxLAN segment";
            tailf:cli-full-command;
            //tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
            type string {
              tailf:info "WORD;;VRF name";
            }
          }

          // interface nve* / member vni * / suppress-unknown-unicast-flooding
          leaf suppress-unknown-unicast-flooding {
            tailf:info "Configure the suppression of unknown unicast flooding";
            type empty;
          }

          // interface nve* / member vni * / host-reachability protocol bgp
          container host-reachability {
            tailf:info "Configure host reachability advertisement";
            leaf protocol {
              tailf:info "Control protocol to use";
              type enumeration {
                enum "bgp" {
                  tailf:info "Border Gateway Protocol";
                }
              }
            }
          }
          // interface nve* / member vni * /  host-reachabilty protocol bgp
          // Note: ASR5.3 spelling typo support.
          container host-reachabilty {
            tailf:info "Configure host reachabilty advertisement";
            leaf protocol {
              tailf:info "Control protocol to use";
              type enumeration {
                enum "bgp" {
                  tailf:info "Border Gateway Protocol";
                }
              }
            }
          }

          // interface nve* / member vni * / load-balance per-evi
          container load-balance {
            tailf:info "Configure load balance mode";
            leaf per-evi {
              tailf:info "Configure per-evi load balance mode (default is per-flow)";
              type empty;
            }
          }

          // interface nve* / member vni * / mcast-group
          container mcast-group {
            tailf:info "associate a multicast core group with VxLAN segment(s)";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ip-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Single mcast ID or Start of range";
              }
            }
            leaf end-ip-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;End of mcast IP range";
              }
            }
          }
        }
      }

      // interface nve* / remap-replication-servers
      leaf remap-replication-servers {
        tailf:info "Remap Replication servers to VNIs";
        tailf:cli-full-command;
        type empty;
      }

      // interface nve* / replication-server
      leaf replication-server {
        tailf:info "Configure a replication server";
        tailf:cli-full-command;
        type inet:ipv4-address {
        }
      }

      // interface nve* / source-interface Loopback
      container source-interface {
        tailf:info "Configure source interface for Network Virtualization Endpoint";
        leaf Loopback {
          tailf:info "Loopback interface";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type uint32 {
            tailf:info "<0-2147483647>";
            range "0..2147483647";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/Loopback/id";
          }
        }
      }

      // interface nve* / anycast source-interface Loopback
      container anycast {
        tailf:info "Configure anycast mode parameters for this VTEP";
        container source-interface {
          tailf:info "Configure source interface for the anycast mode";
          leaf Loopback {
            tailf:info "Loopback interface";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            type uint32 {
              tailf:info "<0-2147483647>";
              range "0..2147483647";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:interface/Loopback/id";
            }
          }
        }
      }
    }

    // interface PW-Ether*
    list PW-Ether {
      tailf:info "Pseudo-Wire Ethernet interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Pseudo-Wire Ethernet interface id";
        type uint16 {
          tailf:info "<1-32768>";
          range "1..32768";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;

      // interface PW-Ether* / attach generic-interface-list
      container attach {
        tailf:info "Attach to an interface list";
        leaf generic-interface-list {
          tailf:info "Interface List";
          type string {
            tailf:info "WORD;;The name of the interface list";
          }
        }
      }
    }

    // interface PW-Ether*
    container PW-Ether-subinterface {
      tailf:cli-drop-node-name;
      list PW-Ether {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Pseudo-Wire Ethernet sub-interface id";
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
        leaf l2transport {
          tailf:info "Treat as an attachment circuit";
          tailf:cli-hide-in-submode;
          type empty;
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;

        // interface PW-Ether* / attach generic-interface-list
        container attach {
          tailf:info "Attach to an interface list";
          leaf generic-interface-list {
            tailf:info "Interface List";
            type string {
              tailf:info "WORD;;The name of the interface list";
            }
          }
        }
      }
    }

    // interface Port-channel*
    list Port-channel {
      tailf:info "Ethernet Channel of interfaces";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Port-channel interface id";
        type uint32 {
          tailf:info "<1-512>;;Port-channel interface number";
          range "1..512";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface POS*
    list POS {
      tailf:info "Packet over SONET/SDH network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "POS interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;
      container pos {
        tailf:info "Modify POS parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-pos";
        leaf crc {
          tailf:cli-full-command;
          type enumeration {
            enum "16" {
              tailf:info "16-bit CRC mode ";
            }
            enum "32" {
              tailf:info "32-bit CRC mode (default)";
            }
          }
        }
      }
    }

    // subinterface POS*
    container POS-subinterface {
      tailf:cli-drop-node-name;
      list POS {
        tailf:info "Packet over SONET/SDH network interface(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name "config-subif";
        key id;
        leaf id {
          tailf:info "POS sub-interface id";
          type string {
            pattern '[0-9]+/[0-9]+/[0-9]+/[0-9]+\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses interface-common-grouping;
        uses subinterface-common-grouping;
        uses interface-pointtopoint-grouping;
      }
    }

    // interface BVI*
    list BVI {
      tailf:info "Bridge-Group Virtual Interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "BVI interface id";
        type uint16 {
          tailf:info "<1-65535>";
          range "1..65535";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface Vlan*
    list Vlan {
      tailf:info "Iosxr Vlans";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Vlan interface id";
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface tunnel-ip*
    list tunnel-ip {
      tailf:info "GRE/IPinIP Tunnel Interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "tunnel-ip interface id";
        type uint16 {
          tailf:info "<0-65535>";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;

      // interface tunnel-ip* / tunnel
      container tunnel {
        tailf:info "Configure GRE tunnel parameters";

        // interface tunnel-ip* / tunnel mode gre
        container mode {
          tailf:info "Tunnel encapsulation method (default: gre ipv4)";
          leaf gre {
            tailf:info "IP over GRE encapsulation";
            type enumeration {
              enum ipv4 {
                tailf:info "GRE over IPV4 encapsulation";
              }
              enum ipv6 {
                tailf:info "GRE over IPV6 encapsulation";
              }
            }
          }
        }

        // interface tunnel-ip* / tunnel source
        leaf source {
          tailf:info "Tunnel source physical interface";
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // interface tunnel-ip* / tunnel destination
        leaf destination {
          tailf:info "Tunnel destination IP address";
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Ip Address";
            }
            type inet:ipv6-address {
              tailf:info "X:X::X;;IPV6 address of the tunnel destination";
            }
          }
        }
      }
    }

    // interface tunnel-te*
    list tunnel-te {
      tailf:info "MPLS Traffic Engineering Tunnel interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "tunnel-te interface id";
        type uint16 {
          tailf:info "<0-65535>";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      uses interface-tunnel-te-grouping;

      // interface tunnel-te* / bfd
      container bfd {
        tailf:info "Configure BFD parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-tunte-bfd";
        presence true;

        // interface tunnel-te* / bfd / multiplier
        leaf multiplier {
          tailf:info "Detect multiplier";
          type uint8 {
            tailf:info "3-10;;Detect multiplier (default 3)";
            range "3..10";
          }
        }

        // interface tunnel-te* / bfd / fast-detect
        container fast-detect {
          tailf:info "Enable BFD fast detection";
          tailf:cli-delete-when-empty;
          presence true;
          // interface tunnel-te* / bfd / fast-detect sbfd
          leaf sbfd {
            tailf:info "Enable SBFD";
            type empty;
          }
        }

        // interface tunnel-te* / bfd / minimum-interval
        leaf minimum-interval {
          tailf:info "Hello interval";
          type uint16 {
            tailf:info "3-30000;;Hello interval in milliseconds (default 100)";
            range "3..30000";
          }
        }

        // interface tunnel-te* / bfd / dampening
        container dampening {
          tailf:info "Configure dampening intervals to bring tunnel up";

          // interface tunnel-te* / bfd / dampening maximum-wait
          leaf maximum-wait {
            tailf:info "Maximum delay bringing up the tunnel";
            type uint32 {
              tailf:info "<1-518400000>;;Delay in milliseconds (default 600000)";
              range "1..518400000";
            }
          }

          // interface tunnel-te* / bfd / dampening secondary-wait
          leaf secondary-wait {
            tailf:info "Secondary delay bringing up the tunnel";
            type uint32 {
              tailf:info "<1-518400000>;;Delay in milliseconds (default 20000)";
              range "1..518400000";
            }
          }

          // interface tunnel-te* / bfd / dampening initial-wait
          leaf initial-wait {
            tailf:info "Initial delay before bringing up the tunnel";
            type uint32 {
              tailf:info "<1-518400000>;;Delay in milliseconds (default 16000)";
              range "1..518400000";
            }
          }
        }

        // interface tunnel-te* / bfd / bringup-timeout
        leaf bringup-timeout {
          tailf:info "Timeout before BFD session bring up on new LSP is aborted";
          type uint16 {
            tailf:info "<10-3600>;;Wait for session to come up in seconds (default 60)";
            range "10..3600";
          }
        }

        // interface tunnel-te* / bfd / lsp-ping
        container lsp-ping {
          tailf:info "Configure periodic LSP ping";
          choice lsp-ping-choice {
            leaf disable {
              tailf:info "Disable periodic LSP Ping";
              type empty;
            }
            leaf interval {
              tailf:info "Periodic LSP ping interval";
              type uint16 {
                tailf:info "<60-3600>;;Periodic LSP Ping interval in seconds (default 120)";
                range "60..3600";
              }
            }
          }
        }
      }

      // interface tunnel-te* / load-share
      leaf load-share {
        tailf:info "Specify tunnel load-sharing metric";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Loadshare value. "+
            "Scale is the same as bandwidths.";
          range "1..4294967295";
        }
      }

      // interface tunnel-te* / auto-bw
      container auto-bw {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-tunte-autobw";

        // interface tunnel-te* / auto-bw / bw-limit
        container bw-limit {
          tailf:info "Set min/max bandwidth auto-bw can apply on a tunnel";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf min {
            tailf:info "Set minimum bandwidth auto-bw can apply on a tunnel";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-4294967295>;;Minimum bandwidth to apply (kbps)";
            }
          }
          leaf max {
            tailf:info "Set maximum bandwidth auto-bw can apply on a tunnel";
            type uint32 {
              tailf:info "<0-4294967295>;;Maximum bandwidth to apply (kbps)";
            }
          }
        }

        // interface tunnel-te* / auto-bw / overflow threshold
        container overflow {
          tailf:info "Configuring the tunnel overflow detection";
          uses interface-tunnel-te-auto-bw-threshold-grouping;
        }

        // interface tunnel-te* / auto-bw / underflow threshold
        container underflow {
          tailf:info "Configuring the tunnel underflow detection";
          uses interface-tunnel-te-auto-bw-threshold-grouping;
        }

        // interface tunnel-te* / auto-bw / adjustment-threshold
        container adjustment-threshold {
          tailf:info "Set the bandwidth change threshold to trigger "+
            "adjustment";
            leaf percentage {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Bandwidth change percent to trigger "+
                  "adjustment";
                range "1..100";
              }
            }
            leaf min {
              tailf:info "Set the bandwidth change value to trigger "+
                "adjustment";
              type uint32 {
                tailf:info "<10-4294967295>;;Bandwidth change value to "+
                  "trigger adjustment (kbps)";
                range "10..4294967295";
              }
            }
        }

        // interface tunnel-te* / auto-bw / application
        leaf application {
          tailf:info "Set the tunnel auto-bw application frequency";
          type uint16 {
            tailf:info "<5-10080>;;Auto-bw application frequency (minutes)";
            range "5..10080";
          }
        }
      }

      // interface tunnel-te* / autoroute
      container autoroute {
        tailf:info "Parameters for IGP routing over tunnel";

        // interface tunnel-te* / autoroute metric
        container metric {
          tailf:info "Specify MPLS tunnel metric";
          choice metric-choice {
            leaf absolute {
              tailf:info "Set metric mode absolute";
              type uint32 {
                tailf:info "<1-2147483647>;;Absolute metric";
                range "1..2147483647";
              }
            }
            leaf relative {
              tailf:info "Set metric mode relative";
              type int8 {
                tailf:info "<-10,+10>;;Relative metric";
                range "-10..10";
              }
            }
          }
        }

        // interface tunnel-te* / autoroute announce
        container announce {
          tailf:info "Announce tunnel to IGP";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-if-tunte-aa";
          presence true;

          // interface tunnel-te* / autoroute announce / metric
          container metric {
            tailf:info "Specify MPLS tunnel metric";
            choice metric-choice {
              // interface tunnel-te* / autoroute announce / metric constant
              leaf constant {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<1-2147483647>;;Set constant metric";
                  range "1..2147483647";
                }
              }
              // interface tunnel-te* / autoroute announce / metric absolute
              leaf absolute {
                tailf:info "Set metric mode absolute";
                type uint32 {
                  tailf:info "<1-2147483647>;;Absolute metric";
                  range "1..2147483647";
                }
              }
              // interface tunnel-te* / autoroute announce / metric relative
              leaf relative {
                tailf:info "Set metric mode relative";
                type int8 {
                  tailf:info "<-10,+10>;;Relative metric";
                  range "-10..10";
                }
              }
            }
          }
        }

        // interface tunnel-te* / autoroute destination *
        list destination {
          tailf:info "Adds static route to destination";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key addr;
          leaf addr {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Address of static route to add";
            }
          }
        }
      }

      // interface tunnel-te* / destination
      leaf destination {
        tailf:info "Specify tunnel destination";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination address";
        }
      }

      // interface tunnel-te* / forward-class
      leaf forward-class {
        tailf:info "Specify tunnel forward class for policy based routing";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-7>;;Forward class for the tunnel (default value 0)";
          range "1..7";
        }
      }

      // interface tunnel-te* / policy-class
      leaf policy-class {
        tailf:info "Specify classs for policy-based tunnel selection";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Default class for policy-based tunnel selection";
            }
          }
          type uint8 {
            tailf:info "<1-7>;;Tunnel policy class";
            range "1..7";
          }
        }
      }

      // interface tunnel-te* / soft-preemption
      leaf soft-preemption {
        tailf:info "Enable the soft-preemption feature on this tunnel";
        tailf:cli-full-command;
        type empty;
      }

      // interface tunnel-te* / path-protection
      leaf path-protection {
        tailf:info "Enable the path protection feature on this tunnel";
        tailf:cli-full-command;
        type empty;
      }

      // interface tunnel-te* / path-selection
      container path-selection {
        tailf:info "Path Selection Configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-tunte-path-sel";

        // interface tunnel-te* / path-selection / metric
        container metric {
          tailf:info "Metric Type for path calculation";
          leaf metric-type {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type enumeration {
              enum igp {
                tailf:info "Use IGP metric";
              }
              enum te {
                tailf:info "Use TE metric";
              }
            }
          }
        }

        // interface tunnel-te* / path-selection / segment-routing adjacency
        container segment-routing {
          tailf:info "Segment-routing path-selection options";
          leaf adjacency {
            tailf:info "Segment-routing adjacency path-selection type";
            type enumeration {
              enum protected {
                tailf:info "Use only protected adjacencies";
              }
              enum unprotected {
                tailf:info "Use only unprotected adjacencies";
              }
            }
          }
        }
      }

      // interface tunnel-te* / path-option *
      uses interface-tunnel-path-option-grouping;

      // interface tunnel-te* / pce
      container pce {
        tailf:info "Config PCE parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-pce";
        presence true;

        // interface tunnel-te* / pce / delegation
        leaf delegation {
          tailf:info "Enable PCE delegation";
          type empty;
        }
      }
    }

    // interface tunnel-tp*
    list tunnel-tp {
      tailf:info "MPLS Transport Protocol Tunnel interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "tunnel-tp interface id";
        type uint16 {
          tailf:info "<0-65535>";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface tunnel-mte*
    list tunnel-mte {
      tailf:info "MPLS Traffic Engineering P2MP Tunnel interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "tunnel-mte interface id";
        type uint16 {
          tailf:info "<0-65535>";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      uses interface-tunnel-te-grouping;

      // interface tunnel-mte* / destination *
      list destination {
        tailf:info "Specify a destination to an endpoint of the tunnel";
        tailf:cli-mode-name "config-if-p2mp-dest";
        key addr;
        leaf addr {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination address";
          }
        }
        // interface tunnel-mte* / destination * / path-option *
        uses interface-tunnel-path-option-grouping;
      }
    }

    // interface tunnel-ipsec*
    list tunnel-ipsec {
      tailf:info "IPSec Tunnel interface(s)";
      //NSO BUG: tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "tunnel-ipsec interface id";
        type uint32 {
          tailf:info "<0-4294967295>";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface ATM*
    list ATM {
      tailf:info "ATM Network Interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "ATM Network interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-atm-grouping;
    }

    // subinterface ATM* l2transport
    // subinterface ATM* point-to-point
    container ATM-subinterface {
      tailf:cli-drop-node-name;
      list ATM {
        tailf:info "ATM Network Interface(s)";
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "ATM Network sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        choice mode-choice {
          leaf l2transport {
            tailf:info "Treat as an attachment circuit";
            tailf:cli-full-command;
            tailf:cli-hide-in-submode;
            type empty;
          }
          leaf point-to-point {
            tailf:info "Treat as a point-to-point link";
            tailf:cli-full-command;
            tailf:cli-hide-in-submode;
            type empty;
          }
        }
        uses interface-common-grouping;
        uses subinterface-common-grouping;
        uses interface-atm-grouping;
      }
    }

    // interface Multilink*
    list Multilink {
      tailf:info "Multilink network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Multilink interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;
      uses interface-multilink-grouping;
    }

    // subinterface Multilink*
    container Multilink-subinterface {
      tailf:cli-drop-node-name;
      list Multilink {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Multilink sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses interface-common-grouping;
        uses subinterface-common-grouping;
        uses interface-pointtopoint-grouping;
        uses interface-multilink-grouping;
      }
    }

    // interface SRP*
    list SRP {
      tailf:info "SRP interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type string {
          pattern "[0-9]+.*";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;

      // interface SRP* / threshold
      container threshold {
        tailf:info "Commands to set the threshold for the appropriate Bit Error Rate";

        // interface SRP* / threshold b2-tca
        leaf b2-tca {
          tailf:info "Set B2 BER Threshold Crossing Alert (TCA) threshold";
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            range "3..9";
          }
        }
      }
    }

    // interface Serial*
    list Serial {
      tailf:info "Serial network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Serial network interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+(:[0-9]+)?";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;

      // interface Serial * / multilink
      container multilink {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-multilink";
        leaf group {
          tailf:info "Enter multilink group ID";
          type uint32 {
            tailf:info "<1-999999999>;;Group Id";
            range "1..999999999";
          }
        }
      }

      // interface Serial * / serial
      container serial {
        tailf:info "Modify Serial parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-serial";

        // interface Serial * / serial / crc
        leaf crc {
          tailf:info "Set the Encapsulation of this PVC";
          type enumeration {
            enum 16 {
              tailf:info "16-bit CRC mode (default)";
            }
            enum 32 {
              tailf:info "32-bit CRC mode";
            }
          }
        }

        // interface Serial * / serial / scramble
        leaf scramble {
          tailf:info "Enable payload scrambling on Serial interface";
          type empty;
        }
      }
    }

    container Serial-subinterface {
      tailf:cli-drop-node-name;
      list Serial {
        tailf:info "Serial network interface(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name "config-subif";
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:info "Serial network sub-interface id";
          type string {
            tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
            pattern '[0-9]+(/[0-9]+)+(:[0-9]+)?\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
            enum l2transport {
              tailf:info "Treat as an attachment circuit";
            }
          }
        }
        uses interface-common-grouping;
        uses interface-bfd-grouping;
        uses subinterface-common-grouping;
        uses interface-pointtopoint-grouping;
        leaf subinterface {
          tailf:info "Do not SET, internal testing leaf only";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // interface CEM*
    list CEM {
      tailf:info "Circuit Emulation interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Circuit Emulation interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+.*";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;

      // interface CEM* / cem
      container cem {
        tailf:info "Global CEM interface configuration subcommands";

        // interface CEM * / cem class-attach
        leaf class-attach {
          tailf:info "Attach a CEM class to this interface";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;CEM class name";
          }
        }

        // interface CEM * / cem dejitter
        leaf dejitter {
          tailf:info "Configure dejitter buffer";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-500>;;buffer size in milliseconds";
          }
        }
      }
    }
  }

  // bgp-address-family-pre-grouping
  grouping bgp-address-family-pre-grouping {

    // router bgp * / address-family * / label mode
    container label {
      tailf:info "Label-related configuration";
      container  mode {
        tailf:info "Select label mode";
        choice mode-choice {
          leaf per-ce  {
            tailf:info "Set per CE label mode";
            type empty;
          }
          leaf per-prefix {
            tailf:info "Set per perfix label mode";
            type empty;
          }
          leaf per-vrf {
            tailf:info "Set per VRF label mode";
            type empty;
          }
          leaf route-policy {
            tailf:info "Use a route policy to select prefixes for label "+
              "allocation mode";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
        }
      }
    }

    // router bgp * / address-family * / table-policy
    leaf table-policy {
      tailf:info "Configure policy for installation of routes to RIB";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of the policy";
      }
    }

    // router bgp * / address-family * / retain
    container retain {
      tailf:info "Accept/Retain specified bgp parameters";

      // router bgp * / address-family * / retain local-label
      leaf local-label {
        tailf:info "Delay the release of the local label as configured";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<3-60>;;Label retention time in minutes";
          range "3..60";
        }
      }

      // router bgp * / address-family * / retain route-target
      container route-target {
        tailf:info "Accept received updates with the specified route targets";
        choice route-target-choice {
          leaf all {
            tailf:info "Accept received updates containing at least one route target";
            type empty;
          }
          leaf route-policy {
            tailf:info "Accept received updates accepted by the specified policy";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:route-policy/name";
            }
          }
        }
      }
    }

    // router bgp * / address-family * / update
    container update {
      tailf:info "BGP Update generation configuration";
      container limit {
        tailf:info "Upper bound on transient memory usage for update "+
          "generation";
        leaf address-family {
          tailf:info "Update limit for address-family";
          type uint16 {
            tailf:info "<4-2048>;;Update limit in MegaBytes(MB); "+
              "default is 256 MB";
            range "4..2048";
          }
        }
        container sub-group {
          tailf:info "Update limit for sub-groups";
          leaf ebgp {
            tailf:info "Update limit for eBGP sub-groups";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-512>;;Update limit in MegaBytes(MB); "+
                "default is 32 MB";
              range "1..512";
            }
          }
          leaf ibgp {
            tailf:info "Update limit for iBGP sub-groups";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-512>;;Update limit in MegaBytes(MB); "+
                "default is 32 MB";
              range "1..512";
            }
          }
        }
      }
    }

    // router bgp * / address-family * / additional-paths
    container additional-paths {
      tailf:info "Additional paths configuration";

      // router bgp * / address-family ? / additional-paths receive
      leaf receive {
        tailf:info "Additional paths Receive capability";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / address-family ? / additional-paths send
      leaf send {
        tailf:info "Additional paths Send capability";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / address-family ? / additional-paths selection
      container selection {
        tailf:info "Additional paths selection";
        list route-policy {
          tailf:info "Route-policy for additional paths selection";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:route-policy/name";
            }
          }
        }
      }
    }

    // router bgp * / address-family * / weight
    leaf weight {
      tailf:info "Define or modify weight";
      tailf:cli-full-command;
      type union {
        type enumeration {
          enum reset-on-import {
            tailf:info "Reset weight of paths on import";
          }
        }
        type uint32 {
          tailf:info "<0-65535>;;default weight";
          range "0..65535";
        }
      }
    }

    // router bgp * / address-family * / advertise
    container advertise {
      tailf:info "Advertise BGP path";

      // router bgp * / address-family * / advertise best-external
      leaf best-external {
        tailf:info "Advertise best-external path";
        type empty;
      }

      // router bgp * / address-family * / advertise vpnv4 unicast
      container vpnv4 {
        tailf:info "VPNv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence true;
          uses router-bgp-af-advertise-grouping;
        }
      }

      // router bgp * / address-family * / advertise vpnv6 unicast
      container vpnv6 {
        tailf:info "Vpnv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence true;
          uses router-bgp-af-advertise-grouping;
        }
      }

      // router bgp * / address-family * / advertise l2vpn evpn
      container l2vpn {
        tailf:info "L2VPN Address Family";
        container evpn {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence true;
          uses router-bgp-af-advertise-grouping;
        }
      }
    }

    // router bgp * / address-family * / bgp
    container bgp {
      tailf:info "BGP Commands";

      // router bgp * / address-family * / bgp attribute-download
      leaf attribute-download {
        tailf:info "Configure attribute download for this address-family";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / address-family * / bgp dampening
      container dampening {
        tailf:info "Enable route-flap dampening";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-delete-when-empty;
        presence true;
        choice dampening-choice {
          case a {
            leaf half-life {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-45>;;Half-life time for the penalty";
                range "1..45";
              }
            }
            leaf reuse {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-20000>;;Value to start reusing a route";
                range "1..20000";
              }
            }
            leaf suppress {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-20000>;;Value to start suppressing a route";
                range "1..20000";
              }
            }
            leaf max-suppress-time {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-255>;;Maximum duration to suppress a stable route";
                range "1..255";
              }
            }
          }
          case b {
            // router bgp * / address-family * / bgp dampening route-policy
            leaf route-policy {
              tailf:info "Route policy to specify criteria for dampening";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Name of the policy";
              }
            }
          }
        }
      }

      // router bgp * / address-family * / bgp label-delay
      container label-delay {
        tailf:info "Specify delay for batching label processing";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-10>;;Delay, seconds part";
            range "0..10";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Delay, milliseconds part";
            range "0..999";
          }
        }
      }

      // router bgp * / address-family * / bgp client-to-client reflection
      container client-to-client {
        tailf:info "Configure client to client route reflection";
        container reflection {
          tailf:info "Reflection";

          // router bgp * / address-family * / bgp client-to-client reflection disable
          leaf disable {
            tailf:info "Disable";
            type empty;
          }
        }
      }
    }

    // router bgp * / address-family * / maximum-paths
    container maximum-paths {
      tailf:info "Forward packets over multiple paths";

      // router bgp * / address-family * / maximum-paths eibgp
      container eibgp {
        tailf:info "eiBGP-multipath";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths";
          }
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type  empty;
        }
      }

      // router bgp * / address-family * / maximum-paths ebgp
      container ebgp {
        tailf:info "eBGP-multipath";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths";
          }
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type  empty;
        }
      }

      // router bgp * / address-family * / maximum-paths ibgp
      container ibgp {
        tailf:info "iBGP-multipath";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths (limit includes backup path)";
          }
        }
        leaf unequal-cost {
          tailf:info "Allow multipaths to have different BGP nexthop IGP metrics";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type  empty;
        }
      }

    }

    // router bgp * / address-family * / distance
    container distance {
      tailf:info "Define an administrative distance";
      container bgp {
        tailf:info "BGP distance";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf external {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Distance for routes external to the AS";
            range "1..255";
          }
        }
        leaf internal {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Distance for routes internal to the AS";
            range "1..255";
          }
        }
        leaf local {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Distance for local routes";
            range "1..255";
          }
        }
      }
    }

    // router bgp * / address-family * / nexthop
    container nexthop {
      tailf:info "Nexthop";
      container resolution {
        tailf:info "Nexthop resolution";
        container prefix-length {
          tailf:info "Nexthop resolution prefix-length";
          leaf minimum {
            tailf:info "Set minimum prefix-length for nexthop "+
              "resolution";
            type uint16 {
              tailf:info "<0-32|128>;;Prefix-length value "+
                "(only 0 and 32|128 are supported)";
            }
          }
        }
      }
      leaf route-policy {
        tailf:info "Policy to filter out nexthop notification";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
      }
      container trigger-delay {
        tailf:info "Processing trigger delay";
        leaf critical {
          tailf:info "For critical notification";
          type uint32 {
            tailf:info "<0-4294967295>;;Delay in milliseconds";
          }
        }
        leaf non-critical {
          tailf:info "For non-critical notification";
          type uint32 {
            tailf:info "<0-4294967295>;;Delay in milliseconds";
          }
        }
      }
    }

    // router bgp * / address-family * / domain-distinguisher
    leaf domain-distinguisher {
      tailf:info "Globally unique identifier for IGP domain";
      tailf:cli-full-command;
      type string {
        tailf:info "<1-4294967295>:;;4 octet ASN";
      }
    }
  }

  // bgp-address-family-post-grouping
  grouping bgp-address-family-post-grouping {

    // router bgp * / address-family * / aggregate-address
    list aggregate-address {
      tailf:info "Configure BGP aggregate entries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "prefix";
      leaf "prefix" {
        type union {
          type ipv4-prefix {
            tailf:info "A.B.C.D/length;;IPv4 Aggregate address and mask or masklength";
          }
          type tailf:ipv6-address-and-prefix-length {
            tailf:info "X:X::X/length;;IPv6 Aggregate address and mask or masklength";
          }
        }
      }
      leaf as-set {
        tailf:info "Generate AS set path information";
        type empty;
      }
      leaf as-confed-set {
        tailf:info "Generate AS confed set path information";
        type empty;
      }
      leaf summary-only {
        tailf:info "Filter more specific routes from updates";
        type empty;
      }
      container route-policy {
        tailf:info "Policy to condition advertisement, suppression, and attributes";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
        }
      }
    }

    // router bgp * / address-family * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router bgp * / address-family * / redistribute connected
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute subscriber
      container subscriber {
        tailf:info "subscriber routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF router tag";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type empty;
        }
        leaf internal {
          tailf:info "Redistribute OSPF internal routes";
          when "../match";
          type empty;
        }
        leaf external {
          tailf:info "Redistribute OSPF external routes";
          when "../match";
          type empty;
        }
        leaf external-type {
          tailf:cli-drop-node-name;
          when "../external";
          type enumeration {
            enum "1" {
              tailf:info "Redistribute external type 1 routes";
            }
            enum "2" {
              tailf:info "Redistribute external type 2 routes";
            }
          }
        }
        leaf nssa-external {
          tailf:info "Redistribute OSPF NSSA external routes";
          when "../match";
          type empty;
        }
        leaf nssa-external-type {
          tailf:cli-drop-node-name;
          when "../nssa-external";
          type enumeration {
            enum "1" {
              tailf:info "Redistribute NSSA external type 1 routes";
            }
            enum "2" {
              tailf:info "Redistribute NSSA external type 2 routes";
            }
          }
        }
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute isis *
      list isis {
        tailf:info "ISO IS-IS";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;IS-IS instance name";
          }
        }
        leaf level {
          tailf:info "Redistribute routes from the specified ISIS levels";
          type enumeration {
            enum "1" {
              tailf:info "Redistribute ISIS level 1 routes";
            }
            enum "1-inter-area" {
              tailf:info "Redistribute ISIS level 1 inter-area routes";
            }
            enum "2" {
              tailf:info "Redistribute ISIS level 2 ISIS routes";
            }
          }
        }
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;EIGRP instance name";
          }
        }
        leaf match {
          tailf:info "EIGRP route type for redistribution";
          type empty;
        }
        leaf internal {
          tailf:info "Redistribute EIGRP internal routes";
          when "../match";
          type empty;
        }
        leaf external {
          tailf:info "Redistribute EIGRP external routes";
          when "../match";
          type empty;
        }
        uses router-af-redistribute-grouping;
      }
    }

    // router bgp * / address-family * / allocate-label
    container allocate-label {
      tailf:info "Allocate label for selected prefixes";
      choice allocate-label-choice {
        leaf all {
          tailf:info "Allocate labels for all prefixes";
          type empty;
        }
        leaf route-policy {
          tailf:info "Use a route policy to select prefixes for label allocation";
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
          type string {
            tailf:info "WORD;;Name of the policy";
          }
        }
      }
    }
  }

  // bgp-address-family-ipv4-grouping
  grouping bgp-address-family-ipv4-grouping {
    uses bgp-address-family-pre-grouping;

    // router bgp * / address-family * / network *
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key net;
      leaf net {
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;IPv4 network and mask or masklength";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        type empty;
      }
      leaf route-policy {
        tailf:info "Route-policy to modify the attributes";
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
    }

    uses bgp-address-family-post-grouping;
  }

  // bgp-address-family-ipv6-grouping
  grouping bgp-address-family-ipv6-grouping {
    uses bgp-address-family-pre-grouping;

    // router bgp * / address-family * / network *
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key net;
      leaf net {
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "X:X::X/length;;IPv6 network and mask or masklength";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        type empty;
      }
      leaf route-policy {
        tailf:info "Route-policy to modify the attributes";
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
    }

    uses bgp-address-family-post-grouping;
  }

  // bgp-address-family-grouping
  grouping bgp-address-family-grouping {

    container address-family {
      tailf:info "Enter Address Family command mode";

      // router bgp * / address-family ipv4
      container ipv4 {
        tailf:info "IPv4 Address Family";
        // router bgp * / address-family ipv4 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        // router bgp * / address-family ipv4 multicast
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        // router bgp * / address-family ipv4 labeled-unicast
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        // router bgp * / address-family ipv4 mdt
        container mdt {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        // router bgp * / address-family ipv4 rt-filter
        container rt-filter {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        // router bgp * / address-family ipv4 flowspec
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        // router bgp * / address-family ipv4 mvpn
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
      }

      // router bgp * / address-family ipv6
      container ipv6 {
        tailf:info "IPv6 Address Family";
        // router bgp * / address-family ipv6 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
        }
        // router bgp * / address-family ipv6 multicast
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
        }
        // router bgp * / address-family ipv6 mvpn
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
        }
      }

      // router bgp * / address-family vpnv4
      container vpnv4 {
        tailf:info "VPNv4 Address Family";
        // router bgp * / address-family vpnv4 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        // router bgp * / address-family vpnv4 multicast
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        // router bgp * / address-family vpnv4 flowspec
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
      }

      // router bgp * / address-family vpnv6
      container vpnv6 {
        tailf:info "VPNv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
        }
      }

      // router bgp * / address-family l2vpn
      container l2vpn {
        tailf:info "L2VPN Address Family";

        // router bgp * / address-family l2vpn vpls-vpws
        container vpls-vpws {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }

        // router bgp * / address-family l2vpn evpn
        container evpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }

        // router bgp * / address-family l2vpn mspw
        container mspw {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
      }

      // router bgp * / address-family link-state link-state
      container link-state {
        tailf:info "Link-state Address Family";
        container link-state {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-pre-grouping;
        }
      }
    }
  }


  // router bgp * / neighbor * / address-family * /
  // router bgp * / af-group * /
  grouping router-bgp-neighbor-af-grouping {

    // router bgp * / neighbor * / address-family * / multipath
    leaf multipath {
      tailf:info "Paths from this neighbor is eligible for multipath";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / neighbor * / address-family * / route-policy * in|out
    uses route-policy-list-grouping;

    // router bgp * / neighbor * / address-family * / remove-private-AS
    leaf encapsulation-type {
      tailf:info "Specify encapsulation type";
      tailf:cli-full-command;
      type enumeration {
        enum mpls {
          tailf:info "MPLS encapsulation";
        }
        enum vxlan {
          tailf:info "VxLAN encapsulation";
        }
      }
    }

    // router bgp * / neighbor * / address-family * / remove-private-AS
    container remove-private-AS {
      tailf:info "Remove private AS number from outbound updates";
      tailf:cli-delete-when-empty;
      presence true;
      // router bgp * / neighbor * / address-family * / remove-private-AS entire-aspath
      leaf entire-aspath {
        tailf:info "remove only if all ASes in the path are private";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / soft-reconfiguration inbound
    container soft-reconfiguration {
      tailf:info "Per neighbor soft reconfiguration";
      container inbound {
        tailf:info "Allow inbound soft reconfiguration for this neighbor";
        tailf:cli-compact-syntax;
        presence true;
        leaf "type" {
          tailf:cli-drop-node-name;
          type enumeration {
            enum always {
              tailf:info "Always use soft reconfig, even if route refresh "+
                "is supported";
            }
            enum inheritance-disable {
              tailf:info "Prevent soft-reconfiguration from being inherited "+
                "from the parent";
            }
          }
        }
      }
    }

    // router bgp * / address-family * / allowas-in
    container allowas-in {
      tailf:info "Allow as-path with my AS present in it";
      leaf as-occurrence-number {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-10>;;Number of occurences of AS number";
          range "1..10";
        }
      }
    }

    // router bgp * / neighbor * / address-family * / site-of-origin
    leaf site-of-origin {
      tailf:info "Site-of-Origin extended community associated with the neighbor";
      type string {
        tailf:info "WORD;;AS number or IPV4 address:index";
      }
    }

    // router bgp * / neighbor * / address-family * / import
    container "import" {
      tailf:info "Import options for neighbor address-family routes";
      choice import-choice {

        // router bgp * / neighbor * / address-family * / import stitching-rt
        container stitching-rt {
          tailf:info "Import routes using stitching RTs";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-delete-when-empty;
          presence true;
          choice re-originate-choice {
            leaf re-originate {
              tailf:info "Reoriginate imported routes";
              type empty;
            }
            // Note: Different version of ASR9k wherein the leaf does not have hyphen
            leaf reoriginate {
              tailf:info "Reoriginate imported routes, version 5.3.x";
              type empty;
            }
          }
          leaf stitching-rt {
            tailf:info "Reoriginate imported routes by attaching stitching RTs";
            type empty;
          }
        }

        // router bgp * / neighbor * / address-family * / import re-originate
        container re-originate {
          tailf:info "Re-originate imported routes";
          tailf:cli-delete-when-empty;
          presence true;
          leaf stitching-rt {
            tailf:info "Reoriginate imported routes by attaching stitching RTs";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * / address-family * / accept-own
    container accept-own {
      tailf:info "Handle self-originated routes with Accept-Own "+
        "community";
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent item being inherited from a parent group";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / as-override
    container as-override {
      tailf:info "Override matching AS-number while sending update";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent as-override from being inherited from the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / maximum-prefix
    container maximum-prefix {
      tailf:info "Maximum number of prefixes to accept from this peer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf max-prefix-limit {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;maximum no. of prefix limit";
          range "1..4294967295";
        }
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at "
            +"which to generate a warning msg";
          range "1..100";
        }
      }
      leaf restart {
        tailf:info "Restart time interval";
        type uint16 {
          tailf:info "<1-65535>;;Time interval (min) after which peering "+
            "session will be reestablished";
          range "1..65535";
        }
      }
      leaf warning-only {
        tailf:info "Only give warning message when limit is exceeded";
        tailf:cli-full-command;
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / next-hop-self
    container next-hop-self {
      tailf:info "Disable the next hop calculation for this neighbor";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent next-hop-self from being inherited from the "+
          "parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / next-hop-unchanged
    container next-hop-unchanged {
      tailf:info "Do not overwrite next hop before advertising to eBGP peers";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent next-hop-unchanged from being inherited from "+
          "the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / route-reflector-client
    leaf route-reflector-client {
      tailf:info "Configure a neighbor as Route Reflector client";
      type empty;
    }

    // router bgp * / neighbor * / address-family * / default-originate
    container default-originate {
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      // router bgp * / neighbor * / address-family * / default-originate route-policy
      leaf route-policy {
        tailf:info "Route policy to specify criteria to originate default";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
    }

    // router bgp * / neighbor * / address-family * / send-community-ebgp
    container send-community-ebgp {
      tailf:info "Send community attribute to this external neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent send-community-ebgp from being inherited "+
          "from the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / send-extended-community-ebgp
    container send-extended-community-ebgp {
      tailf:info "Send extended community attribute to this external neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent send-extended-community-ebgp from being "+
          "inherited from the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / use af-group
    container use {
      tailf:info "Inherit configuration from a group";
      leaf af-group {
        tailf:info "Inherit configuration for this address-family from an "+
          "af-group";
        tailf:cli-full-command;
        type string;
      }
    }

    // router bgp * / neighbor * / address-family * / capability
    container capability {
      tailf:info "Advertise capability to the peer";
      container orf {
        tailf:info "Advertise ORF capability to the peer";
        leaf "prefix" {
          tailf:info "Advertise address prefix ORF capability to this neighbor";
          type enumeration {
            enum both {
              tailf:info "Capability to RECEIVE and SEND the ORF from/to "+
                "this neighbor";
            }
            enum none {
              tailf:info "No capability to RECEIVE or SEND the ORF from/to "+
                "this neighbor";
            }
            enum receive {
              tailf:info "Capability to RECEIVE the ORF from this neighbor";
            }
            enum send {
              tailf:info "Capability to SEND the ORF to this neighbor";
            }
          }
        }
      }
    }

    // router bgp * / neighbor * / address-family * / Signalling
    container Signalling {
      tailf:info "Signalling protocols to disable, BGP or LDP";
      choice signalling-choice {
        container bgp {
          tailf:info "Select BGP to disable";
          leaf disable {
            tailf:info "Disable Signalling type";
            type empty;
          }
        }
        container ldp {
          tailf:info "Select LDP to disable";
          leaf disable {
            tailf:info "Disable Signalling type";
            type empty;
          }
        }
      }
    }
  }


  // router bgp * / neighbor *
  // router bgp * / neighbor-group *
  grouping bgp-neighbor-grouping {

    // router bgp * / neighbor * / remote-as
    leaf remote-as {
      tailf:info "Specify a BGP neighbor";
      type union {
        type uint32 {
          tailf:info "<1-4294967295>;;AS of remote neighbor";
          range "1..4294967295";
        }
        type string {
          tailf:info "<1.0-XX.YY>;;AS of remote neighbor";
          pattern '[0-9]+\.[0-9]+';
        }
      }
    }

    // router bgp * / neighbor * / local address
    container local {
      tailf:info "Configure local parameter";
      container address {
        tailf:info "use configured local address for bgp peering";
        leaf ip {
          tailf:cli-drop-node-name;
          type inet:host {
            tailf:info "A.B.C.D or X:X::X;;address";
          }
        }
      }
    }

    // router bgp * / neighbor * / local-as
    container local-as {
      tailf:info "Specify local AS number";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice local-as-choice {
        leaf inheritance-disable {
          tailf:info "Prevent local AS from being inherited from parent";
          type empty;
        }
        case as-number-case {
          leaf as-number {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
            }
          }
          leaf no-prepend {
            tailf:info "Do not prepend local AS to announcements from "+
              "this neighbor";
            type empty;
          }
          leaf replace-as {
            tailf:info "Prepend only local AS to announcements to this "+
              "neighbor";
            type empty;
          }
          leaf dual-as {
            tailf:info "Dual-AS mode";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * / bfd
    uses bfd-common-parameters-grouping;

    // router bgp * / neighbor * / ebgp-multihop
    container ebgp-multihop {
      tailf:info "Allow EBGP neighbors not on directly connected networks";
      tailf:cli-compact-syntax;
      leaf ttl-value {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;maximum hop count";
          range "1..255";
        }
      }
      leaf mpls {
        tailf:info "Disable BGP MPLS forwarding";
        type empty;
      }
    }

    // router bgp * / neighbor * / enforce-first-as
    container enforce-first-as {
      tailf:info "Enforce the first AS for EBGP routes";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Do not enforce the first AS for EBGP routes";
        type empty;
      }
    }

    // router bgp * / neighbor * / advertisement-interval
    container advertisement-interval {
      tailf:info "Minimum interval between sending BGP routing updates";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-600>;;time in seconds";
          range "0..600";
        }
      }
      leaf milliseconds {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-999>;;time in milliseconds";
          range "0..999";
        }
      }
    }

    // router bgp * / neighbor * / timers
    container timers {
      tailf:info "BGP per neighbor timers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf keepalive {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-65535>;;Keepalive interval";
        }
      }
      leaf holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0|3-65535>;;Holdtime (0=disable)";
        }
      }
      leaf min-holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<3-65535>;;Minimum acceptable holdtime from neighbor";
        }
      }
    }

    // router bgp * / neighbor * / description
    leaf "description" {
      tailf:info "Neighbor specific description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Up to 80 characters describing this neighbor";
      }
    }

    // router bgp * / neighbor * / password
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf enc-type {
        tailf:cli-drop-node-name;
        type enumeration {
          enum clear {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum encrypted {
            tailf:info "Specifies an ENCRYPTED password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The password";
        }
      }
    }

    // router bgp * / neighbor * / ttl-security
    container ttl-security {
      tailf:info "Enable EBGP TTL security";
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent ttl-security from being inherited from the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / update in filtering
    container update {
      tailf:info "BGP Update configuration";
      container in {
        tailf:info "Inbound update message handling";
        container filtering {
          tailf:info "Inbound update message filtering";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-vrf-nbr-upd-filter";

          // router bgp * / neighbor * / update in filtering / attribute-filter
          container attribute-filter {
            tailf:info "Attribute-filter configuration";
            leaf group {
              tailf:info "Attribute-filter group configuration";
              type string {
                tailf:info "WORD;;Attribute-filter group name";
              }
            }
          }
        }
      }
    }

    // router bgp * / neighbor * / update-source
    container update-source {
      tailf:info "Source of routing updates";
      uses interface-name-grouping;
    }

    // router bgp * / neighbor * /  ignore-connected-check
    container ignore-connected-check {
      tailf:info "Ignore check for directly connected peer";
      presence true;
    }

    // router bgp * / neighbor * / cluster-id
    leaf cluster-id {
      tailf:info "Enter cluster id for this neighbor";
      tailf:cli-full-command;
      type union {
        type uint32 {
          tailf:info "<1-4294967295>;;Route-Reflector Cluster-id as "+
            "32 bit quantity";
        }
        type inet:host {
          tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP address format";
        }
      }
    }

    // router bgp * / neighbor * / graceful-restart
    container graceful-restart {
      tailf:info "Enable graceful restart support for this neighbor";
      presence true;
      leaf suppress {
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
      leaf disable {
        tailf:info "Disable graceful restart support for this neighbor";
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
    }

    // router bgp * / neighbor * / capability suppress
    container capability {
      tailf:info "Advertise capability to the peer";
      container suppress {
        tailf:info "Suppress advertising capability to the peer ";
        container "four-byte-as" {
          tailf:alt-name "4-byte-as";
          tailf:info "4-byte-as capability";
          presence true;
          leaf inheritance-disable {
            tailf:info "Prevent capability suppress 4-type-as being "+
              "inherited from the parent";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * / address-family
    container address-family {
      tailf:info "Enter Address Family command mode";

      // router bgp * / neighbor * / address-family ipv4
      container ipv4 {
        tailf:info "IPv4 Address Family";

        // router bgp * / neighbor * / address-family ipv4 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv4 multicast
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv4 labeled-unicast
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv4 mdt
        container mdt {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv4 rt-filter
        container rt-filter {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv4 flowspec
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv4 mvpn
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }

      // router bgp * / neighbor * / address-family l2vpn
      container l2vpn {
        tailf:info "L2VPN Address Family";

        // router bgp * / neighbor * / address-family l2vpn vpls-vpws
        container vpls-vpws {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family l2vpn evpn
        container evpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / address-family l2vpn mspw
        container mspw {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }

      // router bgp * / neighbor * / address-family vpnv4
      container vpnv4 {
        tailf:info "VPNv4 Address Family";

        // router bgp * / neighbor * / address-family vpnv4 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }

      // router bgp * / neighbor * / address-family ipv6
      container ipv6 {
        tailf:info "IPv6 Address Family";

        // router bgp * / neighbor * / address-family ipv6 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv6 multicast
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv6 labeled-unicast
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv6 mvpn
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }

      // router bgp * / neighbor * / address-family vpnv6
      container vpnv6 {
        tailf:info "IPv6 Address Family";

        // router bgp * / neighbor * / address-family vpnv6 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }

      // router bgp * / neighbor * / address-family link-state link-state
      container link-state {
        tailf:info "Link-state Address Family";
        container link-state {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }
    }

    // router bgp * / neighbor * / keychain
    leaf keychain {
      tailf:info "Set keychain based authentication";
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:key/chain/name";
      }
      type string {
        tailf:info "WORD;;The Key Chain name";
      }
    }

    // router bgp * / neighbor * / peer-group
    container peer-group {
      tailf:info "Configure peer-group";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf group-name {
        // Note: only applicable to ipv4 neighbours
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;peer-group name";
        }
      }
    }

    // router bgp * / neighbor * / use
    container use {
      tailf:info "Inherit configuration from a group";

      // router bgp * / neighbor * / use af-group
      leaf af-group {
        tailf:info "Inherit configuration from an af-group";
        type string {
          tailf:info "WORD;;AF-group name";
        }
      }

      // router bgp * / neighbor * / use neighbor-group
      leaf neighbor-group {
        tailf:info "Inherit configuration from a neighbor-group";
        type string {
          tailf:info "WORD;;Neighbor-group name";
        }
      }

      // router bgp * / neighbor * / use session-group
      leaf session-group {
        tailf:info "Inherit address-family independent config "+
          "from a session-group";
        type string {
          tailf:info "WORD;;Session group name";
        }
      }
    }

    // router bgp * / neighbor * / shutdown
    container shutdown {
      tailf:info "Administratively shut down this neighbor";
      presence true;
    }
  }


  // grouping router-bgp-vrf-grouping
  grouping router-bgp-vrf-grouping {

    // router bgp / bfd
    container bfd {
      tailf:info "Configure BFD parameters";

      // router bgp / bfd multiplier
      leaf multiplier {
        tailf:info "Detect multiplier";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<2-16>;;Detect multiplier";
          range "2..16";
        }
      }

      // router bgp / bfd minimum-interval
      leaf minimum-interval {
        tailf:info "Hello interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<3-30000>;;hello interval in milli-seconds";
          range "3..30000";
        }
      }
    }

    // router bgp * / timers
    container timers {
      tailf:info "Adjust routing timers";
      // router bgp * / timers bgp
      container bgp {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf keepalive {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-65535>;;Keepalive interval";
            range "0..65535";
          }
        }
        leaf holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<3-65535>;;Holdtime (0 Disable keepalives/hold time)";
            range "0|3..65535";
          }
        }
        leaf min-neighbor-holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<3-65535>;;Minimum acceptable holdtime from neighbor (0"
              +"to disable)";
            range "0|3..65535";
          }
        }
      }
    }

    // router bgp / bgp
    container bgp {
      tailf:info "BGP specific commands";

      // router bgp / bgp router-id
      leaf router-id {
        tailf:info "Configure Router-id";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Manually configured router identifier";
        }
      }

      // router bgp / bgp confederation
      container confederation {
        tailf:info "AS confederation parameters";

        // router bgp / bgp confederation identifier
        leaf identifier {
          tailf:info "Set routing domain confederation AS";
          type string {
            tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
          }
        }
      }

      // router bgp / bgp cluster-id
      leaf cluster-id {
        tailf:info "Configure Route-Reflector Cluster-id";
        tailf:cli-full-command;
        type union {
          type uint32 {
            tailf:info "<1-4294967295>;;Route-Reflector Cluster-id as "+
              "32 bit quantity";
          }
          type inet:host {
            tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP address format";
          }
        }
      }

      // router bgp / bgp scan-time
      leaf scan-time {
        tailf:info "Configure background scanner interval for generic scanner";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<5-3600>;;Scanner interval (seconds)";
          range "5..3600";
        }
      }

      // router bgp / bgp update-delay
      container update-delay {
        tailf:info "Set the max initial delay for sending updates";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf update-delay-value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-3600>;;Delay value (seconds)";
            range "0..3600";
          }
        }
        leaf always {
          tailf:info "Keepalive trigger bestpath is disabled and delay "+
            "is enforced";
          type empty;
        }
      }

      // router bgp * / bgp redistribute-internal
      leaf redistribute-internal {
        tailf:info "Allow redistribution of iBGP into IGPs (dangerous)";
        type empty;
      }

      // router bgp / bgp graceful-restart
      container graceful-restart {
        tailf:info "Graceful restart capability parameters";
        presence true;
        tailf:cli-display-separated;

        // router bgp / bgp graceful-restart extended
        leaf extended {
          tailf:info "Enable Graceful-Restart Extension";
          type empty;
        }

        // router bgp / bgp graceful-restart restart-time
        leaf restart-time {
          tailf:info "Set the max time needed to restart and come back up";
          type uint16 {
            tailf:info "<1-4095>;;Max time (seconds)";
            range "1..4095";
          }
        }

        // router bgp / bgp graceful-restart stalepath-time
        leaf stalepath-time {
          tailf:info "Set the max time to hold onto "
            +"restarting peer's stale paths";
          type uint16 {
            tailf:info "<1-3600>;;Delay value (seconds)";
            range "1..3600";
          }
        }

        // router bgp / bgp graceful-restart purge-time
        leaf purge-time {
          tailf:info "Time before stale routes are purged.";
          type uint16 {
            tailf:info "<1-6000>;;Max time (seconds)";
            range "1..6000";
          }
        }

        // router bgp / bgp graceful-restart graceful-reset
        leaf graceful-reset {
          tailf:info "Reset gracefully if configuration change forces a peer reset";
          type empty;
        }
      }

      // router bgp / bgp bestpath
      container bestpath {
        tailf:info "Change default route selection criteria";

        // router bgp / bgp bestpath compare-routerid
        leaf compare-routerid {
          tailf:info "Compare router-id for identical EBGP paths";
          tailf:cli-full-command;
          type empty;
        }

        // router bgp / bgp bestpath cost-community ignore
        container cost-community {
          tailf:info "Cost community";
          leaf ignore {
            tailf:info "Ignore cost-community comparison";
            type empty;
          }
        }

        // router bgp / bgp bestpath med
        container med {
          tailf:info "MED related";

          // router bgp / bgp bestpath med always
          leaf always {
            tailf:info "Allow comparing MED from different neighbors";
            tailf:cli-full-command;
            type empty;
          }

          // router bgp / bgp bestpath med confed
          leaf confed {
            tailf:info "Compare MED among confederation paths";
            tailf:cli-full-command;
            type empty;
          }

          // router bgp / bgp bestpath med missing-as-worst
          leaf missing-as-worst {
            tailf:info "Treat missing MED as the least preferred one";
            tailf:cli-full-command;
            type empty;
          }
        }

        // router bgp / bgp bestpath as-path ignore
        container as-path {
          tailf:info "AS path length";
          leaf ignore {
            tailf:info "Ignore as-path length";
            type empty;
          }
        }
      }

      // router bgp / bgp log
      container log {
        tailf:info "Log bgp info";
        container neighbor {
          tailf:info "Log neighbor state info";
          leaf changes {
            tailf:info "Log neighbor up/down and reset reason";
            type enumeration {
              enum detail {
                tailf:info "Include extra detail in change messages";
              }
              enum disable {
                tailf:info "Disable logging";
              }
            }
          }
        }
      }

      // router bgp / bgp default
      container "default" {
        tailf:info "Configure default value";
        leaf local-preference {
          tailf:info "Local preference";
          type uint32 {
            tailf:info "<0-4294967295>;;Higher = more preferred";
          }
        }
      }

      // router bgp / bgp auto-policy-soft-reset disable
      container auto-policy-soft-reset {
        tailf:info "Enable automatic soft peer reset on policy reconfiguration";
        leaf disable {
          tailf:info "Disable automatic soft peer reset on policy reconfiguration";
          type empty;
        }
      }

      // router bgp / bgp label-delay
      container label-delay {
        tailf:info "Specify delay for batching label processing";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-10>;;Delay, seconds part";
            range "0..10";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Delay, milliseconds part";
            range "0..999";
          }
        }
      }

      // router bgp / bgp import-delay
      container import-delay {
        tailf:info "Specify delay for import processing";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-10>;;Delay, seconds part";
            range "0..10";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Delay, milliseconds part";
            range "0..999";
          }
        }
      }

      // router bgp / bgp fast-external-fallover disable
      container fast-external-fallover {
        tailf:info "Immediately reset session if a link to a directly connected external peer goes down";
        leaf disable {
          tailf:info "Disable";
          type empty;
        }
      }
    }

    // router bgp / default-information originate
    container default-information {
      tailf:info "Control distribution of default information";
      leaf originate {
        tailf:info "Distribute a default route";
        type empty;
      }
    }

    // router bgp / mpls activate
    container mpls {
      tailf:info "Enable mpls parameters";
      container activate {
        tailf:info "Enter mpls interfaces in BGP mpls activate mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-bgp-mpls";

        // router bgp / mpls activate / interface *
        list interface {
          tailf:info "Interface to enable mpls";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
        }
      }
    }

    // router bgp * / update
    container update {
      tailf:info "BGP Update configuration";
      leaf limit {
        tailf:info "Upper bound on transient memory usage for update "+
          "generation";
        type uint16 {
          tailf:info "<16-2048>;;Update limit in MegaBytes(MB); "+
            "default is 512 MB";
          range "16..2048";
        }
      }
    }

    // router bgp * / ibgp policy out enforce-modifications
    container ibgp {
      tailf:info "Set options for iBGP peers";
      container policy {
        tailf:info "Set options for route-policy";
        container out {
          tailf:info "Set options for outbound policy";
          leaf enforce-modifications {
            tailf:info "Allow policy to modify all attributes";
            type empty;
          }
        }
      }
    }

    // router bgp * / address-family
    uses bgp-address-family-grouping;

    // router bgp * / af-group *
    list af-group {
      tailf:info "Specify a AF group";
      tailf:cli-mode-name "config-bgp-afgrp";
      key "name address-family af-modifier";
      leaf name {
        type string {
          tailf:info "WORD;;AF group name";
        }
      }
      leaf address-family {
        tailf:info "Enter Address Family command mode";
        tailf:cli-expose-key-name;
        type enumeration {
          enum ipv4 {
            tailf:info "IPv4 Address Family";
          }
          enum ipv6 {
            tailf:info "IPv6 Address Family";
          }
          enum l2vpn {
            tailf:info "L2VPN Address Family";
          }
          enum vpnv4 {
            tailf:info "VPNv4 Address Family";
          }
          enum vpnv6 {
            tailf:info "VPNv6 Address Family";
          }
        }
      }
      leaf af-modifier {
        type enumeration {
          enum labeled-unicast {
            tailf:info "Address Family modifier";
          }
          enum mdt {
            tailf:info "Address Family modifier";
          }
          enum multicast {
            tailf:info "Address Family modifier";
          }
          enum mvpn {
            tailf:info "Address Family modifier";
          }
          enum rt-filter {
            tailf:info "Address Family modifier";
          }
          enum tunnel {
            tailf:info "Address Family modifier";
          }
          enum unicast {
            tailf:info "Address Family modifier";
          }
          enum vpls-vpws {
            tailf:info "Address Family modifier";
          }
        }
      }

      // router bgp * / af-group * /
      uses router-bgp-neighbor-af-grouping;
    }

    // router bgp * / neighbor-group *
    list neighbor-group {
      tailf:info "Specify a Neighbor-group";
      tailf:cli-mode-name "config-bgp-nbrgrp";
      key name;
      leaf name {
        tailf:info "Neighbor-group name";
        type string {
          tailf:info "WORD;;Neighbor-group name";
        }
      }
      uses bgp-neighbor-grouping;
    }

    // router bgp * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-mode-name "config-bgp-nbr";
      key id;
      leaf id {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor address";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Neighbor IPv6 address";
          }
        }
      }
      leaf activate {
        tailf:cli-hide-in-submode;
        type empty;
      }
      uses bgp-neighbor-grouping;
    }

    // router bgp * / socket
    container socket {
      tailf:info "set socket parameters";
      container receive-buffer-size {
        tailf:info "socket receive buffer size";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf socket-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<512-131072>;;Receive socket buffer size in bytes";
            range "512..131072";
          }
        }
        leaf bgp-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "BGP Read buffer size in bytes";
            range "512..131072";
          }
        }
      }
      container send-buffer-size {
        tailf:info "socket send buffer size";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf socket-size {
          tailf:cli-drop-node-name;
          type uint32 {
            range "512..131072";
          }
        }
        leaf bgp-size {
          tailf:cli-drop-node-name;
          type uint32 {
            range "512..131072";
          }
        }
      }
    }

  }

  // grouping router-bgp-grouping
  grouping router-bgp-grouping {

    // router bgp * / nsr
    container nsr {
      tailf:info "Enable non-stop-routing support for all neighbors";
      tailf:cli-delete-when-empty;
      presence true;
      // router bgp * / nsr disable
      leaf disable {
        tailf:info "Disable non-stop-routing support for all neighbors";
        type empty;
      }
    }

    uses router-bgp-vrf-grouping;

    // router bgp * / session-group *
    list session-group {
      tailf:info "Specify a Session group";
      tailf:cli-mode-name "config-bgp-sngrp";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Session group name";
        }
      }

      // router bgp * / session-group * / remote-as
      leaf remote-as {
        tailf:info "Set remote AS";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
        }
      }

      // router bgp * / session-group * / use
      container use {
        tailf:info "Inherit configuration from a group";
        leaf session-group {
          tailf:info "Inherit address-family independent config from a session-group";
          type string {
            tailf:info "WORD;;Session group name";
          }
        }
      }

      // router bgp * / session-group * / ebgp-multihop
      container ebgp-multihop {
        tailf:info "Allow EBGP neighbors not on directly connected networks";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf ttl-value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;maximum hop count";
          }
        }
        leaf mpls {
          tailf:info "Disable BGP MPLS forwarding";
          type empty;
        }
      }

      // router bgp * / session-group * / advertisement-interval
      container advertisement-interval {
        tailf:info "Minimum interval between sending BGP routing updates";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-600>;;time in seconds";
            range "0..600";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;time in milliseconds";
            range "0..999";
          }
        }
      }

      // router bgp * / session-group / local-as
      container local-as {
        tailf:info "Specify a local-as number";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice local-as-choice {
          case a {
            leaf inheritance-disable {
              tailf:info "Prevent local AS from being inherited from parent";
              type empty;
            }
          }
          case b {
            leaf as-number {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
              }
            }
            leaf no-prepend {
              tailf:info "Do not prepend local AS to announcements from this neighbor";
              type empty;
            }
            leaf replace-as {
              tailf:info "Prepend only local AS to announcements to this neighbor";
              type empty;
            }
            leaf dual-as {
              tailf:info "Dual-AS mode";
              type empty;
            }
          }
        }
      }

      // router bgp * / session-group * / password
      container password {
        tailf:info "Set a password";
        choice password-choice {
          leaf clear {
            tailf:info "Specifies an unencrypted password will follow";
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) neighbor password";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an encrypted password will follow";
            type string {
              tailf:info "WORD;;The ENCRYPTED neighbor password string";
            }
          }
          leaf inheritance-disable {
            tailf:info "Prevent password from being inherited from parent";
            type empty;
          }
        }
      }

      // router bgp * / session-group * / shutdown
      leaf shutdown {
        tailf:info "Administratively shut down this neighbor";
        type empty;
      }

      // router bgp * / session-group * / description
      leaf "description" {
        tailf:info "Neighbor specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this neighbor";
        }
      }

      // router bgp * / session-group * / update-source
      container update-source {
        tailf:info "Source of routing updates";
        uses interface-name-grouping;
      }

      // router bgp * / session-group * / session-open-mode
      leaf session-open-mode {
        tailf:info "Establish BGP session using this TCP open mode";
        type enumeration {
          enum active-only {
            tailf:info "Active only";
          }
          enum both {
            tailf:info "Prevent session-open-mode being inherited "+
              "from the parent";
          }
          enum passive-only {
            tailf:info "Passive only";
          }
        }
      }

      // router bgp * / session-group * / send-buffer-size
      leaf send-buffer-size {
        tailf:info "Set socket and BGP send buffer size";
        type uint32 {
          tailf:info "<4096-131072>;;Send socket buffer size in bytes";
        }
      }

      // router bgp * / session-group * / receive-buffer-size
      leaf receive-buffer-size {
        tailf:info "Set socket and BGP receive buffer size";
        type uint32 {
          tailf:info "<512-131072>;;Receive socket buffer size in bytes";
        }
      }

      uses bfd-common-parameters-grouping;
    }

    // router bgp * / vrf *
    list vrf {
      tailf:info "Specify a vrf name";
      tailf:cli-mode-name "config-bgp-vrf";
      key name;
      leaf name {
        tailf:info "VRF name";
        type string {
          tailf:info "WORD;;VRF name - maximum length 32 characters";
        }
      }

      // router bgp * / vrf * / rd
      leaf rd {
        tailf:info "route distinguisher";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;AS-number, IPv4 address:index or 'auto'";
        }
      }

      // router bgp * / vrf * / label-allocation-mode
      // NOTE: Warning, deprecated and may be a marco to below, i.e. will cause a diff
      leaf label-allocation-mode {
        tailf:info "Set MPLS/VPN label allocation mode";
        tailf:cli-full-command;
        type enumeration {
          enum  per-ce {
            tailf:info "Set per CE label mode";
          }
          enum per-vrf {
            tailf:info "Set per VRF label mode";
          }
        }
      }

      // router bgp * / vrf * / label
      container label {
        leaf mode {
          tailf:info "Select label mode";
          type enumeration  {
            enum per-ce  {
              tailf:info "Set per CE label mode";
            }
            enum per-vrf {
              tailf:info "Set per VRF label mode";
            }
          }
        }
      }

      // router bgp * / vrf * / XXX
      uses router-bgp-vrf-grouping;
    }
  }

  // policy-map * / class * / set
  // policy-map * / class * / police * / conform-action set
  // policy-map * / class * / police * / exceed-action set
  // policy-map * / class * / police * / violate-action set
  grouping police-set-grouping {

    // policy-map * / class * / set atm-clp
    leaf atm-clp {
      tailf:info "Set atm cell-loss-priority bit";
      tailf:cli-full-command;
      type empty;
    }

    // policy-map * / class * / set cos
    container cos {
      tailf:info "Set Class Of Service values";
      leaf cos-value {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
      leaf inner {
        tailf:info "COS inner value";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
    }

    // policy-map * / class * / set dei
    leaf dei {
      tailf:info "Set DEI";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-1>;;DEI value";
        range "0..1";
      }
    }

    // policy-map * / class * / set discard-class
    leaf discard-class {
      tailf:info "Set discard-class";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-63>;;Discard Class value";
        range "0..63";
      }
    }

    // policy-map * / class * / set dscp
    container dscp {
      tailf:info "Set IP DSCP (DiffServ CodePoint)";
      leaf outer {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type dscp-type;
      }
      leaf tunnel {
        tailf:info "Set DSCP Tunnel(for ipsec tunnels)";
        tailf:cli-full-command;
        type dscp-type;
      }
    }

    // policy-map * / class * / set fr-de
    leaf fr-de {
      tailf:info "Set FR DE value";
      tailf:cli-full-command;
      type enumeration {
        enum "1" {
          tailf:info "<1-1>;;FR DE value";
        }
      }
    }

    // policy-map * / class * / set mpls
    container mpls {
      tailf:info "Set MPLS specific values";
      container experimental {
        tailf:info "Set Experimental value";
        leaf imposition {
          tailf:info "Set Experimental value at tag imposition";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-7>;;Experimental value";
            range "0..7";
          }
        }
        leaf topmost {
          tailf:info "Set Experimental value on topmost label";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-7>;;Experimental value";
            range "0..7";
          }
        }
      }
    }

    // policy-map * / class * / set precedence
    container precedence {
      tailf:info "Set IP Precedence";
      leaf outer {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type precedence-type;
      }
      leaf tunnel {
        tailf:info "Set Precedence tunnel (for ipsec tunnels)";
        tailf:cli-full-command;
        type precedence-type;
      }
    }

    // policy-map * / class * / set qos-group
    leaf qos-group {
      tailf:info "Set qos-group";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-63>;;QoS group value";
        range "0..63";
      }
    }

    // policy-map * / class * / set forward-class
    leaf forward-class {
      tailf:info "Set forward class";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-7>;;Forward class value";
        range "1..7";
      }
    }

    // policy-map * / class * / set srp-priority
    leaf srp-priority {
      tailf:info "Set SRP priority";
      type uint8 {
        tailf:info "<0-7>;;SRP priority value";
        range "0..7";
      }
    }
  }


  // policy-map * / class * / police * /
  grouping police-action-grouping {

    // policy-map * / class * / police * / child-conform-aware
    leaf child-conform-aware {
      tailf:cli-break-sequence-commands;
      tailf:info "Enable coupled policing";
      type empty;
    }

    // policy-map * / class * / police * / conform-action
    container conform-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }

    // policy-map * / class * / police * / exceed-action
    container exceed-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }

    // policy-map * / class * / police * / violate-action
    container violate-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
  }

  // policy-map-class-grouping
  grouping policy-map-class-grouping {

    // policy-map * / class type traffic *
    leaf "type" {
      tailf:info "The type of classmap";
      tailf:cli-prefix-key;
      type enumeration {
        enum traffic {
          tailf:info "Traffic classmap";
        }
      }
    }

    // policy-map * / class * / drop
    leaf drop {
      tailf:info "Drop the packet";
      type empty;
    }

    // policy-map * / class * / transmit
    leaf transmit {
      tailf:info "Transmit the packet";
      type empty;
    }

    // policy-map * / class * / redirect
    container redirect {
      tailf:info "Configure PBF redirect feature";

      // policy-map * / class * / redirect nexthop
      container nexthop {
        tailf:info "Forward to specified nexthop";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf vrf {
          tailf:info "Enter specific VRF Name for this nexthop";
          tailf:cli-optional-in-sequence;
          //tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
          type vrf-type;
        }
        choice nexthop-choice {
          leaf IPv4-address  {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Input IPv4 Nexthop address";
            }
          }
          leaf IPv6-address {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "X:X::X%zone;;Input IPv6 Nexthop address";
            }
          }
          leaf route-target {
            tailf:info "Enter specific route-target string";
            type string {
              tailf:info "WORD;;IPAddress:index or 2-byte ASN or 4-byte ASN";
            }
          }
        }
      }
    }

    // policy-map * / class * / http-redirect
    leaf http-redirect {
      tailf:info "Configure HTTP redirect";
      type string {
        tailf:info "WORD;;Specify the URL HTTP requests should be redirected to";
      }
    }

    // policy-map * / class * / shape
    container shape {
      tailf:info "Configure shaping for this class";
      // policy-map * / class * / shape average
      container average {
        tailf:info "Average rate shaping";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice average-choice {
          case percent-case {
            leaf percent {
              tailf:info "Configure shape rate in percentage";
              type uint8 {
                tailf:info "<1-100>;;Shape rate as percentage of "+
                  "available bandwidth";
                range "1..100";
              }
            }
          }
          case unit-case {
            leaf rate {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-4294967295>;;Shape rate";
                range "1..4294967295";
              }
            }
            leaf rate-unit {
              tailf:cli-drop-node-name;
              type enumeration {
                enum bps {
                  tailf:info "Bits per second (default)";
                }
                enum cellsps {
                  tailf:info "Cells per second";
                }
                enum gbps {
                  tailf:info "Gigabits per second";
                }
                enum kbps {
                  tailf:info "Kilobits per second";
                }
                enum mbps {
                  tailf:info "Megabits per second";
                }
              }
            }
          }
        }
        leaf burst {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Excess burst size";
            range "1..4294967295";
          }
        }
        leaf burst-unit {
          tailf:cli-drop-node-name;
          type union {
            type police-burst-units-type;
            type enumeration {
              enum cells {
                tailf:info "Cells";
              }
            }
          }
        }
      }
    }

    // policy-map * / class * / bandwidth
    container bandwidth {
      tailf:info "Configure bandwidth for this class";
      container bandwidth-units {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf rate {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Bandwidth value";
          }
        }
        leaf "units" {
          tailf:cli-drop-node-name;
          type police-rate-units-type;
        }
      }
      leaf percent {
        tailf:info "configure a percentage bandwidth";
        type percentage-type;
      }
      container remaining {
        tailf:info "Allocate left over bandwidth";
        leaf percent {
          tailf:info "Allocate remaining bandwidth as percentage";
          type percentage-type;
        }
        leaf ratio {
          tailf:info "Allocate remaining bandwidth as a ratio";
          type uint16 {
            tailf:info "<1-1020>;;Bandwidth ratio";
            range "1..1020";
          }
        }
      }
    }

    // policy-map * / class * / police ?
    choice police-choice {

      // policy-map * / class * / police rate
      case police-rate-unit-case {
        container police-rate-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container rate {
              tailf:info "Committed Information Rate";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pmap-c-police";
              tailf:cli-flatten-container;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              // { <value> [<units>] | percent <percentage> }
              choice rate-choice {
                case units-case {
                  leaf cir {
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    tailf:cli-incomplete-command;
                    type uint64 {
                      tailf:info "<1-4294967295>;;Committed Information Rate";
                    }
                  }
                  leaf cir-unit {
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    type police-rate-units-type;
                  }
                }
                case percent-case {
                  leaf percent {
                    tailf:info "Percent of the link bandwidth";
                    tailf:cli-hide-in-submode;
                    type uint8 {
                      tailf:info "<1-100>;;Committed Information Rate in "+
                        "percentage of link bandwidth";
                      range "1..100";
                    }
                  }
                }
              }
              // [ burst burst-size [burst-units] ]
              leaf burst {
                tailf:info "Burst size (BC)";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint32 {
                  tailf:info "<1-4294967295>;;Burst size (BC)";
                  range "1..4294967295";
                }
              }
              leaf burst-units {
                when "../burst";
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-units-type;
              }
              // [ peak-rate { value [units] | percent percentage } ]
              leaf peak-rate {
                tailf:info "Peak Information Rate";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint64 {
                  tailf:info "WORD;;Peak-rate value in range "
                    +"1-10,000,000,000";
                  range "1..10000000000";
                }
              }
              leaf peak-rate-units {
                when "../peak-rate";
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-rate-units-type;
              }
              container peak-rate-percent {
                when "not(../peak-rate)" {
                  tailf:dependency "../peak-rate";
                }
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                tailf:cli-flatten-container;
                container peak-rate {
                  tailf:cli-flatten-container;
                  leaf percent {
                    tailf:info "Percent of the link bandwidth";
                    type percentage-type;
                  }
                }
              }
              // [ peak-burst peak-burst [burst-units] ]
              leaf peak-burst {
                tailf:info "Excess Burst size (BE)";
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<1-4294967295>;;Excess burst size (BE)";
                }
              }
              leaf peak-burst-units {
                when "../peak-burst";
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-units-type;
              }
              // conform-action | exceed-action | violate-action
              uses police-action-grouping;
            }
          }
        }
      }

      // policy-map * / class * / police <unit>
      case police-unit-case {
        container police-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            // To cover also the syntax where cir, bc and be
            // doesn't have to be explicitly specified
            tailf:info "Police traffic";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pmap-c-police";
            tailf:cli-flatten-container;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf cir {
              tailf:info "Committed information rate";
              tailf:cli-hide-in-submode;
              type uint32 {
                range "8000..2000000000";
                tailf:info "<8000-2000000000>;;Bits per second";
              }
            }
            leaf bc {
              tailf:info "Conform burst";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type uint32 {
                range "1000..512000000";
                tailf:info "<1000-512000000>;;Burst bytes";
              }
            }
            leaf be {
              tailf:info "Excess burst";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type uint32 {
                range "1000..512000000";
                tailf:info "<1000-512000000>;;Burst bytes";
              }
            }
            // conform-action | exceed-action | violate-action
            uses police-action-grouping;
          }
        }
      }
    }

    // policy-map * / class * / set
    container set {
      tailf:info "Configure marking for this class";
      uses police-set-grouping;
    }

    // policy-map * / class * / priority
    container priority {
      tailf:info "Assign priority to this class";
      leaf level {
        tailf:info "Configure a priority level";
        type uint8 {
          tailf:info "<1-3>;;Priority level";
          range "1..3";
        }
      }
    }

    // policy-map * / class * / queue-limit
    container queue-limit {
      tailf:info "Configure queue-limit (taildrop threshold) for this class";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf queue-limit-value {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;Max Threshold for tail drop";
          range "1..4294967295";
        }
      }
      leaf queue-limit-unit {
        tailf:cli-drop-node-name;
        type enumeration {
          enum bytes {
            tailf:info "Bytes";
          }
          enum kbytes {
            tailf:info "Kilobytes";
          }
          enum mbytes {
            tailf:info "Megabytes";
          }
          enum ms {
            tailf:info "Milliseconds";
          }
          enum packets {
            tailf:info "Packets (default)";
          }
          enum us {
            tailf:info "Microseconds";
          }
        }
      }
    }

    // policy-map * / class * / service-function-path
    container service-function-path {
      tailf:info "Configure NSH service function action";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf id {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-16777215>;;Service function path id";
          range "1..16777215";
        }
      }
      leaf index {
        tailf:info "Specify service path index";
        type uint8 {
          tailf:info "<1-255>;;Service function path index";
          range "1..255";
        }
      }
      leaf metadata {
        tailf:info "service-function metadata";
        type string {
          tailf:info "WORD;;Specify metadata name";
        }
      }
    }

    // policy-map * / class * / service-policy
    container service-policy {
      tailf:info "Configure a child service policy";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf "type" {
        tailf:info "The type of policymap";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum accounting {
            tailf:info "Accounting policymap";
          }
          enum control {
            tailf:info "Control policy-map";
          }
          enum none {
            tailf:info "Untyped policymap";
          }
          enum pbr {
            tailf:info "PBR policymap";
          }
          enum performance-traffic {
            tailf:info "Realtime Application Flow Monitoring policymap";
          }
          enum qos {
            tailf:info "QoS policymap (default)";
          }
          enum redirect {
            tailf:info "Redirect policymap";
          }
          enum traffic {
            tailf:info "Traffic policy-map";
          }
        }
      }
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Name of the child service policy";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:policy-map/name";
        }
      }
    }

    // policy-map * / class * / random-detect
    container random-detect {
      tailf:info "Enable Random Early Detection";

      // policy-map * / class * / random-detect default
      leaf "default" {
        tailf:info "Enable RED with default min and max thresholds";
        tailf:cli-full-command;
        type empty;
      }



      // policy-map * / class * / random-detect cos
      list cos {
        tailf:info "COS based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-7>;;COS value";
          }
        }
        uses class-random-detect-grouping;
      }

       // policy-map * / class * / random-detect dei
      list dei {
        tailf:info "DEI based WRED";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-1>;;DEI value";
          }
        }
        uses class-random-detect-grouping;
      }

      // policy-map * / class * / random-detect dscp
      list dscp {
        tailf:info "DSCP based WRED (upto 8 values or ranges)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-63>;;Differentiated services codepoint value\n"+
              "af11,af12,af13,af21,af22,af23,af31,af32,af33,af41,af42,af43\n"+
              "cs1-cs7,default,ef and ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }

      // policy-map * / class * / random-detect exp
      list exp {
        tailf:info "MPLS Experimental value based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-7>;;MPLS Experimental value"+
              "and ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }

      // policy-map * / class * / random-detect precedence
      list precedence {
        tailf:info "Precedence based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-7>;;Precedence value\n"+
              "critical,flash,flash-override,immediate,\n"+
              "internet,network,priority,routine and ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }

      // policy-map * / class * / random-detect discard-class *
      list discard-class {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type uint8 {
            tailf:info "<0-7>;;Discard Class  value";
            range "0..7";
          }
        }
        uses class-random-detect-grouping;
      }

      // policy-map * / class * / random-detect ?
      container default-values {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        uses class-random-detect-grouping;
      }
    }
  }

  // performance-mgmt-grouping
  grouping performance-mgmt-grouping {

    choice case-choice {
      container AverageCpuUsed {
        tailf:info "Average %CPU utilization";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        uses average-cpu-used-grouping;
      }
      container AverageCPUUsed {
        tailf:info "Average %CPU utilization";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        uses average-cpu-used-grouping;
      }
    }

    leaf sample-size {
      tailf:info "Number of samples to be taken";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-60>;;Number of samples";
        range "1..60";
      }
    }

    leaf sample-interval {
      tailf:info "Frequency of sampling in minutes";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-60>;;Frequency of samples";
        range "1..60";
      }
    }
  }


  // ipv4
  // ipv6
  grouping ipv4-ipv6-common-grouping {

    // ipv4 conflict-policy
    // ipv6 conflict-policy
    leaf conflict-policy {
      tailf:info "ip address conflict algorithm selection";
      tailf:cli-full-command;
      type enumeration {
        enum highest-ip {
          tailf:info "Keeps the highest ip address in the conflict set UP";
        }
        enum longest-prefix {
          tailf:info "Keeps the longest prefix match in the conflict set UP";
        }
        enum static {
          tailf:info "Keeps the existing interface UP across new address "+
            "configs";
        }
      }
    }

    // ipv4 prefix-list *
    // ipv6 prefix-list *
    list prefix-list {
      tailf:info "Prefix-list command";
      tailf:cli-mode-name "config-ipv_pfx";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of a prefix list - maximum 32 characters";
          length "1..32";
        }
      }

      // ipv4 prefix-list * / *
      // ipv6 prefix-list * / *
      list rule {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-2147483646>;;Sequence number";
          }
        }
        leaf line {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "deny;;Specify packets to reject\n"+
              "permit;;Specify packets to forward\n"+
              "remark;;Comment for access list";
            pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
          }
        }
      }
    }
  }

  // arp-grouping
  grouping arp-grouping {
    list arp-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key address;
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP Address";
        }
      }
      leaf mac {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "H.H.H;;MAC address";
          pattern '[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+';
        }
      }
      leaf "type" {
        tailf:cli-drop-node-name;
        type enumeration {
          enum ARPA {
            tailf:info "Encapsulation type ARPA";
          }
          enum SRP {
            tailf:info "Encapsulation type SRP";
          }
          enum SRPA {
            tailf:info "Encapsulation type SRPA";
          }
          enum SRPB {
            tailf:info "Encapsulation type SRPB";
          }
        }
      }
      leaf alias {
        tailf:info "Configure an Alias ARP entry";
        type empty;
      }
    }
  }


  // tftp-server-grouping
  grouping tftp-server-grouping {
    list tftp-server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key af;
      leaf af {
        type enumeration {
          enum ipv4 {
            tailf:info "Global ipv4 specific TFTP server commands";
          }
          enum ipv6 {
            tailf:info "Global ipv6 specific TFTP server commands";
          }
        }
      }
      leaf server {
        tailf:info "TFTP server configuration commands";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf homedir {
        tailf:info "Home directory for TFTP server";
        type string {
          tailf:info "WORD;;Name of home directory (e.g. disk0:)";
        }
      }
      leaf max-servers {
        tailf:cli-break-sequence-commands;
        tailf:info "Set maximum number of concurrent tftp servers";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;Set number of allowable tftp "+
              "server processes";
            range "1..2147483647";
          }
          type enumeration {
            enum no-limit {
              tailf:info "No limit to number of allowable tftp server "+
                "processes";
            }
          }
        }
      }
      leaf access-list {
        tailf:info "Access list for TFTP server";
        type string {
          tailf:info "WORD;;Name of access list";
        }
      }
    }
  }


  // telnet-server-grouping
  grouping telnet-server-grouping {
    list telnet-server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      key af;
      leaf af {
        type enumeration {
          enum ipv4 {
            tailf:info "IPv4 configuration";
          }
          enum ipv6 {
            tailf:info "IPv6 configuration";
          }
        }
      }
      leaf dscp {
        tailf:info "dscp";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;dscp value";
        }
      }
      container server {
        tailf:info "Telnet server configuration commands";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf max-servers {
          tailf:info "Set number of allowable telnet sessions";
          type uint8 {
            tailf:info "<1-100>;;Set number of allowable telnet sessions";
            range "1..100";
          }
        }
        leaf access-list {
          tailf:info "Access list for telnet server";
          type string {
            tailf:info "WORD;;Name of access list";
          }
        }
      }
    }
  }


  // ntp server *
  grouping ntp-server-grouping {
    list server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        tailf:cli-disallow-value "vrf";
        type inet:host {
          tailf:info "Hostname or A.B.C.D or X:X::X;;Peer/server address";
        }
      }
      leaf ip-version {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum ipv4 {
            tailf:info "Specify IPv4 address or hostname";
          }
          enum ipv6 {
            tailf:info "Specify IPv6 address or host name";
          }
        }
      }

      // ntp server * version
      leaf version {
        tailf:info "Configure NTP version";
        type uint8 {
          tailf:info "<1-4>;;NTP version number";
          range "1..4";
        }
      }

      // ntp server * minpoll
      leaf minpoll {
        tailf:info "Configure minimum polling rate";
        type uint8 {
          tailf:info "<4-17>;;Minimum poll rate, default 6, less than "+
            "maxpoll";
          range "4..17";
        }
      }

      // ntp server * maxpoll
      leaf maxpoll {
        tailf:info "Configure maximum polling rate";
        type uint8 {
          tailf:info "<4-17>;;Maximum poll rate, default 10, greater than "+
            "minpoll";
          range "4..17";
        }
      }

      // ntp server * prefer
      leaf prefer {
        tailf:info "Prefer this peer when possible";
        type empty;
      }

      // ntp server * burst
      leaf burst {
        tailf:info "Use burst mode";
        type empty;
      }

      // ntp server * iburst
      leaf iburst {
        tailf:info "Use initial burst mode";
        type empty;
      }

      // ntp server * source
      container source {
        tailf:info "Interface for source address";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }

      // ntp server * key
      leaf "key" {
        tailf:info "Configure peer authentication key";
        type uint16 {
          tailf:info "<1-65535>;;Peer key number";
          range "1..65535";
        }
      }
    }
  }


  // router static / address-family ipv4 unicast
  // router static / address-family ipv6 unicast
  grouping router-static-options-grouping {

    // router static / address-family ipv4 unicast / * bfd fast-detect
    leaf bfd {
      tailf:info "Configure BFD paramenters";
      type enumeration {
        enum fast-detect {
          tailf:info "Enable Fast detection";
        }
      }
    }

    // router static / address-family ipv4 unicast / * minimum-interval
    leaf minimum-interval {
      when "../bfd";
      tailf:info "Hello interval";
      type uint16 {
        tailf:info "<3-30000>;;interval in milli-seconds";
        range "3..30000";
      }
    }

    // router static / address-family ipv4 unicast / * multiplier
    leaf multiplier {
      when "../bfd";
      tailf:info "Detect multiplier";
      type uint8 {
        tailf:info "<1-10>;;Detect multiplier";
        range "1..10";
      }
    }

    // router static / address-family ipv4 unicast / * <metric>
    choice metric-choice {
      leaf metric {
        tailf:info "Distance metric for this route";
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-254>;;Distance metric for this route";
          range "1..254";
        }
      }
      // router static / address-family ipv4 unicast / * metric
      container metric2 {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf metric {
          tailf:info "Set metric for this route";
          type uint32 {
            tailf:info "<1-16777214>;;Set metric for this route";
            range "1..16777214";
          }
        }
      }
    }

    // router static / address-family ipv4 unicast / * tag
    leaf tag {
      tailf:info "Set tag for this route";
      type uint32 {
        tailf:info "<1-4294967295>;;Set tag for this route";
      }
    }

    // router static / address-family ipv4 unicast / * permanent
    leaf permanent {
      tailf:info "Permanent route";
      type empty;
    }

    // router static / address-family ipv4 unicast / * vrflabel
    leaf vrflabel {
      tailf:info "VRF label";
      type uint32 {
        tailf:info "<0-4294967295>;;VRF label";
      }
    }

    // router static / address-family ipv4 unicast / * tunnel-id
    leaf tunnel-id {
      tailf:info "Tunnel ID";
      type uint32 {
        tailf:info "<0-4294967295>;;Tunnel ID";
      }
    }

    // router static / address-family ipv4 unicast / * description
    leaf "description" {
      tailf:info "description of the static route";
      type string {
        tailf:info "WORD;;short description of static route";
      }
    }
  }


  // router static
  // router static / vrf *
  grouping router-static-grouping {

    // router static / maximum path
    container maximum {
      tailf:info "Limit the number of static paths which may be configured";
      container "path" {
        tailf:info "Limit the number of static paths which may be configured";

        // router static / maximum path ipv4
        leaf ipv4 {
          tailf:info "IPv4 commands";
          type uint32 {
            tailf:info "<1-140000>;;The maximum number of static paths which can be configured";
            range "1..140000";
          }
        }

        // router static / maximum path ipv6
        leaf ipv6 {
          tailf:info "IPv6 commands";
          type uint32 {
            tailf:info "<1-140000>;;The maximum number of static paths which can be configured";
            range "1..140000";
          }
        }
      }
    }

    // router static / address-family
    container address-family {
      tailf:info "Static route address family configuration subcommands";

      // router static / address-family ipv4 unicast
      container ipv4 {
        tailf:info "IPv4 commands";
        container unicast {
          tailf:info "Unicast commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-static-afi";

          // router static / address-family ipv4 unicast / *
          list routes {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net interface address";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value "vrf";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }

          // router static / address-family ipv4 unicast / *
          list routes-ip {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net address";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }

          // router static / address-family ipv4 unicast / *
          list routes-if {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net interface";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value "vrf";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            uses router-static-options-grouping;
          }

          // router static / address-family ipv4 unicast / * vrf *
          list routes-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf interface address";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              //tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
              type string {
                tailf:info "WORD;;Destination VRF";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }

          // router static / address-family ipv4 unicast / * vrf *
          list routes-ip-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf address";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              //tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
              type string {
                tailf:info "Destination VRF";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }

          // router static / address-family ipv4 unicast / * vrf *
          list routes-if-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf interface";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              //tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
              type string {
                tailf:info "Destination VRF";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            uses router-static-options-grouping;
          }
        }
      }

      // router static / address-family ipv6 unicast
      container ipv6 {
        tailf:info "IPv6 commands";
        container unicast {
          tailf:info "Unicast commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-static-afi";

          // router static / address-family ipv6 unicast / *
          list routes {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net interface address";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value "vrf";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }

          // router static / address-family ipv6 unicast / *
          list routes-ip {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net address";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }

          // router static / address-family ipv6 unicast / *
          list routes-if {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net interface";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value "vrf";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            uses router-static-options-grouping;
          }

          // router static / address-family ipv6 unicast / * vrf *
          list routes-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf interface address";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              //tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
              type string {
                tailf:info "WORD;;Destination VRF";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value "vrf";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }

          // router static / address-family ipv6 unicast / * vrf *
          list routes-ip-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf address";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              //tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
              type string {
                tailf:info "WORD;;Destination VRF";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }

          // router static / address-family ipv6 unicast / * vrf *
          list routes-if-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf interface";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              //tailf:cli-diff-dependency "/cisco-ios-xr:vrf/vrf-list";
              type string {
                tailf:info "WORD;;Destination VRF";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value "vrf";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            uses router-static-options-grouping;
          }
        }
      }
    }
  }


  // router igmp
  // router igmp / vrf *
  grouping router-igmp-grouping {

    // router igmp / interface *
    list interface {
      tailf:info "IGMP interface configuration subcommands";
      tailf:cli-mode-name "config-igmp-default-if";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // router igmp / interface * / explicit-tracking
      container explicit-tracking {
        tailf:info "IGMPv3 explicit host tracking";
        presence true;
      }

      // router igmp / interface * / version
      leaf version {
        tailf:info "IGMP version";
        type uint8 {
          tailf:info "<1-3>;;version number";
        }
      }

      // router igmp / interface * / router
      leaf router {
        tailf:info "Enable/Disable Router side functionality in IGMP";
        type enumeration {
          enum disable {
            tailf:info "Disable Router side functionality in IGMP";
          }
          enum enable {
            tailf:info "Enable Router side functionality in IGMP";
          }
        }
      }

      // router igmp / interface * / join-group *
      list join-group {
        tailf:info "IGMP join multicast group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP group address";
          }
        }
        choice source-choice {
          leaf source-address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source address to include";
            }
          }
          leaf exclude {
            tailf:info "Exclude the only following source address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source address to exclude";
            }
          }
        }
      }

      // router igmp / interface * / static-group *
      list static-group {
        tailf:info "IGMP static multicast group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP group address";
          }
        }
        leaf source-address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source address to join";
          }
        }
      }
    }

    // router igmp / explicit-tracking
    container explicit-tracking {
      tailf:info "IGMPv3 explicit host tracking";
      presence true;
    }

    // router igmp / version
    leaf version {
      tailf:info "IGMP version";
      type uint8 {
        tailf:info "<1-3>;;version number";
        range "1..3";
      }
    }

    // router igmp / access-group
    leaf access-group {
      tailf:info "IGMP group access group";
      type string {
        tailf:info "WORD;;IP Named Standard Access list";
      }
    }

    // router igmp / query-interval
    leaf query-interval {
      tailf:info "IGMP host query interval";
      type uint16 {
        tailf:info "<1-3600>;;Query interval in seconds";
        range "1..3600";
      }
    }

    // router igmp / query-max-response-time
    leaf query-max-response-time {
      tailf:info "IGMP max query response value";
      type uint8 {
        tailf:info "<1-12>;;query response value in seconds";
        range "1..12";
      }
    }

    // router igmp / robustness-count
    leaf robustness-count {
      tailf:info "IGMP robustness variable";
      type uint8 {
        tailf:info "<2-10>;;Robustness variable count";
        range "2..10";
      }
    }
  }

  // l2vpn / bridge group * / bridge-domain * / mac
  // l2vpn / bridge group * / bridge-domain * / interface * / mac
  grouping l2vpn-bridge-domain-mac-grouping {

    // l2vpn / bridge group * / bridge-domain * / mac / learning
    container learning {
      tailf:info "MAC learning";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Disable MAC learning";
        type empty;
      }
    }

    // l2vpn / bridge group * / bridge-domain * / mac / limit
    container limit {
      tailf:info "MAC-Limit configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-bg-bd-ac-mac-limit";

      // l2vpn / bridge group * / bridge-domain * / mac / limit maximum
      leaf maximum {
        tailf:info "Number of MAC addresses after which MAC limit action is taken";
        type uint32 {
          tailf:info "<1-512000>;;Number of MAC addresses after "+
            "which MAC limit action is taken";
          range "1..512000";
        }
      }

      // l2vpn / bridge group * / bridge-domain * / mac / limit action
      leaf action {
        tailf:info "MAC address limit enforcement action";
        type enumeration {
          enum flood {
            tailf:info "Stop learning but continue flooding";
          }
          enum no-flood {
            tailf:info "Stop learning and stop flooding";
          }
          enum none {
            tailf:info "No action";
          }
          enum shutdown {
            tailf:info "Stop forwarding";
          }
        }
      }

      // l2vpn / bridge group * / bridge-domain * / mac / limit notification
      leaf "notification" {
        tailf:info "MAC address limit notification action";
        type enumeration {
          enum both {
            tailf:info "Generate syslog message and SNMP trap";
          }
          enum none {
            tailf:info "No notification";
          }
          enum syslog {
            tailf:info "Generate syslog message";
          }
          enum trap {
            tailf:info "Generate SNMP trap";
          }
        }
      }
    }

    // l2vpn / bridge group * / bridge-domain * / mac / secure
    container secure {
      tailf:info "MAC Secure configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-bg-bd-mac-secure";
      tailf:cli-delete-when-empty;
      presence true;

      // l2vpn / bridge group * / bridge-domain * / mac / secure / action
      leaf action {
        tailf:info "MAC secure enforcement action";
        type enumeration {
          enum none {
            tailf:info "Forward the violating packet and allow the MAC "+
              "to be relearned";
          }
          enum shutdown {
            tailf:info "Shutdown the violating bridge port";
          }
        }
      }

      // l2vpn / bridge group * / bridge-domain * / mac / secure / logging
      leaf logging {
        tailf:info "Enable Logging";
        type empty;
      }
    }
  }

  grouping freqsync-quality-grouping {

    choice quality-type {
      leaf exact {
        tailf:info "Specify the exact QL value to use";
        type empty;
      }
      leaf highest {
        tailf:info "Specify the highest acceptable QL value";
        type empty;
      }
      leaf lowest {
        tailf:info "Specify the lowest acceptable QL value";
        type empty;
      }
    }

    container itu-t {
      tailf:info "ITU-T QL options";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf option {
        tailf:info "ITU-T QL options";
        type enumeration {
          enum "1" {
            tailf:info "ITU-T QL option 1";
          }
          enum "2" {
            tailf:info "ITU-T QL option 2";
          }
        }
      }
      leaf generation {
        tailf:info "ITU-T QL option 2 generation";
        tailf:cli-incomplete-command;
        when "../option = '2'";
        type enumeration {
          enum "1" {
            tailf:info "ITU-T QL option 2, generation 1";
          }
          enum "2" {
            tailf:info "ITU-T QL option 2, generation 2";
          }
        }
      }
      leaf ql1 {
        tailf:cli-drop-node-name;
        when "../option = '1'";
        type enumeration {
          enum PRC {
          }
          enum SSU-A {
          }
          enum SSU-B {
          }
          enum SEC {
          }
          enum DNU {
          }
        }
      }
      leaf ql2 {
        tailf:cli-drop-node-name;
        when "../option = '2'";
        type enumeration {
          enum DUS {
            tailf:info "This signal should not be used for "+
              "synchronization";
          }
          enum PRS {
            tailf:info "ITU-T Option 2, Primary reference source";
          }
          enum SMC {
            tailf:info "ITU-T Option 2, SONET clock self timed";
          }
          enum ST2 {
            tailf:info "ITU-T Option 2, Stratum 2";
          }
          enum ST3 {
            tailf:info "ITU-T Option 2, Stratum 3";
          }
          enum ST3E {
            tailf:info "ITU-T Option 2, Stratum 3E";
          }
          enum STU {
            tailf:info "ITU-T Option 2, Synchronized - "+
              "traceability unknown";
          }
          enum TNC {
            tailf:info "ITU-T Option 2, Transit node clock";
          }
          enum ST4 {
          }
          enum PROV {
          }
        }
      }
    }
  }

    // router hsrp / interface * / address-family * / hsrp
  grouping router-hsrp-group-grouping {

    // router hsrp / interface * / address-family ipv4 / hsrp / name
    leaf name {
      tailf:info "MGO session name";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;MGO session name";
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / authentication
    leaf authentication {
      tailf:info "Authentication string";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Authentication string";
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / timers
    container timers {
      tailf:info "Set hello and hold timers";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      container hello {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        choice hello-timer-choice {
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;hello time in seconds";
              range "1..255";
            }
          }
          leaf msec {
            tailf:info "Specify hellotime in milliseconds";
            type uint16 {
              tailf:info "<100-3000>;;Hellotime in msecs";
              range "100..3000";
            }
          }
        }
      }
      container hold {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        choice hold-timer-choice {
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;hold time in seconds";
              range "1..255";
            }
          }
          leaf msec {
            tailf:info "Specify holdtime in milliseconds";
            type uint16 {
              tailf:info "<100-3000>;;Holdtime in msecs";
              range "100..3000";
            }
          }
        }
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / mac-address
    leaf mac-address {
      tailf:info "Use specified mac address for the virtual router";
      tailf:cli-full-command;
      type string {
        tailf:info "H.H.H;;48-bit hardware address of ARP entry";
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / preempt
    container preempt {
      tailf:info "Force active if higher priority";
      tailf:cli-delete-when-empty;
      presence true;
      leaf delay {
        tailf:info "Wait before preempting";
        type uint16 {
          tailf:info "<0-3600>;;Number of seconds to delay";
          range "0..3600";
        }
        default 0;
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / priority
    leaf priority {
      tailf:info "Priority level";
      type uint8 {
        tailf:info "<0-255>;;Priority value";
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / track *
    list track {
      tailf:info "Configure tracking";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type ifname;
      }
      leaf priority-decrement {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Priority decrement";
          range "1..255";
        }
        default 10;
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / bfd fast-detect
    container bfd {
      tailf:info "Configure BFD parameters";
      container fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-delete-when-empty;
        presence true;
        container peer {
          tailf:info "Information about HSRP peer for BFD monitoring";
          container ipv4 {
            tailf:info "BFD peer interface IPv4 address";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ipv4-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;HSRP BFD remote interface IP address";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              uses interface-name-grouping;
            }
          }
          container ipv6 {
            tailf:info "BFD peer interface IPv6 address";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ipv6-address {
              tailf:cli-drop-node-name;
              type inet:ipv6-address {
                tailf:info "X:X::X;;HSRP BFD remote interface IP address";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              uses interface-name-grouping;
            }
          }
        }
      }
    }
  }

  // router hsrp / interface * / address-family ipv4 / hsrp /
  grouping router-hsrp-ipv4-group-grouping {

    // router hsrp / interface * / address-family ipv4 / hsrp / address
    leaf address {
      tailf:info "Enable hot standby protocol for IP";
      type union {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Hot standby IP address";
        }
        type enumeration {
          enum learn {
            tailf:info "Learn virtual IP address from peer";
          }
        }
      }
    }

    uses router-hsrp-group-grouping;
  }

  // router hsrp / interface * / address-family ipv6 / hsrp /
  grouping router-hsrp-ipv6-group-grouping {

    uses router-hsrp-group-grouping;

    // router hsrp / interface * / address-family ipv6 / hsrp / address
    container address {
      tailf:info "Enable hot standby protocol for IP";

      // router hsrp / interface * / address-family ipv6 / hsrp / address global *
      leaf-list global {
        tailf:info "Global HSRP IPv6 address";
        tailf:cli-list-syntax;
        type inet:ipv6-address {
          tailf:info "X:X::X;;Set Global HSRP IPv6 address";
        }
      }

      // router hsrp / interface * / address-family ipv6 / hsrp / address linklocal
      container linklocal {
        tailf:info "HSRP IPv6 linklocal address";
        choice linklocal-choice {
          leaf address {
            tailf:cli-drop-node-name;
            type inet:ipv6-address {
              tailf:info "X:X::X;;HSRP IPv6 linklocal address";
            }
          }
          container autoconfig {
            tailf:info "Autoconfigure the HSRP IPv6 linklocal address";
            tailf:cli-delete-when-empty;
            presence true;
            leaf legacy-compatible {
              tailf:info "Autoconfigure for Legacy compatibility (with IOS/NX-OS)";
              type empty;
            }
          }
        }
      }
    }
  }


  // interface ATM* /
  grouping interface-atm-grouping {

    // interface ATM* / atm
    container atm {
      tailf:info "Global ATM interface configuration subcommands";

      // interface ATM* / atm mcpt-timers
      container mcpt-timers {
        tailf:info "Configure Maximum cell Packing Timeout Values";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf timer-1 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<50-4095>;;MCPT timer1 value in microsecond "+
              "(CEoP min value is 101)";
            range "50..4095";
          }
        }
        leaf timer-2 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<50-4095>;;MCPT timer2 value in microsecond";
            range "50..4095";
          }
        }
        leaf timer-3 {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<60-4095>;;MCPT timer3 value in microsecond";
            range "60..4095";
          }
        }
      }

      // interface ATM* / atm ilmi-keepalive
      container ilmi-keepalive {
        tailf:info "ILMI keepalive configuration";
        presence true;
      }
    }

    // interface ATM* / pvc *
    list pvc {
      tailf:info "Configure a pvc on this interface";
      tailf:cli-mode-name "config-atm-l2transport-pvc";
      key vpi-vci;
      leaf vpi-vci {
        type string {
          tailf:info "WORD;;VPI/VCI";
        }
      }

      // interface ATM* / pvc * / service-policy
      uses interface-service-policy-grouping;

      // interface ATM* / pvc * / shape
      container shape {
        tailf:info "ATM Traffic Shaping";

        // interface ATM* / pvc * / shape vbr-nrt
        container vbr-nrt {
          tailf:info "Variable Bit Rate - Non Real Time";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf peak-output-rate {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<8-599040>;;Peak output rate in kbps (max:OC12 599040; OC3 149760; T1 1544; T3 44736)";
            }
          }
          leaf sustained-output-rate {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<8-599040>;;Sustained output rate (kbps)";
            }
          }
          leaf burst-size {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-8192>;;Burst size (cells)";
            }
          }
        }
      }

      // interface ATM* / pvc * / encapsulation
      leaf encapsulation {
        tailf:info "Configure encapsulation on this PVC";
        tailf:cli-full-command;
        type enumeration {
          enum aal0 {
            tailf:info "Use aal0 encapsulation on this PVC";
          }
          enum aal5 {
            tailf:info "Use aal5 encapsulation on this PVC";
          }
          enum aal5mux {
            tailf:info "Use aal5mux encapsulation on this PVC";
          }
          enum aal5nlpid {
            tailf:info "Use aal5nlpid encapsulation on this PVC";
          }
          enum aal5snap {
            tailf:info "Use aal5snap encapsulation on this PVC";
          }
        }
      }

      // interface ATM* / pvc * / oam
      container oam {
        tailf:info "Configure ATM OAM VC commands";

        // interface ATM* / pvc * / oam retry
        container retry {
          tailf:info "Enter OAM to configure retry freq";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf up-count {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-600>;;OAM retry count before declaring a VC as up";
            }
          }
          leaf down-count {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-600>;;OAM retry count before declaring a VC as down";
            }
          }
          leaf retry-frequency {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-1000>;;OAM retry polling frequency in seconds";
            }
          }
        }
      }

      // interface ATM* / pvc * / oam-pvc manage
      container oam-pvc {
        tailf:info "Enter OAM to generate OAM cells  ";
        container manage {
          tailf:info "OAM PVC management";
          tailf:cli-delete-when-empty;
          presence true;
          // interface ATM* / pvc * / oam-pvc manage disable
          leaf disable {
            tailf:info "Disable OAM PVC management";
            tailf:cli-reset-container;
            tailf:cli-full-command;
            type empty;
          }
          leaf frequency {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<0-600>;;OAM loopback frequency (seconds)";
              range "0..600";
            }
          }
        }
      }

      // interface ATM* / pvc * / cell-packing
      container cell-packing {
        tailf:info "Configure L2VPN cell packing parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf cells {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<2-255>;;Maximum number of cells to be packed in a packet";
            range "2..255";
          }
        }
        leaf timer {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-3>;;Which cell packing timer to use";
            range "1..3";
          }
        }
      }
    }
  }


  // ipsla / operation * / type udp *
  // ipsla / operation * / type icmp *
  // ipsla / operation * / type mpls lsp *
  grouping ipsla-operation-type-grouping {

    // ipsla / operation * / type * / tag
    leaf tag {
      tailf:info "Add a tag for this operation";
      type string {
        tailf:info "WORD;;Tag string";
      }
    }

    // ipsla / operation * / type * / timeout
    leaf timeout {
      tailf:info "Probe/Control timeout interval";
      type uint32 {
        tailf:info "<1-604800000>;;Probe/Control timeout in ms (default 5000 ms)";
        range "1..604800000";
      }
    }

    // ipsla / operation * / type * / vrf
    leaf vrf {
      tailf:info "Configure IPSLA for a VPN Routing/Forwarding instance";
      type string {
        tailf:info "WORD;;VPN Routing/Forwarding instance name";
      }
    }

    // ipsla / operation * / type * / source
    container source {
      tailf:info "Address/port of the source device";

      // ipsla / operation * / type * / source address
      leaf address {
        tailf:info "IPv4 address of the source device";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Enter IPv4 address of the source device";
        }
      }

      // ipsla / operation * / type * / source port
      leaf port {
        tailf:info "Port number on source device";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Specify the port number";
        }
      }
    }

    // ipsla / operation * / type * / destination
    container destination {
      tailf:info "Address/port of the target device";

      // ipsla / operation * / type * / destination address
      leaf address {
        tailf:info "IPv4 address of the target device";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Enter IPv4 address of the target device";
        }
      }

      // ipsla / operation * / type * / destination port
      leaf port {
        tailf:info "Port number on target device";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Specify the port number";
        }
      }
    }

    // ipsla / operation * / type * / statistics hourly
    container statistics {
      tailf:info "Statistics collection parameters for this operation";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ipsla-op-stats";
      tailf:cli-incomplete-command;
      leaf hourly {
        tailf:info "Statistics collection aggregated over an hour";
        tailf:cli-hide-in-submode;
        type empty;
      }
      // ipsla / operation * / type * / statistics hourly / buckets
      leaf buckets {
        tailf:info "Number of Hours for which statistics are kept";
        type uint8 {
          tailf:info "<0-25>;;Specify number of hours (default 2)";
          range "0..25";
        }
      }
    }

    // ipsla / operation * / type * / packet
    container packet {
      tailf:info "Probe packet configuration parameters";
      // ipsla / operation * / type * / packet count
      leaf count {
        tailf:info "Number of packets to be transmitted during a probe";
        type uint16 {
          tailf:info "<1-60000>;;Packet count (default 10)";
          range "1..60000";
        }
      }
      // ipsla / operation * / type * / packet interval
      leaf interval {
        tailf:info "Inter packet interval";
        type uint16 {
          tailf:info "<1-60000>;;Packet interval (default 20 ms)";
          range "1..60000";
        }
      }
    }

    // ipsla / operation * / type * / tos
    leaf tos {
      tailf:info "Type of service setting in probe packet";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Type of service number";
      }
    }

    // ipsla / operation * / type * / datasize request
    container datasize {
      tailf:info "Protocol data size in payload of probe packets";
      leaf request {
        tailf:info "Payload size in request probe packet";
        type uint16 {
          tailf:info "<16-1500>;;Enter request datasize in byte";
        }
      }
    }

    // ipsla / operation * / type * / target
    container target {
      tailf:info "Target for the MPLS LSP operation";

      // ipsla / operation * / type * / target traffic-eng tunnel
      container traffic-eng {
        tailf:info "Traffic engineering target";
        leaf tunnel {
          tailf:info "TE tunnel interface";
          type uint16 {
            tailf:info "<0-65535>;;Tunnel interface number";
          }
        }
      }

      // ipsla / operation * / type * / target pseudowire
      container pseudowire {
        tailf:info "Pseudowire target";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Target address";
          }
        }
        leaf pw-id {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Virtual Circuit ID";
          }
        }
      }

      // ipsla / operation * / type * / target ipv4
      leaf ipv4 {
        tailf:info "Target specified as an IPv4 address";
        tailf:cli-full-command;
        type ipv4-prefix {
          tailf:info "A.B.C.D/prefix;;Target FEC address with mask";
        }
      }
    }

    // ipsla / operation * / type * / frequency
    leaf frequency {
      tailf:info "Frequency of the probing";
      type uint32 {
        tailf:info "<1-604800>;;Probe interval in seconds (default 60)";
        range "1..604800";
      }
    }

    // ipsla / operation * / type * / statistics interval *
    container statistics-interval {
      tailf:cli-drop-node-name;
      container statistics {
        tailf:info "Statistics collection parameters for this operation";
        list interval {
          tailf:info "Statistics collection over specified time interval";
          tailf:cli-mode-name "config-ipsla-op-stats";
          key seconds;
          leaf seconds {
            type uint16 {
              tailf:info "<1-3600>;;Interval in seconds";
              range "1..3600";
            }
          }

          // ipsla / operation * / type * / statistics interval * buckets
          leaf buckets {
            tailf:info "Maximum number of buckets to keep";
            type uint8 {
              tailf:info "<1-100>;;Buckets of enhanced statistics kept";
              range "1..100";
            }
          }
        }
      }
    }
  }


  grouping storm-control-grouping {
    container storm-control {
      tailf:info "Storm Control";
      container broadcast {
        tailf:info "Broadcast Storm Control";
        leaf kbps {
          tailf:info "Set the storm control kbps";
          type uint32 {
            tailf:info "<64-1280000>;;storm control kbps value";
            range "64..1280000";
          }
        }
        leaf pps {
          tailf:info "Set the storm control pps";
          type uint32 {
            tailf:info "<1-160000>;;storm control pps value";
            range "1..160000";
          }
        }
      }
      container multicast {
        tailf:info "Multicast Storm Control";
        leaf kbps {
          tailf:info "Set the storm control kbps";
          type uint32 {
            tailf:info "<64-1280000>;;storm control kbps value";
            range "64..1280000";
          }
        }
        leaf pps {
          tailf:info "Set the storm control pps";
          type uint32 {
            tailf:info "<1-160000>;;storm control pps value";
            range "1..160000";
          }
        }
      }
      container unknown-unicast {
        tailf:info "Unknown-unicast Storm Control";
        leaf kbps {
          tailf:info "Set the storm control kbps";
          type uint32 {
            tailf:info "<64-1280000>;;storm control kbps value";
            range "64..1280000";
          }
        }
        leaf pps {
          tailf:info "Set the storm control pps";
          type uint32 {
            tailf:info "<1-160000>;;storm control pps value";
            range "1..160000";
          }
        }
      }
    }
  }


  // vrf * / address-family ipv4 unicast
  // vrf * / address-family ipv4 flowspec
  grouping vrf-af-ipv4-grouping {

    // vrf * / address-family ipv4 unicast / import
    container "import" {
      tailf:info "VRF import";

      // vrf * / address-family ipv4 unicast / import route-policy
      leaf route-policy {
        tailf:info "Use route-policy for import filtering";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
      }

      // vrf * / address-family ipv4 unicast / import route-target
      container route-target {
        tailf:info "Specify import route target extended communities";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-vrf-import-rt";
        uses vrf-route-target-grouping;
      }

      // vrf * / address-family ipv4 unicast / import from
      container from {
        tailf:info "Import routes from a VRF";

        // vrf * / address-family ipv4 unicast / import from vrf  advertise-as-vpn
        container vrf {
          tailf:info "VRF import";
          leaf advertise-as-vpn {
            tailf:info "Advertise imported routes to PEs";
            type empty;
          }
        }

        // vrf * / address-family ipv4 unicast / import from default-vrf
        container default-vrf {
          tailf:info "Import routes from the default VRF";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf route-policy {
            tailf:info "Use route-policy for import filtering";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
          leaf advertise-as-vpn {
            tailf:info "Advertise imported routes to PE";
            type empty;
          }
        }
      }
    }

    // vrf * / address-family ipv4 unicast / export
    container export {
      tailf:info "VRF export";

      // vrf * / address-family ipv4 unicast / export route-policy
      leaf route-policy {
        tailf:info "Use route-policy for export filtering";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
      }

      // vrf * / address-family ipv4 unicast / export route-target
      container route-target {
        tailf:info "Specify export route target extended communities";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-vrf-export-rt";
        uses vrf-route-target-grouping;
      }

      // vrf * / address-family ipv4 unicast / export to
      container to {
        tailf:info "Export routes to a VRF";

        // vrf * / address-family ipv4 unicast / export to vrf
        container vrf {
          tailf:info "VRF export";
          leaf allow-imported-vpn {
            tailf:info "Allow export of imported VPN routes to non-default VRF";
            type empty;
          }
        }

        // vrf * / address-family ipv4 unicast / export to default-vrf
        container default-vrf {
          tailf:info "Export routes to the default VRF";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf route-policy {
            tailf:info "Use route-policy for export";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
          leaf allow-imported-vpn {
            tailf:info "Export imported VPN routes to default VRF";
            type empty;
          }
        }
      }
    }

    // vrf * / address-family ipv4 unicast / maximum
    container maximum {
      tailf:info "Set maximum prefix limit";
      container "prefix" {
        tailf:info "Set table's maximum prefix limit";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf limit {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<32-5000000>;;Maximum table's prefix limit";
            range "32..5000000";
          }
        }
        leaf mid-thresh {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-100>;;mid-thresh (% of max)";
            range "1..100";
          }
        }
      }
    }
  }

  // snmp-server host *
  grouping snmp-server-host-grouping {
    list host {
      tailf:info "Specify hosts to receive SNMP notifications";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key "address type community-string";
      leaf address {
        type string {
          tailf:info "A.B.C.D or X:X::X;;IP address of SNMP notification host";
        }
      }
      leaf "type" {
        type enumeration {
          enum traps {
            tailf:info "Send Trap messages to this host";
          }
          enum informs {
            tailf:info "Send Inform messages to this host";
          }
        }
      }
      leaf version {
        tailf:info "SNMP version to use for notification messages";
        tailf:cli-optional-in-sequence;
        tailf:cli-prefix-key {
          tailf:cli-before-key 3;
        }
        type enumeration {
          enum "1" {
            tailf:info "WORD  Use 1 for SNMPv1";
          }
          enum "2c" {
            tailf:info "WORD;;Use 2c for SNMPv2c";
          }
          enum "3" {
            tailf:info "WORD;;Use 3 for SNMPv3";
          }
        }
      }
      leaf security-level {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        when "../version = '3'" {
          tailf:dependency "../version";
        }
        tailf:cli-prefix-key {
          tailf:cli-before-key 3;
        }
        type enumeration {
          enum auth {
            tailf:info "Using authNoPriv Security Level";
          }
          enum noauth {
            tailf:info "Using noAuthNoPriv Security Level";
          }
          enum priv {
            tailf:info "Using authPriv Security Level";
          }
        }
      }
      leaf enc {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-prefix-key {
          tailf:cli-before-key 3;
        }
        tailf:meta-data "secret-password" {
          tailf:meta-value "(snmp-server host \\S+ (?:traps|informs)(?: version \\S+)?(?: auth| priv| noauth)?) <SECRET>";
        }
        type enumeration {
          enum clear {
            tailf:info "Save the community string in encrypted form";
          }
          enum encrypted {
            tailf:info "Specifies an ENCRYPTED community string";
          }
        }
      }
      leaf community-string {
        tailf:cli-disallow-value "traps|informs|version|auth|noauth|priv|clear|encrypted";
        type string {
          tailf:info "WORD;;The UNENCRYPTED (cleartext) community string";
        }
      }
      leaf udp-port {
        tailf:info "udp port to which notifications should be sent";
        type uint16 {
          tailf:info "<1-65535>;;udp port number";
          range "1..65535";
        }
      }
    }
  }

  // multicast-routing /
  // multicast-routing / vrf /
  grouping multicast-routing-grouping {

    // multicast-routing / address-family
    container address-family {
      tailf:info "Enter Address Family command mode";

      // multicast-routing / address-family ipv4
      container ipv4 {
        tailf:info "IPv6 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mcast-default-ipv4";

        // multicast-routing / address-family ipv4 / interface *
        list interface {
          tailf:info "Multicast interface configuration subcommands";
          tailf:cli-mode-name "config-mcast-default-ipv4-if";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }

          // multicast-routing / address-family ipv4 / interface * / enable
          // multicast-routing / address-family ipv4 / interface * / disable
          choice status-choice {
            leaf enable {
              tailf:info "Enable IP multicast";
              tailf:cli-full-command;
              type empty;
            }
            leaf disable {
              tailf:info "Disable IP multicast";
              tailf:cli-full-command;
              type empty;
            }
          }

          // multicast-routing / address-family ipv4 / interface * / boundary
          leaf boundary {
            tailf:info "Boundary for administratively scoped multicast "+
              "addresses";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Access list specifying scoped multicast "+
                "groups";
            }
          }
        }

        // multicast-routing / address-family ipv4 / interface-inheritance
        container interface-inheritance {
          tailf:info "Knob to separate enabling/disabling multicast routing & forwarding";
          leaf disable {
            tailf:info "Disable inheriting En/Dis config";
            tailf:cli-full-command;
            type empty;
          }
        }

        // multicast-routing / address-family ipv4 / nsf
        leaf nsf {
          tailf:cli-full-command;
          type empty;
        }

        // multicast-routing / address-family ipv4 / log-traps
        leaf log-traps {
          tailf:info "Enable logging trap events";
          type empty;
        }

        // multicast-routing / address-family ipv4 / mdt
        container mdt {
          tailf:info "MVPN configuration";

          // multicast-routing / address-family ipv4 / mdt mtu
          leaf mtu {
            tailf:info "MDT mtu configuration";
            type uint16 {
              tailf:info "<1401-65535>;;MTU value";
              range "1401..65535";
            }
          }

          // multicast-routing / address-family ipv4 / mdt source
          container source {
            tailf:info "Interface used to set MDT source address";
            uses interface-name-grouping;
          }

          // multicast-routing / address-family ipv4 / mdt data
          container data {
            tailf:info "Data MDT configuration";

            // multicast-routing / address-family ipv4 / mdt data a.b.c.d
            container address {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf mdt-group-address {
                tailf:cli-drop-node-name;
                type ipv4-prefix {
                  tailf:info "A.B.C.D/length;;Data MDT group IP address/prefix length";
                }
              }
              leaf threshold {
                tailf:info "Traffic rate threshold in Kbps to trigger Data MDT";
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<0-4294967295>;;Threshold value (kbps). Default 1kbps";
                }
                default 1;
              }
              leaf acl-name {
                tailf:cli-drop-node-name;
                tailf:cli-disallow-value "threshold";
                type string {
                  tailf:info "WORD;;ACL for Customer VRF groups allowed to do Data MDT";
                }
              }
            }

            // multicast-routing / address-family ipv4 / mdt data p2mp-te
            container p2mp-te {
              tailf:info "P2MPTE Data MDT core";
              choice max-or-rp-choice {
                container max-number {
                  tailf:cli-drop-node-name;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-all-siblings;
                  }
                  leaf "value" {
                    tailf:cli-drop-node-name;
                    type uint8 {
                      tailf:info "<1-255>;;Maximum number of data-mdts to be triggered";
                    }
                  }
                  // TODO: there are more leafs here, max-number gives option to add more
                }
                leaf route-policy {
                  tailf:info "Route policy to select data mdt core";
                  type string {
                    tailf:info "WORD;;Route policy name";
                  }
                  tailf:non-strict-leafref {
                    path "/cisco-ios-xr:route-policy/name";
                  }
                }
              }
            }
          }

          // multicast-routing / address-family ipv4 / mdt default
          container "default" {
            tailf:info "MDT Default distribution tree";

            // multicast-routing / address-family ipv4 / mdt default ipv4
            leaf ipv4 {
              tailf:info "IPv4 encapsulated MDT";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address MDT default group";
              }
            }

            // multicast-routing / address-family ipv4 / mdt default mldp *
            container mldp {
              tailf:info "mLDP default distribution tree";
              list ipv4 {
                tailf:info "MP2MP core-tree with IPv4 Root Address";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                key address;
                leaf address {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Root address";
                  }
                }
                container partitioned {
                  tailf:info "mLDP Partitioned MDT";
                  leaf bidir {
                    tailf:info "Enable Exclusive Partitioned MDT for Bidir";
                    type empty;
                  }
                }
              }
            }

            // multicast-routing / address-family ipv4 / mdt default p2mp-te
            container p2mp-te {
              tailf:info "P2MP-TE default distribution tree";
              tailf:cli-delete-when-empty;
              presence true;

              // multicast-routing / address-family ipv4 / mdt default p2mp-te attribute-set
              leaf attribute-set {
                tailf:info "The Attribute Set template to be used with the TE tunnel request";
                type string {
                  tailf:info "WORD;;Name of template describing the Attribute Set";
                }
              }

              // multicast-routing / address-family ipv4 / mdt default p2mp-te static
              container static {
                tailf:info "Static P2MP-TE Tunnel";
                leaf tunnel-mte {
                  tailf:cli-allow-join-with-value {
                    tailf:cli-display-joined;
                  }
                  type uint16 {
                    tailf:info "<0-65535>;;MPLS Traffic Engineering P2MP Tunnel interface(s)";
                  }
                }
              }
            }
          }
        }

        // multicast-routing / address-family ipv4 / bgp
        container bgp {
          tailf:info "Enable BGP MVPN Discovery";
          // multicast-routing / address-family ipv4 / bgp auto-discovery
          container auto-discovery {
            tailf:info "Enable BGP Auto-Discovery";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-mcast-vrf-ipv4-bgp-ad";
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            leaf ad-tree {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              type enumeration {
                enum ingress-replication {
                  tailf:info "IR core tree";
                }
                enum mldp {
                  tailf:info "mLDP core tree";
                }
                enum p2mp-te {
                  tailf:info "RSVP P2MP-TE core tree";
                }
                enum pim {
                  tailf:info "PIM core tree";
                }
              }
            }
            // multicast-routing / address-family ipv4 / bgp auto-discovery / inter-as
            leaf inter-as {
              tailf:info "Inter-AS MVPN";
              tailf:cli-break-sequence-commands;
              type empty;
            }
            // multicast-routing / address-family ipv4 / bgp auto-discovery / leaf-info-required
            leaf leaf-info-required {
              tailf:info "Explicit tracking of S-PMSI core trees";
              type empty;
            }
          }
        }

        // multicast-routing / address-family ipv4 / multipath
        container multipath {
          tailf:info "Enable equal-cost multipath routing";
          tailf:cli-delete-when-empty;
          presence true;

          // multicast-routing / address-family ipv4 / multipath hash
          leaf hash {
            tailf:info "Enter a hashing algorithm";
            type enumeration {
              enum source {
                tailf:info "Enable source based multipath hashing (Compatible with IOS versions)";
              }
              enum source-group {
                tailf:info "Enable source, group based multipath hashing";
              }
              enum source-nexthop {
                tailf:info "Enable source with next-hop multipath hashing (better distribution)";
              }
            }
          }
        }

        // multicast-routing / address-family ipv4 / ssm
        container ssm {
          tailf:info "Configure a group range for Source-Specific use";
          leaf "range" {
            tailf:info "Provide ACL that specifies non-standard SSM range";
            type string {
              tailf:info "WORD;;Access list specifying SSM group range";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
            }
          }
          leaf allow-override {
            tailf:info "Allow SSM ranges to be overridden by more "+
              "specific ranges";
            type empty;
          }
        }

        // multicast-routing / address-family ipv4 / oom-handling
        container oom-handling {
          tailf:info "Enable out-of-memory handling";
          presence true;
        }

        // multicast-routing / address-family ipv4 / rate-per-route
        leaf rate-per-route {
          tailf:info "Enable/disable per (S,G) rate calculation";
          tailf:cli-full-command;
          type empty;
        }

        // multicast-routing / address-family ipv4 / accounting
        container accounting {
          tailf:info "Enable/disable Accounting";
          container per-prefix {
            tailf:info "Enable per (S,G) accounting.";
            presence true;
          }
        }
      }

      // multicast-routing / address-family ipv6
      container ipv6 {
        tailf:info "IPv6 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pim-default-ipv6";
        list interface {
          tailf:info "Multicast interface configuration subcommands";
          tailf:cli-mode-name "config-mcast-default-ipv6-if";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf enable {
            tailf:info "Enable IP multicast";
            tailf:cli-full-command;
            type empty;
          }
        }
        container multipath {
          tailf:info "Enable equal-cost multipath routing";
          presence true;
        }
      }
    }
  }


  // router mld  /
  // router mld  / vrf * /
  grouping router-mld-grouping {

    // router mld / version
    leaf version {
      tailf:info "MLD version";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-2>;;version number";
        range "1..2";
      }
    }

    // router mld / interface *
    list interface {
      tailf:info "MLD interface configuration subcommands";
      tailf:cli-mode-name "config-mld-default-if";
      key name;
      leaf name {
        type ifname;
      }

      // router mld / interface * / enable
      leaf router {
        tailf:info "Enable/Disable Router side functionality in MLD";
        tailf:cli-full-command;
        type enumeration {
          enum enable {
            tailf:info "Enable Router side functionality in MLD";
          }
          enum disable {
            tailf:info "Disable Router side functionality in MLD";
          }
        }
      }
    }
  }

  grouping router-pim-grouping {

    // router pim / address-family ipv4
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv4 {
        tailf:info "Enter ipv4 Address Family command mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pim-default-ipv4";

        // router pim / address-family ipv4 / hello-interval
        leaf hello-interval  {
          tailf:info "Inherited by all interfaces : Hello interval in seconds";
          type uint16 {
            tailf:info "<1-3600>;;Hello interval in seconds";
            range "1..3600";
          }
        }

        // router pim / address-family ipv4 / rpf
        container rpf {
          tailf:info "RPF commands";
          // router pim / address-family ipv4 / rpf topology
          container topology {
            tailf:info "Select RPF topology";
            // router pim / address-family ipv4 / rpf topology route-policy *
            leaf route-policy {
              tailf:info "Route policy to select RPF topology";
              type string {
                tailf:info "WORD;;Name of the policy";
              }
              tailf:non-strict-leafref {
                path "/cisco-ios-xr:route-policy/name";
              }
            }
          }
        }

        // router pim / address-family ipv4 / mdt
        container mdt {
          tailf:info "Multicast Distribution Tree commands";

          // router pim / address-family ipv4 / mdt c-multicast-routing
          container c-multicast-routing {
            tailf:info "MVPN customer routing commands";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pim-default-ipv4-mdt-cmcast";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            choice protocol-choice {
              leaf bgp {
                tailf:info "BGP customer multicast routing";
                tailf:cli-hide-in-submode;
                tailf:cli-full-command;
                type empty;
              }
              leaf pim {
                tailf:info "PIM customer multicast routing";
                tailf:cli-hide-in-submode;
                tailf:cli-full-command;
                type empty;
              }
            }

            // router pim / address-family ipv4 / mdt c-multicast-routing * / unicast-reachability
            container unicast-reachability {
              tailf:cli-break-sequence-commands;
              tailf:info "Control addition of Extended Communities to Unicast VPN-IP routes";
              tailf:cli-compact-syntax;
              // router pim / address-family ipv4 / mdt c-multicast-routing * / unicast-reachability connector
              leaf connector {
                tailf:info "Enable/Disable Connector";
                type enumeration {
                  enum disable {
                    tailf:info "Disable Connector Attribute";
                  }
                  enum enable {
                    tailf:info "Enable Connector Attribute";
                  }
                }
              }
            }

            // router pim / address-family ipv4 / mdt c-multicast-routing * / announce-pim-join-tlv
            leaf announce-pim-join-tlv {
              tailf:info "Announce PIM MDT Join TLVs";
              tailf:cli-full-command;
              type empty;
            }
          }
        }

        // router pim / address-family ipv4 / auto-rp
        container auto-rp {
          tailf:info "Auto-RP Commands";
          container listen {
            tailf:info "RP discovery through AUTORP protocol";
            leaf disable {
              tailf:info "Disable RP discovery through the AUTORP protocol";
              type empty;
            }
          }
        }

        // router pim / address-family ipv4 / rp-address *
        list rp-address {
          tailf:info "Configure Rendezvous Point";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key name;
          leaf name {
            type inet:host {
              tailf:info "IP name or address of Rendezvous Point";
            }
          }
          leaf group-access-list {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;Access list of groups that should map "+
                "to given RP";
            }
          }
          leaf override {
            tailf:info "Static RP config overrides auto-rp and BSR";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf bidir {
            tailf:info "Specify keyword bidir to configure a bidir RP";
            type empty;
          }
        }

        // router pim / address-family ipv4 / accept-register
        leaf accept-register {
          tailf:info "Registers accept filter";
          type string {
            tailf:info "WORD;;IP named access list";
          }
        }

        // router pim / address-family ipv4 / spt-threshold
        container spt-threshold {
          tailf:info "Configure threshold for switching to SPT on last-hop";
          container infinity {
            tailf:info "Always stay on shared-tree";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf group-list {
              tailf:info "Only stay on the shared-tree for specified groups";
              type string {
                tailf:info "WORD;;Access-list of threshold limited groups";
              }
            }
          }
        }

        // router pim / address-family ipv4 / neighbor-check-on-recv
        container neighbor-check-on-recv {
          tailf:info "Check for PIM neighbor before rcv'ing control messages";
          leaf enable {
            tailf:info "Enable this feature";
            type empty;
          }
        }

        // router pim / address-family ipv4 / neighbor-check-on-send
        container neighbor-check-on-send {
          tailf:info "Check for PIM neighbor before sending control messages";
          leaf enable {
            tailf:info "Enable this feature";
            type empty;
          }
        }

        // router pim / address-family ipv4 / nsf lifetime
        container nsf {
          tailf:info "Configure Non-stop forwarding (NSF) options"+
            "(cisco-support)";
          leaf lifetime {
            tailf:info "Override default maximum lifetime for PIM NSF mode";
            type uint16 {
              tailf:info "<10-600>;;Maximum time for PIM NSF mode in seconds";
              range "10..600";
            }
          }
        }

        // router pim / address-family ipv4 / log neighbor
        container log {
          tailf:info "Enable PIM logging";
          container neighbor {
            tailf:info "Enable PIM neighbor logging";
            leaf changes {
              tailf:info "Enable PIM neighbor state logging";
              type empty;
            }
          }
        }

        // router pim / address-family ipv4 / interface *
        list interface {
          tailf:info "PIM interface configuration subcommands";
          tailf:cli-mode-name "config-pim-ipv4-if";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }

          // router pim / address-family ipv4 / interface * / bfd
          uses bfd-common-parameters-grouping;

          // router pim / address-family ipv4 / interface * / enable
          // router pim / address-family ipv4 / interface * / disable
          choice status-choice {
            leaf enable {
              tailf:info "Enable PIM processing on this interface";
              tailf:cli-full-command;
              type empty;
            }
            leaf disable {
              tailf:info "Disable PIM processing on this interface";
              tailf:cli-full-command;
              type empty;
            }
          }

          // router pim / address-family ipv4 / interface * / dr-priority
          leaf dr-priority {
            tailf:info "PIM Hello DR priority";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-4294967295>;;Hello DR priority, preference given to larger value";
            }
          }
        }

        // router pim / address-family ipv4 / maximum
        container maximum {
          tailf:info "Maximum state limits";

          // router pim / address-family ipv4 / maximum routes
          container routes {
            tailf:info "PIM Routes";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf number {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-200000>;;Maximum PIM routes";
                range "1..200000";
              }
            }
            leaf threshold {
              tailf:info "Set threshold to print warning";
              type uint32 {
                tailf:info "<1-200000>;;Threshold value";
                range "1..200000";
              }
            }
          }
        }
      }

      // router pim / address-family ipv6
      container ipv6 {
        tailf:info "Enter ipv6 Address Family command mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pim-default-ipv6";

        // router pim / address-family ipv6 / neighbor-check-on-recv
        leaf neighbor-check-on-recv {
          tailf:info "Check for PIM neighbor before rcv'ing control messages";
          tailf:cli-full-command;
          type enumeration {
            enum enable {
              tailf:info "Enable this feature";
            }
          }
        }

        // router pim / address-family ipv6 / neighbor-check-on-send
        leaf neighbor-check-on-send {
          tailf:info "Check for PIM neighbor before sending control messages";
          tailf:cli-full-command;
          type enumeration {
            enum enable {
              tailf:info "Enable this feature";
            }
          }
        }

        // router pim / address-family ipv6 / interface *
        list interface {
          tailf:info "PIM interface configuration subcommands";
          tailf:cli-mode-name "config-pim-ipv6-if";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interace Name";
            }
          }

          // router pim / address-family ipv6 / interface * / enable
          leaf enable {
            tailf:info "Enable PIM processing on this interface";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
    }
  }

  grouping router-rip-redistribute-grouping {
    leaf route-policy {
      tailf:info "Route policy reference";
      type string {
        tailf:info "WORD;;Name of the policy";
      }
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:route-policy/name";
      }
    }
  }


  // router rip /
  // router rip / interface * /
  grouping router-rip-if-grouping {

    // router rip / route-policy * in|out
    uses route-policy-list-grouping;
  }

  grouping router-rip-grouping {

    // router rip / interface *
    list interface {
      tailf:info "Enter the RIP interface configuration submode";
      tailf:cli-mode-name "config-rip-if";
      key name;
      leaf name {
        type ifname;
      }

      // router rip / interface * / passive-interface
      leaf passive-interface {
        tailf:info "Suppress routing updates on this interface";
        tailf:cli-full-command;
        type empty;
      }

      uses router-rip-if-grouping;
    }

    // router rip / timers basic
    container timers {
      tailf:info "Adjust routing timers";
      container basic {
        tailf:info "Basic routing protocol update timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf update {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<5-50000>;;Interval between updates";
          }
        }
        leaf invalid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<15-200000>;;Invalid";
          }
        }
        leaf holddown {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<15-200000>;;Holddown";
          }
        }
        leaf flush {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-250000>;;Flush";
          }
        }
      }
    }

    // router rip / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router rip / redistribute static
      container static {
        tailf:info "Static";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute bgp
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
          }
        }
        uses router-rip-redistribute-grouping;
      }
    }

    // router rip / auto-summary
    leaf auto-summary {
      tailf:info "Enable automatic network number summarization";
      tailf:cli-full-command;
      type empty;
    }

    // router rip / maximum-paths
    leaf maximum-paths {
      tailf:info "Maximum number of paths allowed per route";
      type uint8 {
        tailf:info "<1-128>;;Number of paths";
        range "1..128";
      }
    }

    uses router-rip-if-grouping;
  }


  // router vrrp / interface * / address-family ipv4 / vrrp * /
  // router vrrp / interface * / address-family ipv6 / vrrp * /
  grouping router-vrrp-if-af-vrrp-grouping {

    // router vrrp / interface * / address-family ipv4 / vrrp * / priority
    leaf priority {
      tailf:info "Set priority level";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-254>;;Priority value";
      }
    }

    // router vrrp / interface * / address-family ipv4 / vrrp * / preempt
    container preempt {
      tailf:info "Preempt Master router if higher priority";
      choice preempt-choice {
        leaf delay {
          tailf:info "Wait before preempting";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<1-3600>;;Number of seconds to delay";
            range "1..3600";
          }
        }
        leaf disable {
          tailf:info "Disable preemption";
          type empty;
        }
      }
    }

    // router vrrp / interface * / address-family ipv4 / vrrp * / timer
    container timer {
      tailf:info "Set advertisement timer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice timer-choice {
        leaf time-value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Advertisement time in seconds";
          }
        }
        leaf msec {
          tailf:info "Configure in milliseconds";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<100-3000>;;Advertisement time in "+
              "milliseconds (100-3000)";
          }
        }
      }
      leaf force {
        tailf:info "Force the configured values to be used "+
          "(required for msec)";
        type empty;
      }
    }

    // router vrrp / interface * / address-family ipv4 / vrrp * / track *
    container track {
      tailf:info "Track an item, reducing priority if it goes down";
      list interface {
        tailf:info "Track an interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf priority {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-254>;;Priority decrement";
            range "1..254";
          }
        }
      }
    }
  }

  // router bgp * / address-family * / advertise
  grouping router-bgp-af-advertise-grouping {

    // router bgp * / address-family * / advertise * re-originated
    container re-originated {
      tailf:info "Advertise Re-orignated routes only";
      tailf:cli-delete-when-empty;
      presence true;
      leaf route-target {
        tailf:cli-drop-node-name;
        type enumeration {
          enum regular-rt {
            tailf:info "Advertise re-originated routes with regular (non-stitching) Route-Targets";
          }
          enum stitching-rt {
            tailf:info "Advertise re-originated routes with stitching Route-Targets";
          }
        }
      }
    }

    // router bgp * / address-family * / advertise * local
    container local {
      tailf:info "Advertisement of local routes";
      tailf:cli-delete-when-empty;
      presence true;
      leaf route-target {
        tailf:cli-drop-node-name;
        type enumeration {
          enum regular-rt {
            tailf:info "Advertise re-originated routes with regular (non-stitching) Route-Targets";
          }
          enum stitching-rt {
            tailf:info "Advertise re-originated routes with stitching Route-Targets";
          }
        }
      }
    }

    // router bgp * / address-family * / advertise * disable
    leaf disable {
      tailf:info "Disable Advertisement of selected SAFI";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / address-family * / advertise * imported-from-vrf
    container imported-from-vrf {
      tailf:info "VRF extranet imported routes";
      leaf disable {
        tailf:info "Disable advertisement of VRF extranet imported routes";
        type empty;
      }
    }

    // router bgp * / address-family * / advertise * imported-from-default-vrf
    container imported-from-default-vrf {
      tailf:info "Default VRF imported routes";
      leaf disable {
        tailf:info "Disable advertisement of default VRF imported routes";
        type empty;
      }
    }
  }


  grouping controller-dwdm-grouping {

    // controller dwdm *
    list dwdm {
      tailf:info "DWDM controller(s)";
      tailf:cli-allow-join-with-key;
      key id;
      leaf id {
        type string {
          tailf:info "dwdm Interface Instance";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }

      // controller dwdm * / description
      uses description-grouping;

      // controller dwdm * / proactive
      leaf proactive {
        tailf:info "Enable Proactive Protection Feature";
        tailf:cli-full-command;
        type empty;
      }

      // controller dwdm * / proactive X
      container proactive-conf {
        tailf:cli-drop-node-name;
        container proactive {
          tailf:info "Enable Proactive Protection Feature";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;

          // controller dwdm * / proactive revert
          container revert {
            tailf:info "Configure Revert thresholds";

            // controller dwdm * / proactive revert threshold
            container threshold {
              tailf:info "Set values x and y of xE-y";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf x-coefficient {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-9>;;Bit error rate coefficient (x of xE-y) (Revert threshold cannot be > 1E-3";
                  range "1..9";
                }
              }
              leaf y-power {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<3-10>;;Bit error rate power (y of xE-y) (Revert threshold cannot be > 1E-3)";
                  range "3..10";
                }
              }
            }

            // controller dwdm * / proactive revert window
            leaf window {
              tailf:info "Number of times threshold crossing is tested";
              type uint32 {
                tailf:info "<500-100000>;;Integration window for FRR revert in MS";
                range "500..100000";
              }
            }
          }

          // controller dwdm * / proactive trigger
          container trigger {
            tailf:info "Configure trigger threshold";

            // controller dwdm * / proactive trigger threshold
            container threshold {
              tailf:info "Set values x and y of xE-y";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf x-coefficient {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-9>  Bit error rate coefficient (x of xE-y) (Trigger threshold cannot be > 1E-2)";
                  range "1..9";
                }
              }
              leaf y-power {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<2-9>;;Bit error rate power (y of xE-y) (Trigger threshold cannot be > 1E-3)";
                  range "2..9";
                }
              }
            }

            // controller dwdm * / proactive trigger window
            leaf window {
              tailf:info "Number of times threshold crossing is tested";
              type uint32 {
                tailf:info "<10-10000>;;Integration window for FRR trigger in MS";
                range "10..10000";
              }
            }
          }
        }
      }

      // controller dwdm * / g709
      container g709 {
        tailf:info "Configure G709 parameters";

        // controller dwdm * / g709 enable
        leaf enable {
          tailf:info "Enable G709 function";
          tailf:cli-full-command;
          type empty;
        }

        // controller dwdm * / g709 fec
        container fec {
          tailf:info "Configure FEC mode";
          choice fec-choice {
            leaf ci-bch {
              tailf:info "Continuously Interleaved BCH FEC";
              tailf:cli-full-command;
              type empty;
            }
            leaf disable {
              tailf:info "Disable FEC";
              tailf:cli-full-command;
              type empty;
            }
            leaf enhanced {
              tailf:info "Enhanced FEC mode";
              type enumeration {
                enum "i.4" {
                  tailf:info "efec i.4";
                }
                enum "i.7" {
                  tailf:info "efec i.7";
                }
              }
            }
            leaf high-gain-hd-fec {
              tailf:info "7% HD FEC (Staircase FEC)";
              type empty;
            }
            leaf high-gain-multivendor-hd-fec {
              tailf:info "7% HD FEC (Staircase FEC) Multivendor Interoperable";
              type empty;
            }
            leaf high-gain-sd-fec {
              tailf:info "7% CISCO SD FEC (Etna Soft-Decision FEC)";
              type empty;
            }
            leaf long-haul-hd-fec {
              tailf:info "20% HD FEC (Staircase FEC)";
              type empty;
            }
            leaf long-haul-sd-fec {
              tailf:info "20% CISCO SD FEC (Etna Soft-Decision FEC)";
              type empty;
            }
            leaf standard {
              tailf:info "Standard FEC mode";
              type empty;
            }
          }
        }

        // controller dwdm * / g709 framing
        leaf framing {
          tailf:info "Configure Framing mode";
          type enumeration {
            enum "opu1e" {
              tailf:info "opu1e framing mode";
            }
            enum "opu2e" {
              tailf:info "opu2e framing mode";
            }
          }
        }

        // controller dwdm * / g709 odu
        container odu {
          tailf:info "Configure ODU parameters";

          // controller dwdm * / g709 otu overhead tti
          container overhead {
            tailf:info "Configure ODU overhead";
            container tti {
              tailf:info "Configure ODU Trail Trace Identifier buffer";

              // controller dwdm * / g709 otu overhead tti expected
              container expected {
                tailf:info "Set expected TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }

              // controller dwdm * / g709 otu overhead tti sent
              container sent {
                tailf:info "Set transmit TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }
            }
          }
        }

        // controller dwdm * / g709 otu
        container otu {
          tailf:info "Configure OTU parameters";

          // controller dwdm * / g709 otu overhead
          container overhead {
            tailf:info "Configure OTU overhead";
            container tti {
              tailf:info "Configure OTU Trail Trace Identifier buffer";

              // controller dwdm * / g709 otu overhead tti expected
              container expected {
                tailf:info "Set expected TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }

              // controller dwdm * / g709 otu overhead tti sent
              container sent {
                tailf:info "Set transmit TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }
            }
          }

          // controller dwdm * / g709 otu threshold
          container threshold {
            tailf:info "Configure OTU threshold value";

            // controller dwdm * / g709 otu threshold prefec-sd-ber
            leaf prefec-sd-ber {
              tailf:info "Set PreFec Signal Degrate BER threshold";
              type uint8 {
                tailf:info "<2-9>;;Bit error rate (10 to the minus n) (default 6)";
                range "2..9";
              }
            }

            // controller dwdm * / g709 otu threshold prefec-sf-ber
            leaf prefec-sf-ber {
              tailf:info "Set PreFec Signal fail BER threshold";
              type uint8 {
                tailf:info "<2-9>;;Bit error rate (10 to the minus n) (default 4)";
                range "2..9";
              }
            }

            // controller dwdm * / g709 otu threshold sd-ber
            leaf sd-ber {
              tailf:info "Set Signal Degrade BER threshold";
              type uint8 {
                tailf:info "<1-9>;;Bit error rate (10 to the minus n) (default 6)";
                range "1..9";
              }
            }

            // controller dwdm * / g709 otu threshold sf-ber
            leaf sf-ber {
              tailf:info "Set Signal Failure BER threshold";
              type uint8 {
                tailf:info "<1-9>;;Bit error rate (10 to the minus n)";
                range "1..9";
              }
            }
          }
        }

        // controller dwdm * / g709 tti-processing
        leaf tti-processing {
          tailf:info "Enable Trail Trace Identifier processing";
          tailf:cli-full-command;
          type empty;
        }
      }

      // controller dwdm * / loopback
      leaf loopback {
        tailf:info "Configure loopback mode";
        tailf:cli-full-command;
        type enumeration {
          enum "internal" {
            tailf:info "Select internal loopback mode";
          }
          enum "line" {
            tailf:info "Select line loopback mode";
          }
        }
      }

      // controller dwdm * / wavelength
      container wavelength {
        tailf:info "Configure ITU Channel, Wavelength and Frequency";
        choice wave-length-choice {
          leaf channel-number {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;Select an ITU channel number; C Band: 1-89";
              range "1..100";
            }
          }
          // controller dwdm * / wavelength frequency
          leaf frequency {
            tailf:info "Configure Frequency and Map to ITU Channel";
            type uint16 {
              tailf:info "<19115-19610>;;Enter 5-digit Frequency data; e.g. 19580 for 195.8 THz";
              range "19115..19610";
            }
          }
          // controller dwdm * / wavelength 100MHz-Grid
          container hundred-Grid {
            tailf:alt-name "100MHz-Grid";
            tailf:info "Specify frequency directly instead of wave channel numbers";
            leaf frequency {
              tailf:info "Configure frequency in steps of 100MHz";
              type string {
                tailf:info "WORD;;Enter Frequency Data in THz (e.g. 195.7314)";
              }
            }
          }
          // controller dwdm * / wavelength 50GHz-Grid
          container fifty-Grid {
            tailf:alt-name "50GHz-Grid";
            tailf:info "Configure Wavelength / Frequency / Channel Number";
            choice config-choice {
              leaf itu-ch {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-100>;;Select an ITU channel number; C Band: 1-100";
                range "1..100";
                }
              }
              leaf frequency {
                tailf:info "Configure Frequency and Map to ITU Channel";
                type uint16 {
                  tailf:info "<19115-19610>;;Enter 5-digit Frequency data; e.g. 19580 for 195.8 THz";
                  range "19115..19610";
                }
              }
              leaf update {
                tailf:info "Configure Wavelength and Map to ITU Channel";
                type uint32 {
                  tailf:info "<1528773-1568362>;;Enter 7-digit Wavelength data; e.g. 1532290 for 1532.29 nm";
                  range "1528773..1568362";
                }
              }
            }
          }
        }
      }

      // controller dwdm * / admin-state
      leaf admin-state {
        tailf:info "Configure the transport admin state of the controller";
        type enumeration {
          enum in-service {
            tailf:info "change the admin-state to In-service (IS)";
          }
          enum maintenance {
            tailf:info "change the admin-state to Out-of-service-Maintenance (OOS-MT)";
          }
          enum out-of-service {
            tailf:info "change the admin-state to Out-of-service (OOS)";
          }
          enum in-service-config-allowed {
            tailf:info "change the admin-state to In-service-config-allowed (IS-CFG)";
          }
        }
      }

      // controller dwdm * / transmit-power
      leaf transmit-power {
        tailf:info "Configure transponder transmit power ";
        tailf:cli-full-command;
        type int16 {
          tailf:info "<-190,+10>;;Select power level (in units of 0.1dBm)";
          range "-190..10";
        }
      }
    }
  }


  // controller *
  // controller preconfigure *
  grouping controller-grouping {

    // controller dwdm *
    uses controller-dwdm-grouping;

    // controller MgmtMultilink *
    list MgmtMultilink {
      tailf:info "Controller for the management of multilink interfacess";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-mgmtmultilink";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      // controller MgmtMultilink * / bundle *
      list bundle {
        tailf:info "Configure a multilink bundle interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-999999999>;;Bundle Id";
          }
        }
      }
    }

    // controller T1 *
    list T1 {
      tailf:info "T1 Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-t1";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }

      // controller T1 * / description
      uses description-grouping;

      // controller T1 * / mode
      leaf mode {
        tailf:info "Configure mode for the port";
        type enumeration {
          enum atm {
            tailf:info "clear channel carrying atm";
          }
        }
      }

      // controller T1 * / framing
      leaf framing {
        tailf:info "Configure T1E1 framing";
        type enumeration {
          enum esf {
            tailf:info "esf framing: default";
          }
          enum sf {
            tailf:info "sf framing mode";
          }
        }
      }

      // controller T1 * / linecode
      leaf linecode {
        tailf:info "Specify the line encoding method for a DS1 link";
        tailf:cli-full-command;
        type enumeration {
          enum ami {
            tailf:info "AMI encoding";
          }
          enum b8zs {
            tailf:info "B8ZS encoding";
          }
        }
      }

      // controller T1 * / carrier-delay
      container carrier-delay {
        tailf:info "Set the carrier delay on a T1/E1 controller";
        choice carrier-delay-choice {
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-60>;;Carrier Transitions delay in seconds";
              range "0..60";
            }
          }
          leaf msec {
            tailf:info "Set time in milliseconds";
            type uint16 {
              tailf:info "<0-1000>;;Carrier Transitions delay in milliseconds";
              range "0..1000";
            }
          }
        }
      }

      // controller T1 * / channel-group *
      list channel-group {
        tailf:info "Configure channel group on T1E1";
        tailf:cli-mode-name "config-t1-channel_group";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-23>;;channel group number";
            range "0..23";
          }
        }
        // controller T1 * / channel-group * / speed
        leaf speed {
          tailf:info "speed of the ds0 channel";
          tailf:cli-full-command;
          type enumeration {
            enum "56" {
              tailf:info "56 Kbits";
            }
            enum "64" {
              tailf:info "64 Kbits";
            }
          }
        }
        // controller T1 * / channel-group * / timeslots
        leaf timeslots {
          tailf:info "List of timeslots in the channel group";
          type string {
            tailf:info "WORD;;timeslot string seprated by (:) or (-) "+
              "from 1 to 24. (:) indicates individual timeslot and (-) "+
              "represent range";
          }
        }
      }

      // controller T1 * / clock
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t1/e1  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
          }
        }
      }

      // controller T1 * / bert
      container bert {
        tailf:info "Configure BERT parameters";

        // controller T1 * / bert / error
        leaf error {
          tailf:info "Insert errors into BERT bit stream";
          tailf:cli-full-command;
          type uint8{
            tailf:info "<1-255>;;Number of errors to generate";
            range "1..255";
          }
        }

        // controller T1 * / bert / interval
        leaf interval {
          tailf:info "Duration of BERT in minutes";
          tailf:cli-full-command;
          type uint16{
            tailf:info "<1-1440>;;Duration of BERT in minutes";
            range "1..1440";
          }
        }

        // controller T1 * / bert / pattern
        leaf "pattern" {
          tailf:info "BERT pattern";
          tailf:cli-full-command;
          type enumeration {
            enum "0s" {
              tailf:info "All 0's test pattern";
            }
            enum "1in8" {
              tailf:info "1 in 8 test pattern";
            }
            enum "1s" {
              tailf:info "All 1's test pattern";
            }
            enum "2e11" {
              tailf:info "2^11-1 O.150 test pattern";
            }
            enum "2e15" {
              tailf:info "2^15-1 O.151 test pattern";
            }
            enum "2e20" {
              tailf:info "2^20-1 O.153 test pattern";
            }
            enum "2e20-QRSS" {
              tailf:info "2^20-1 QRSS O.151 test pattern";
            }
            enum "2e23" {
              tailf:info "2^23-1 O.151 test pattern";
            }
            enum "2e9" {
              tailf:info "2^9-1 O.150 test pattern";
            }
            enum "3in24" {
              tailf:info "3 in 24 test pattern";
            }
            enum "55Daly" {
              tailf:info "55 Daly test pattern";
            }
            enum "55Octet" {
              tailf:info "55 Octect test pattern";
            }
            enum "alt-0-1" {
              tailf:info "Alternating 0's and 1's test pattern";
            }
          }
        }
      }

      // controller T1 * / shutdown
      leaf shutdown {
        // Note: default to "no shutdown" in order to be able to bring if up.
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }

      // controller T1 * / loopback
      container loopback {
        tailf:info "Configure T1 loopback mode";

        // controller T1 * / loopback / local
        leaf local {
          tailf:cli-full-command;
          tailf:info "Put near end in local loopback";
          type empty;
        }

        // controller T1 * / loopback / network
        leaf network {
          tailf:info "Network loopback";
          tailf:cli-full-command;
          type enumeration {
            enum "line" {
              tailf:info "Put line network loopback";
            }
            enum "payload" {
              tailf:info "Put payload network loopback";
            }
          }
        }

        // controller T1 * / loopback / remote
        container remote {
          tailf:info "Remote loopback (put far end in loopback)";
          tailf:cli-compact-syntax;
          choice line-payload {
            // controller T1 * / loopback / remote / line
            container line {
              tailf:info "Put far end line loop";
              leaf fdl {
                tailf:info "loopback using fdl";
                tailf:cli-full-command;
                type enumeration {
                  enum "ansi" {
                    tailf:info "loopback using ansi fdl";
                  }
                  enum "bellcore" {
                    tailf:info "loopback using Bellcore fdl (SmartJack loopback)";
                  }
                }
              }
              leaf inband {
                tailf:info "loopback using inband code";
                tailf:cli-full-command;
                type empty;
              }
            }
            // controller T1 * / loopback / remote / payload
            container payload {
              tailf:info "Put far end payload loop";
              leaf fdl {
                tailf:info "loopback using fdl";
                tailf:cli-full-command;
                type enumeration {
                  enum "ansi" {
                    tailf:info "loopback using ansi fdl";
                  }
                }
              }
            }
          }
        }
      }
    }

    // controller T3 *
    list T3 {
      tailf:info "T3 Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-t3";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }

      // controller T3 * / description
      uses description-grouping;

      // controller T3 * / mode
      leaf mode {
        tailf:info "Configure mode for the port";
        tailf:cli-full-command;
        type enumeration {
          enum atm {
            tailf:info "clear channel carrying atm";
          }
          enum e1 {
            tailf:info "channelize into 21 E1s";
          }
          enum serial {
            tailf:info "clear channel carrying hdlc like payload";
          }
          enum t1 {
            tailf:info "channelized into 28 T1s";
          }
        }
      }

      // controller T3 * / dsu
      container dsu {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-t3-dsu";

        // controller T3 * / dsu / bandwidth
        leaf bandwidth {
          tailf:info "Configure DSU bandwidth";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<75-44210>;;DSU subrate bandwidth range";
            range "75..44210";
          }
        }
        // controller T3 * / dsu / mode
        leaf mode {
          tailf:info "Configure DSU mode";
          tailf:cli-full-command;
          type enumeration {
            enum "adtran" {
              tailf:info "Set DSU mode to Adtran";
            }
            enum "digital-link" {
              tailf:info "Set DSU mode to Digital link";
            }
            enum "kentrox" {
              tailf:info "Set DSU mode to Kentrox";
            }
            enum "larscom" {
              tailf:info "Set DSU mode to Larscom";
            }
            enum "verilink" {
              tailf:info "Set DSU mode to Verilink";
            }
          }
        }
        // controller T3 * / dsu / remote
        leaf remote {
          tailf:info "Specify commands associated with the remote end";
          tailf:cli-full-command;
          type enumeration {
            enum "disable" {
              tailf:info "Deny incoming remote requests to reset bandwidth "+
              "to fullrate";
            }
            enum "fullrate" {
              tailf:info "Request that the farend set its bandwidth "+
              "to fullrate";
            }
          }
        }
      }

      // controller T3 * / framing
      leaf framing {
        tailf:info "Configure T3/E3 framing";
        type enumeration {
          enum auto-detect {
            tailf:info "Application Identification Channel Signal";
          }
          enum c-bit {
            tailf:info "C-bit framing (T3 default)";
          }
          enum m23 {
            tailf:info "M23 Framing Format";
          }
        }
      }

      // controller T3 * / delay
      container delay {
        leaf trigger {
          tailf:info "trigger time";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-60000>;;time in msec to soak before declaring the alarm";
            range "0..60000";
          }
        }
      }

      // controller T3 * / cablelength
      leaf cablelength {
        tailf:info "Length of the T3/E3 cable in feet";
        type uint16 {
          tailf:info "<0-450>;;Length of the cable in feet";
          range "0..450";
        }
      }

      // controller T3 * / clock
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t3/e3  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
          }
        }
      }

      // controller T3 * / bert
      container bert {
        tailf:info "Configure BERT parameters";

        // controller T3 * / bert / error
        leaf error {
          tailf:info "Insert errors into BERT bit stream";
          tailf:cli-full-command;
          type uint8{
            tailf:info "<1-255>;;Number of errors to generate";
            range "1..255";
          }
        }

        // controller T3 * / bert / interval
        leaf interval {
          tailf:info "Duration of BERT in minutes";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-1440>;;Duration of BERT in minutes";
            range "1..1440";
          }
        }

        // controller T3 * / bert / pattern
        leaf "pattern" {
          tailf:info "BERT pattern";
          tailf:cli-full-command;
          type enumeration {
            enum "0s" {
              tailf:info "All 0's test pattern";
            }
            enum "1in8" {
              tailf:info "1 in 8 test pattern";
            }
            enum "1s" {
              tailf:info "All 1's test pattern";
            }
            enum "2e11" {
              tailf:info "2^11-1 O.150 test pattern";
            }
            enum "2e15" {
              tailf:info "2^15-1 O.151 test pattern";
            }
            enum "2e20" {
              tailf:info "2^20-1 O.153 test pattern";
            }
            enum "2e20-QRSS" {
              tailf:info "2^20-1 QRSS O.151 test pattern";
            }
            enum "2e23" {
              tailf:info "2^23-1 O.151 test pattern";
            }
            enum "2e9" {
              tailf:info "2^9-1 O.150 test pattern";
            }
            enum "3in24" {
              tailf:info "3 in 24 test pattern";
            }
            enum "55Daly" {
              tailf:info "55 Daly test pattern";
            }
            enum "55Octet" {
              tailf:info "55 Octect test pattern";
            }
            enum "alt-0-1" {
              tailf:info "Alternating 0's and 1's test pattern";
            }
          }
        }
      }

      // controller T3 * / shutdown
      leaf shutdown {
        // Note: default to "no shutdown" in order to be able to bring if up.
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }

      // controller T3 * / loopback
      container loopback {
        tailf:info "Configure T3 loopback mode";

        // controller T3 * / loopback / local
        leaf local {
          tailf:info "Put near end in local loopback";
          tailf:cli-full-command;
          type empty;
        }

        // controller T3 * / loopback / network
        leaf network {
          tailf:info "Put near end in network loopback";
          tailf:cli-full-command;
          type enumeration {
            enum "line" {
              tailf:info "Put line network loopback";
            }
            enum "payload" {
              tailf:info "Put payload network loopback";
            }
          }
        }

        // controller T3 * / loopback / remote
        leaf remote {
          tailf:info "Remote loopback (put far end in loopback by sending FEAC)";
          tailf:cli-full-command;
          type enumeration {
            enum "line" {
              tailf:info "Remote line loopback";
            }
            enum "payload" {
              tailf:info "Remote payload loopback";
            }
          }
        }
      }
    }

    // controller E1 *
    list E1 {
      tailf:info "E1 Port controller(s)";
      tailf:cli-mode-name "config-e1";
      key name;
      leaf name {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port"+
            "format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }

      // controller E1 * / description
      uses description-grouping;

      // controller E1 * / cem-group
      container cem-group {
        tailf:info "Configure CEM interface on T1/E1";

        // controller E1 * / cem-group unframed
        leaf unframed {
          tailf:info "Configure a unframed CEM interface on T1/E1";
          type empty;
        }

        // controller E1 * / cem-group framed *
        list framed {
          tailf:info "Configure a framed CEM interface on T1/E1";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<0-30>;;CEM group number";
            }
          }
          leaf timeslots {
            tailf:info "List of timeslots in the CEM group";
            type string {
              tailf:info "WORD;;timeslot string seprated by (:) or (-) from 1 to 31. "+
                "(:) indicates individual timeslot and (-) represent range";
            }
          }
        }
      }

      // controller E1 * / framing
      leaf framing {
        tailf:info "Configure T1E1 framing";
        type enumeration {
          enum crc4 {
            tailf:info "E1 with CRC: default";
          }
          enum no-crc4 {
            tailf:info "E1";
          }
          enum unframed {
            tailf:info "unframed";
          }
        }
      }

      // controller E1 * / linecode
      leaf linecode {
        tailf:info "Specify the line encoding method for a DS1 link";
        tailf:cli-full-command;
        type enumeration {
          enum ami {
            tailf:info "AMI encoding";
          }
          enum hdb3 {
            tailf:info "high-density bipolar 3";
          }
        }
      }

      // controller E1 * / channel-group *
      list channel-group {
        tailf:info "Configure channel group on T1E1";
        tailf:cli-mode-name "config-e1-channel_group";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-30>;;channel group number";
            range "0..30";
          }
        }

        // controller E1 * / channel-group * / timeslots
        leaf timeslots {
          tailf:info "List of timeslots in the channel group";
          type string {
            tailf:info "WORD;;timeslot string seprated by (:) or (-) "+
              "from 1 to 31. (:) indicates individual timeslot and (-) "+
              "represent range";
          }
        }
      }

       // controller E1 * / down-when-looped
      leaf down-when-looped {
        tailf:info "Configure t1e1 controller into down-when-looped mode";
        type empty;
      }

      // controller E1 * / clock source
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t1/e1  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
            leaf recovered {
              tailf:info "Select Recovered clock";
              type uint8 {
                tailf:info "<0-23>;;Clock number";
                range "0..23";
              }
            }
          }
        }
      }

      // controller E1 * / shutdown
      leaf shutdown {
        // Note: default to "no shutdown" in order to be able to bring if up.
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
    }

    // controller E3 *
    list E3 {
      tailf:info "E3 Port controller(s)";
      tailf:cli-mode-name "config-e3";
      key name;
      leaf name {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }

      // controller E3 * / description
      uses description-grouping;

      // controller E3 * / mode
      leaf mode {
        tailf:info "Configure mode for the port";
        tailf:cli-full-command;
        type enumeration {
          enum atm {
            tailf:info "clear channel carrying atm";
          }
          enum e1 {
            tailf:info "channelize into 21 E1s";
          }
          enum serial {
            tailf:info "clear channel carrying hdlc like payload";
          }
          enum t1 {
            tailf:info "channelized into 28 T1s";
          }
        }
      }

      // controller E3 * / framing
      leaf framing {
        tailf:info "Configure T3/E3 framing";
        tailf:cli-full-command;
        type enumeration {
          enum g751 {
            tailf:info "E3 Framing G.751 (E3 default)";
          }
          enum g832 {
            tailf:info "E3 Framing G.832";
          }
        }
      }

      // controller E3 * / dsu
      container dsu {
        tailf:info "Configure T3/E3 subrate(dsu)";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-e3-dsu";

        // controller E3 * / dsu / mode
        leaf mode {
          tailf:info "Configure DSU mode";
          type enumeration {
            enum cisco {
              tailf:info "Set DSU mode to Cisco";
            }
            enum digital-link {
              tailf:info "Set DSU mode to Digital link";
            }
            enum kentrox {
              tailf:info "Set DSU mode to Kentrox";
            }
          }
        }

        // controller E3 * / dsu / bandwidth
        leaf bandwidth {
          tailf:info "Configure DSU bandwidth";
          type uint16 {
            tailf:info "<300-34010>;;DSU subrate bandwidth range";
            range "300..34010";
          }
        }
      }

      // controller E3 * / down-when-looped
      leaf down-when-looped {
        tailf:info "Configure T3/E3 controller into down-when-looped mode";
        tailf:cli-full-command;
        type empty;
      }

      // controller E3 * / clock source
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t3/e3  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
            leaf recovered {
              tailf:info "Select Recovered clock";
              type uint8 {
                tailf:info "<0-23>;;Clock number";
                range "0..23";
              }
            }
          }
        }
      }

      // controller E3 * / shutdown
      leaf shutdown {
        // Note: default to "no shutdown" in order to be able to bring if up.
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
    }

    // controller SONET *
    list SONET {
      tailf:info "SONET/SDH Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-sonet";
      key id;
      leaf id {
        tailf:cli-case-insensitive;
        type string {
          tailf:info "WORD;;SONET Interface Instance";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }

      // controller SONET * / description
      uses description-grouping;

      // controller SONET * / ais-shut
      leaf ais-shut {
        tailf:info "Enable sending SONET/SDH LAIS when shutdown";
        tailf:cli-full-command;
        type empty;
      }

      // controller SONET * / line
      container line {
        tailf:info "Configure SONET/SDH line parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-sonet-line";

        // controller SONET * / line / delay
        container delay {
          tailf:info "alarm soaking";

          // controller SONET * / line / delay clear
          leaf clear {
            tailf:info "clear time";
            type uint32 {
              tailf:info "<1000-180000>;;Time in msec to soak before clearing the alarm (Default 10 seconds)";
              range "1000..180000";
            }
          }

          // controller SONET * / line / delay trigger
          leaf trigger {
            tailf:info "trigger time";
            type uint16 {
              tailf:info "<0-60000>;;Time in msec to soak before declaring "+
                "the alarm (Default No Delay)";
              range "0..60000";
            }
          }
        }
      }

      // controller SONET * / path
      container "path" {
        tailf:info "Configure SONET/SDH path parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-sonet-path";

        // controller SONET * / path / report
        container report {
          tailf:info "Configure SONET/SDH path alarm reporting";

          // controller SONET * / path / report pais
          leaf pais {
            tailf:info "Set Path Alarm Indication Signal reporting status";
            type empty;
          }

          // controller SONET * / path / report prdi
          leaf prdi {
            tailf:info "Set Path Remote Defect Indication reporting status";
            type empty;
          }
        }

        // controller SONET * / path / ais-shut
        leaf ais-shut {
          tailf:info "Enable sending SONET/SDH PAIS when shutdown";
          type empty;
        }

        // controller SONET * / path / delay
        container delay {
          tailf:info "alarm soaking";

          // controller SONET * / path / delay trigger
          leaf clear {
            tailf:info "clear time";
            type uint32 {
              tailf:info "<1000-180000>;;Time in msec to soak before clearing the alarm (Default 10 seconds)";
              range "1000..180000";
            }
          }

          // controller SONET * / path / delay trigger
          leaf trigger {
            tailf:info "trigger time";
            type uint16 {
              tailf:info "<0-60000>;;Time in msec to soak before declaring "+
                "the alarm (Default No Delay)";
              range "0..60000";
            }
          }
        }

        // controller SONET * / path / scrambling
        leaf scrambling {
          tailf:info "Configure SONET/SDH SPE scrambling";
          type enumeration {
            enum disable;
            enum enable;
          }
        }

        // controller SONET * / path / threshold b3-tca
        container threshold {
          tailf:info "Configure SONET/SDH path BER threshold values";
          leaf b3-tca {
            tailf:info "Set B3 BER Threshold Crossing Alert (TCA) threshold";
            type uint8 {
              tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            }
          }
        }
      }

      // controller SONET * / framing
      leaf framing {
        tailf:info "Configure SONET/SDH framing";
        tailf:cli-full-command;
        type enumeration {
          enum sdh {
            tailf:info "Select SDH framing";
          }
          enum sonet {
            tailf:info "Select SONET framing (default)";
          }
        }
      }

      // controller SONET * / report
      container report {
        tailf:info "Configure SONET/SDH section/line alarm reporting";

        // controller SONET * / report lais
        leaf lais {
          tailf:info "Set Line Alarm Indication Signal reporting status";
          type empty;
        }

        // controller SONET * / report sd-ber
        leaf sd-ber {
          tailf:info "Set LBIP BER in excess of SD threshold reporting status";
          type empty;
        }
      }

      // controller SONET * / overhead
      container overhead {
        tailf:info "Configure SONET/SDH SOH/LOH byte/bit values";
        // controller SONET * / overhead j0
        leaf j0 {
          tailf:info "Specify STS identifier (J0/C1) byte";
          type uint8 {
            tailf:info "<0-255>;;J0/C1 byte value (default 0x01)";
            range "0..255";
          }
        }
        // controller SONET * / overhead s1s0
        leaf s1s0 {
          tailf:info "Specify bits s1 and s0 of H1 byte";
          type uint8 {
            tailf:info "<0-3>;;s1 & s0 bits value (default 0x0)";
            range "0..3";
          }
        }
      }

      // controller SONET * / sts *
      list sts {
        tailf:info "Configure SONET path parameters";
        tailf:cli-mode-name "config-stsPath";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-48>;;Possible range is 1-3 for OC3, 1-12 for OC12.";
          }
        }

        // controller SONET * / sts * / width
        leaf width {
          tailf:info "Configure width for the path";
          type uint16 {
            tailf:info "<1-768>;;Valid width(1,3,12,48..), natural "+
              "sts boundaries(1,4,7,10,13..)";
            range "1..768";
          }
        }

        // controller SONET * / sts * / mode
        container mode {
          tailf:info "Configure mode for the path";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf carrying {
            tailf:cli-drop-node-name;
            type enumeration {
              enum atm {
                tailf:info "clear channel carrying atm";
              }
              enum pos {
                tailf:info "Configure pos mode for the path";
              }
              enum t3 {
                tailf:info "sonet path carrying T3";
              }
              enum vt15 {
                tailf:info "sonet path carrying VT15";
              }
              enum vt15-t1 {
                tailf:info "sonet path carrying VT15 T1";
              }
              enum vt2 {
                tailf:info "sonet path carrying VT2";
              }
            }
          }
          leaf pos-option {
            tailf:cli-drop-node-name;
            when "../carrying = 'pos'";
            type enumeration {
              enum scramble {
                tailf:info "clear channel carrying POS scramble";
              }
              enum unscramble {
                tailf:info "clear channel carrying POS unscramble";
              }
            }
          }
        }

        // controller SONET * / sts * / delay trigger
        container delay {
          tailf:info "alarm soaking";
          leaf trigger {
            tailf:info "trigger time";
            type uint16 {
              tailf:info "<0-60000>;;Time in msec to soak before declaring "+
                "the alarm (Default No Delay)";
              range "0..60000";
            }
          }
        }
      }

      // controller SONET * / threshold
      container threshold {
        tailf:info "Configure SONET/SDH section/line BER threshold values";

        // controller SONET * / threshold sf-ber
        leaf sf-ber {
          tailf:info "Set Signal Fail BER threshold";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 3)";
            range "3..9";
          }
        }

        // controller SONET * / threshold b1-tca
        leaf b1-tca {
          tailf:info "Set B1 BER Threshold Crossing Alert (TCA) threshold";
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            range "3..9";
          }
        }

        // controller SONET * / threshold b2-tca
        leaf b2-tca {
          tailf:info "Set B2 BER Threshold Crossing Alert (TCA) threshold";
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            range "3..9";
          }
        }
      }

      // controller SONET * / down-when-looped
      leaf down-when-looped {
        tailf:info "Configure SONET/SDH controller into down-when-looped mode";
        type empty;
      }

      // controller SONET * / au *
      list au {
        tailf:info "Configure SDH path parameters";
        tailf:cli-mode-name "config-auPath";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-48>;;au3 or au4 path range";
            range "1..48";
          }
        }

        // controller SONET * / au * / width
        leaf width {
          tailf:info "Configure width for the path";
          type uint16 {
            tailf:info "<1-768>;;Valid width(1,3,12,48..), "+
              "natural au boundaries(1,4,7,10,13..)";
            range "1..768";
          }
        }

        // controller SONET * / au * / mode
        container mode {
          tailf:info "Configure mode for the au path";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf carrying {
            tailf:cli-drop-node-name;
            type enumeration {
              enum atm {
                tailf:info "clear channel carrying atm";
              }
              enum c11 {
                tailf:info "au3 path carrying c11";
              }
              enum c11-t1 {
                tailf:info "au3 path carrying c11 t1";
              }
              enum c12 {
                tailf:info "au3 path carrying c12";
              }
              enum c12-e1 {
                tailf:info "au3 path carrying c12 e1";
              }
              enum e3 {
                tailf:info "au3 path carrying E3";
              }
              enum pos {
                tailf:info "Configure pos mode for au path";
              }
              enum t3 {
                tailf:info "au3 path carrying T3";
              }
              enum tug3 {
                tailf:info "au4 path carries TUG3";
              }
            }
          }
          leaf pos-option {
            tailf:cli-drop-node-name;
            when "../carrying = 'pos'";
            type enumeration {
              enum scramble {
                tailf:info "clear channel carrying POS scramble";
              }
              enum unscramble {
                tailf:info "clear channel carrying POS unscramble";
              }
            }
          }
        }

        // controller SONET * / au * / tug3 *
        list tug3 {
          tailf:info "Configure tug3 path parameters";
          tailf:cli-mode-name "config-tug3Path";
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-3>;;tug3 number range";
              range "1..3";
            }
          }

          // controller SONET * / au * / tug3 * / mode
          container mode {
            tailf:info "Configure mode for the tug3 path";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf carrying {
              tailf:cli-drop-node-name;
              type enumeration {
                enum c11 {
                  tailf:info "tug3 path carrying TU-11";
                }
                enum c11-t1 {
                  tailf:info "tug3 path carrying TU-11 to t1";
                }
                enum c12 {
                  tailf:info "tug3 path carrying TU-12";
                }
                enum c12-e1 {
                  tailf:info "tug3 path carrying TU-12 to e1";
                }
                enum e3 {
                  tailf:info "au3 or all tug3 path carrying E3";
                }
                enum t3 {
                  tailf:info "au3 or all tug3 path carrying T3";
                }
              }
            }
          }
        }
      }

      // controller SONET * / clock source
      container clock {
        tailf:info "Configure SONET/SDH port clock";
        leaf source {
          tailf:info "Configure SONET/SDH port TX clock source";
          type enumeration {
            enum internal {
              tailf:info "Select internal clock";
            }
            enum line {
              tailf:info "Select clock recovered from line (default)";
            }
          }
        }
      }

      // controller SONET * / s1byte ignore
      container s1byte {
        tailf:info "Configure SONET/SDH controller to s1byte ignore mode";
        leaf ignore {
          tailf:info "Ignore S1 byte";
          type empty;
        }
      }

      // controller SONET * / shutdown
      leaf shutdown {
        // Note: default to "no shutdown" in order to be able to bring if up.
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
    }

    // controller wanphy *
    list wanphy {
      tailf:info "WANPHY controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-wanphy";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }

      // controller wanphy * / lanmode on
      container lanmode {
        tailf:info "Configure Lan Mode On/Off";
        leaf on {
          tailf:info "Turn LanMode On";
          type empty;
        }
      }

      // controller wanphy * / wanmode on
      container wanmode {
        tailf:info "Configure Wan Mode On/Off";
        leaf on {
          tailf:info "Turn WanMode On";
          type empty;
        }
      }
    }

    // controller Optics *
    list Optics {
      tailf:info "OPTICS controller | short name is Op";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-Optics";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }

      // controller Optics * / shutdown
      leaf shutdown {
        tailf:info "Disable optics controller processing";
        type empty;
      }

      // controller Optics * / description
      uses description-grouping;

      // controller Optics * / transmit-power
      leaf transmit-power {
        tailf:info "Configure transponder transmit power ";
        tailf:cli-full-command;
        type int16 {
          tailf:info "<-190,+20>;;Select power level (in units of 0.1dBm)";
          range "-190..20";
        }
      }

      // controller Optics * / dwwm-carrier
      container dwdm-carrier {
        tailf:info "Configure the DWDM Carrier Channel";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf grid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "50GHz-grid" {
              tailf:info "Configure Wavelength in 50GHz grid";
            }
            enum "100MHz-grid" {
              tailf:info "Configure Wavelength in 100MHz Grid";
            }
          }
        }
        choice config-choice {
          leaf frequency {
            tailf:info "Configure Frequency";
            tailf:cli-break-sequence-commands;
            type uint32 {
              tailf:info "NUM;;Enter Frequency";
            }
          }
          leaf itu-ch {
            tailf:info "Configure the ITU 50GHz Grid ITU Channel";
            type uint8 {
              tailf:info "<1-100>;;Select an ITU channel number; C Band: 1-100";
              range "1..100";
            }
          }
          leaf wavelength {
            tailf:info "Configure Wavelength and Map to ITU Channel";
            type uint32 {
              tailf:info "<1528773-1568362>;;Enter 7-digit Wavelength data; e.g. 1532290 for 1532.29 nm";
              range "1528773..1568362";
            }
          }
        }
      }
    }
  }


  // extcommunity-set rt *
  // extcommunity-set soo *
  // rd-set *
  // prefix-set *
  // as-path-set *
  // community-set *
  grouping set-list-grouping {
    list set {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      //tailf:cli-show-obu-comments;
      ordered-by user;
      key "value";
      leaf "value" {
        tailf:cli-multi-word-key;
        tailf:cli-disallow-value "end-set|abort|exit";
        type string {
          tailf:info "WORD;;extcommunity-set line";
          pattern ".*[^,]";
        }
      }
    }
  }

  grouping ipsla-reaction-operation-react-grouping {

    // ipsla / reaction operation * / react rtt / action
    container action {
      tailf:info "Type of action to be taken on threshold violation(s)";

      // ipsla / reaction operation * / react rtt / action logging
      leaf logging {
        tailf:info "Generate a syslog alarm on threshold violation";
        type empty;
      }

      // ipsla / reaction operation * / react rtt / action trigger
      leaf trigger {
        tailf:info "Generate trigger to active reaction triggered operation(s)";
        type empty;
      }
    }

    // ipsla / reaction operation * / react rtt / threshold
    container threshold {
      tailf:info "Configure threshold parameters on monitored element";

      // ipsla / reaction operation * / react rtt / threshold type
      container "type" {
        tailf:info "Threshold type";

        choice type-choice {
          // ipsla / reaction operation * / react rtt / threshold type immediate
          leaf immediate {
            tailf:info "Take action immediately upon threshold violation";
            type empty;
          }

          // ipsla / reaction operation * / react rtt / threshold type consecutive
          leaf consecutive {
            tailf:info "Take action after a number of consecutive violations";
            type uint8 {
              tailf:info "<1-16>;;Number of consecutive violations";
              range "1..16";
            }
          }

          // ipsla / reaction operation * / react rtt / threshold type average
          leaf average {
          tailf:info "Take action on average values violate threshold";
          type uint8 {
            tailf:info "<1-16>;;Number of probes to average over";
            range "1..16";
          }
          }
        }
      }

      // ipsla / reaction operation * / react rtt / threshold lower-limit
      container limit {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf lower-limit {
          tailf:info "Threshold lower limit";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Threshold lower limit value";
            range "1..4294967295";
          }
        }
        leaf upper-limit {
          tailf:info "Threshold upper limit";
          type uint32 {
            tailf:info "<1-4294967295>;;Threshold upper limit value";
            range "1..4294967295";
          }
        }
      }
    }
  }

  grouping interface-tunnel-te-auto-bw-threshold-grouping {
    container threshold {
      tailf:info "Set the bandwidth change percent to trigger an underflow/overflow";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf percentage {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-100>;;Bandwidth change percent to trigger an overflow";
          range "1..100";
        }
      }
      leaf min {
        tailf:info "Set the bandwidth change value to trigger an "+
          "overflow";
        tailf:cli-optional-in-sequence;
        type uint32 {
          tailf:info "<10-4294967295>;;Bandwidth change value to "+
            "trigger an overflow (kbps)";
          range "10..4294967295";
        }
      }
      leaf limit {
        tailf:info "Set the number of consecutive collections "+
          "exceeding threshold";
        type uint8 {
          tailf:info "<1-10>;;Number of consecutive collections "+
            "exceeding threshold";
          range "1..10";
        }
      }
    }
  }


  grouping router-ospf-domain-id-grouping {
    leaf "type" {
      tailf:info "OSPF domain ID type in Hex format";
      tailf:cli-incomplete-command;
      type enumeration {
        enum "0005" {
          tailf:info "Type 0x0005";
        }
        enum "0105" {
          tailf:info "Type 0x0105";
        }
        enum "0205" {
          tailf:info "Type 0x0205";
        }
        enum "8005" {
          tailf:info "Type 0x8005";
        }
      }
    }
    leaf "value" {
      tailf:info "OSPF domain ID value in Hex format";
      type string {
        tailf:info "WORD;;OSPF domain ID ext. community value in Hex (6 octets)";
      }
    }
  }


  // explicit-path name * /
  // explicit-path identifier * /
  grouping explicit-path-index-list-grouping {
    list index {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key index-id;
      leaf index-id {
        type uint16 {
          tailf:info "<1-65535>;;Index number";
          range "1..65535";
        }
      }
      // explicit-path name * / index * next-address
      leaf keyword {
        tailf:cli-drop-node-name;
        type enumeration {
          enum exclude-address {
            tailf:info "Specify the next address to be excluded ";
          }
          enum exclude-srlg {
            tailf:info "Specify an IP Addr to get SRLGs from for exclusion";
          }
          enum next-address {
            tailf:info "Specify the next (adjacent) address in the path";
          }
          enum next-label {
            tailf:info "Specify the next (adjacent) address in the path";
          }
        }
      }
      // explicit-path name * / index * next-address loose
      // explicit-path name * / index * next-address strict
      leaf hop-type {
        when "../keyword = 'next-address'";
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        type enumeration {
          enum loose {
            tailf:info "Specify the next address in the path as a loose hop";
          }
          enum strict {
            tailf:info "Specify the next address in the path as a strict hop";
          }
        }
      }
      leaf label {
        when "../keyword = 'next-label'";
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        type uint32;
      }
      // explicit-path name * / index * ipv4 unicast
      container ipv4 {
        tailf:info "Specify the address AFI";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf unicast {
          tailf:info "Specify the address SAFI";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Enter IP address (A.B.C.D)";
          }
        }
      }
    }
  }


  // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / route-target *
  // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / route-target
  grouping route-target-import-export-grouping {
    container route-target {
      tailf:info "Route Target";

      // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / route-target *
      list route-target-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Two or Four Byte AS number or IP:nn";
          }
        }
      }

      // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / route-target import *
      leaf-list "import" {
        tailf:info "Import Route Target";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;AS-number or IPv4 address:index";
        }
      }

      // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / route-target export *
      leaf-list "export" {
        tailf:info "Export Route Target";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;AS-number or IPv4 address:index";
        }
      }
    }
  }


  // admin / username *
  // username *
  grouping username-grouping {
    list username {
      tailf:info "Configure user name";
      tailf:cli-mode-name "config-un";
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;User name";
        }
      }

      // username * / group *
      list group {
        tailf:info "User group in which this user will be a member of";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the user group";
          }
        }
      }

      // username * / password
      container password {
        tailf:info "Specify the password for the user";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf "encryption" {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum "7" {
              tailf:info "Specifies a HIDDEN password will follow";
            }
          }
        }
        leaf "password" {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;The HIDDEN user password string";
          }
        }
      }

      // username * / privilege
      leaf privilege {
        tailf:info "Set user privilege level";
        type uint8 {
          tailf:info "<0-15>;;User privilege level";
          range "0..15";
        }
      }

      // username * / secret
      container secret {
        tailf:info "Specify the secure password for the user";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf "encryption" {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum "5" {
              tailf:info "Specifies that an encrypted password will follow";
            }
          }
        }
        leaf password {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;The user password string";
          }
        }
      }
    }
  }

  // admin / clock
  // clock
  grouping clock-grouping {
    container clock {
      tailf:info "Configure time-of-day clock";
      tailf:cli-explicit-exit;

      leaf calendar-valid {
        tailf:info "Calendar time is authoritative";
        type empty;
      }
      container summer-time {
        tailf:info "Configure summer (daylight savings) time";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf zone {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;name of time zone in summer";
          }
        }
        choice summer {
          case a {
            container date {
              tailf:info "Configure absolute summer time";
            }
          }
          case b {
            leaf recurring {
              type empty;
            }
            leaf start {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<1-4>;;Week number to start";
                  range "1..4";
                }
                type enumeration {
                  enum first {
                    tailf:info "First week of the month";
                  }
                  enum last {
                    tailf:info "Last week of the month";
                  }
                }
              }
            }
            leaf start-day {
              tailf:cli-drop-node-name;
              type enumeration {
                enum monday;
                enum tuesday;
                enum wednesday;
                enum thursday;
                enum friday;
                enum saturday;
                enum sunday;
              }
            }
            leaf start-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf start-time {
              tailf:cli-drop-node-name;
              type string {
                pattern "[0-9][0-9]:[0-9][0-9]";
              }
            }
            leaf end {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<1-4>;;Week number to end";
                  range "1..4";
                }
                type enumeration {
                  enum first {
                    tailf:info "First week of the month";
                  }
                  enum last {
                    tailf:info "Last week of the month";
                  }
                }
              }
            }
            leaf end-day {
              tailf:cli-drop-node-name;
              type enumeration {
                enum monday;
                enum tuesday;
                enum wednesday;
                enum thursday;
                enum friday;
                enum saturday;
                enum sunday;
              }
            }
            leaf end-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf end-time {
              tailf:cli-drop-node-name;
              type string {
                pattern "[0-9][0-9]:[0-9][0-9]";
              }
            }
          }
        }
      }
      container timezone {
        tailf:info "Configure time zone";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf zone {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;name of time zone";
          }
        }
        leaf hours-offset {
          tailf:cli-drop-node-name;
          type int8 {
            tailf:info "<-23 - 23>;;Hours offset from UTC";
            range "-23..23";
          }
        }
        leaf minutes-offset {
          tailf:cli-drop-node-name;
          type int8 {
            tailf:info "<0-59>;;Minutes offset from UTC";
            range "0..59";
          }
        }
      }
    }
  }

  // admin / exception
  // exception
  grouping exception-grouping {
    container exception {
      tailf:info "Coredump configuration commands";
      tailf:cli-explicit-exit;

      // exception choice ? compress ? filepath ?
      container exception-filepath {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf "choice" {
          tailf:info "Preference for the following dump location";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-3>;;Order of preference";
            range "1..3";
          }
        }
        leaf compress {
          tailf:info "Compress the dump files";
          tailf:cli-incomplete-command;
          type enumeration {
            enum off {
              tailf:info "Do not compress core files dumped on this path";
            }
            enum on {
              tailf:info "Compress core files dumped on this path";
            }
          }
        }
        container filename {
          tailf:info "Dump file name";
          tailf:cli-optional-in-sequence;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Filename";
            }
          }
          leaf limit {
            tailf:cli-drop-node-name;
            //!!fix cleaner
            type string {
              tailf:info "lowlimit-highlimit";
            }
          }
        }
        leaf filepath {
          tailf:info "Give the dump location next";
          type string {
            tailf:info "WORD;;Protocol and directory";
          }
        }
      }

      // exception sparse
      leaf sparse {
        tailf:info "control sparse core dump";
        tailf:cli-full-command;
        type enumeration {
          enum off {
            tailf:info "Disable sparse core dump";
          }
          enum on {
            tailf:info "Enable sparse core dump by default";
          }
        }
      }

      // exception sprsize
      leaf sprsize {
        tailf:info "Switch to sparse core dump at this size";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-4095>;;Switch to sparse core dump size in MB";
          range "1..4095";
        }
      }

      // exception coresize
      leaf coresize {
        tailf:info "Only print out stack trace and create no core file "+
          "beyond this size";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4095>;;Core file size max limit in MB";
          range "1..4095";
        }
      }

      // exception pakmem
      leaf pakmem {
        tailf:info "control pakmem in core";
        tailf:cli-full-command;
        type enumeration {
          enum off {
            tailf:info "Disable dump of packet memory by default";
          }
          enum on {
            tailf:info "Dump packet memory for all process";
          }
        }
      }
    }
  }

  grouping average-cpu-used-grouping {
    leaf op {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type operator-type;
    }
    leaf threshold {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<0-100>;;Threshold value";
        range "0..100";
      }
    }
    leaf percent {
      tailf:info "Specify that threshold value is percent of previous sample";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    container rearm {
      tailf:info "Specify Rearm parameters (default - always)";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      choice rearm-choice {
        leaf toggle {
          tailf:info "Rearm after the first period when condition is not met";
          type empty;
        }
        leaf window {
          tailf:info "Rearm after the window of sampling periods";
          type uint8 {
            tailf:info "<1-100>;;Rearm window size";
            range "1..100";
          }
        }
      }
    }
  }


  // evpn / timers
  // evpn / virtual neighbor * pw-id * / timers
  grouping evpn-timers-grouping {

    // evpn /  timers
    container timers {
      tailf:info "Configure EVPN timers";
      tailf:cli-add-mode;
      tailf:cli-delete-when-empty;
      presence true;

      // evpn /  timers peering
      leaf peering {
        tailf:info "Peering timer";
        type uint16 {
          tailf:info "<0-300>;;Value in seconds, default is 3 seconds";
          range "0..300";
        }
      }

      // evpn /  timers recovery
      leaf recovery {
        tailf:info "Recovery timer";
        type uint16 {
          tailf:info "<20-3600>;;Value in seconds, default is 30 seconds";
          range "20..3600";
        }
      }
    }
  }

  // evpn / virtual neighbor * pw-id *
  // evpn / virtual vfi *
  grouping evpn-virtual-grouping {

    // evpn / virtual neighbor * pw-id * / ethernet-segment
    container ethernet-segment {
      tailf:info "Ethernet Segment configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-evpn-ac-es";

      // evpn / virtual neighbor * pw-id * / ethernet-segment / identifier
      container identifier {
        tailf:info "Ethernet Segment identifier (ESI)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf "type" {
          tailf:info "ESI Type";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "0;;Type 0 (arbitrary 9-octet ESI value)";
            range "0";
          }
        }
        leaf esi-value {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "<0-ff>.;;9-octet ESI value";
            pattern '[0-9a-f]{2}(\.[0-9a-f]{2}){8}';
          }
        }
      }

      // evpn / virtual neighbor * pw-id * / ethernet-segment / bgp route-target
      container bgp {
        tailf:info "Configure BGP";
        leaf route-target {
          tailf:info "Set ES-Import Route Target";
          type string {
            tailf:info "H.H.H;;Route Target value (6-octet)";
            pattern '[0-9a-f]{4}\.[0-9a-f]{4}\.[0-9a-f]{4}';
          }
        }
      }
    }

    // evpn / virtual neighbor * pw-id * / timers
    uses evpn-timers-grouping;
  }

  grouping pppoe-bba-group-grouping {

    // pppoe bba-group / ac name
    container ac {
      tailf:info "Modify Access Concentrator config";
      leaf name {
        tailf:info "Change the name to include in the AC tag";
        type string {
          tailf:info "WORD;;New name";
        }
      }
    }

    // pppoe bba-group / pado
    container pado {
      tailf:info "Configure the PADO response to PADIs";

      // pppoe bba-group / pado delay
      container delay {
        tailf:info "Delay the PADO response";
        leaf delay {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-10000>;;PADO delay (in milliseconds)";
            range "0..10000";
          }
        }
      }
    }

    // pppoe bba-group / service
    container service {
      tailf:info "Modify service config";

      // pppoe bba-group / service selection disable
      container selection {
        tailf:info "Disable advertising of unrequested service names";
        leaf disable {
          tailf:info "Disable advertising of unrequested service names";
          type empty;
        }
      }
    }

    // pppoe bba-group / sessions
    container sessions {
      tailf:info "Change sessions configuration";

      // pppoe bba-group / sessions mac
      container mac {
        tailf:info "Limit or throttle PPPoE sessions from any one MAC address";

        // pppoe bba-group / sessions mac throttle
        container throttle {
          tailf:info "Throttle PPPoE sessions from any one MAC address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf limit {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-65535>;;Number of requests at which to throttle";
              range "1..65535";
            }
          }
          leaf request-period {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-100>;;Throttle request period";
              range "1..100";
            }
          }
          leaf block-period {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;Throttle blocking period";
            }
          }
        }
      }
    }
  }

  // router eigrp * / address-family * /
  // router eigrp * / address-family * / interface *
  grouping router-eigrp-if-grouping {

  }

  // router eigrp * / address-family ipv4 /
  // router eigrp * / address-family ipv6 /
  grouping router-eigrp-af-grouping {

    // router eigrp * / address-family * / stub
    container stub {
      tailf:info "EIGRP stub";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf connected {
        tailf:info "Do advertise connected routes";
        type empty;
      }
      leaf redistributed {
        tailf:info "Do advertise redistributed routes";
        type empty;
      }
      leaf static {
        tailf:info "Do advertise static routes";
        type empty;
      }
      leaf summary {
        tailf:info "Do advertise summary routes";
        type empty;
      }
    }

    // router eigrp * / address-family * / timers
    container timers {
      tailf:info "Configure EIGRP timers";

      // router eigrp * / address-family * / timers nsf
      container nsf {
        tailf:info "Configure NSF timers";

        // router eigrp * / address-family * / timers nsf route-hold
        leaf route-hold {
          tailf:info "Route hold time for inactive peer";
          type uint16 {
            tailf:info "<20-6000>;;Hold time (in seconds)";
            range "20..6000";
          }
        }
      }
    }

    // router eigrp * / address-family * / distance
    container distance {
      tailf:info "Set distance for EIGRP routes";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf internal {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;Internal routes' distance";
          range "1..255";
        }
      }
      leaf external {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;External routes' distance";
          range "1..255";
        }
      }
    }

    // router eigrp * / address-family * / maximum-paths
    leaf maximum-paths {
      tailf:info "Maximum paths";
      type uint8 {
        tailf:info "<1-32>;;number of paths";
        range "1..32";
      }
    }

    // router eigrp * / address-family * / router-id
    leaf router-id {
      tailf:info "Set router ID";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Router ID";
      }
    }

    // router eigrp * / address-family * / route-policy * in|out
    uses route-policy-list-grouping;

    // router eigrp * / address-family * / metric
    container metric {
      tailf:info "Modify EIGRP routing metrics and parameters";

      // router eigrp * / address-family * / metric maximum-hops
      leaf maximum-hops {
        tailf:info "Advertise EIGRP routes greater than <hops> as unreachable";
        type uint8 {
          tailf:info "<1-255>;;Hop count";
          range "1..255";
        }
      }

      // router eigrp * / address-family * / metric weights
      container weights {
        tailf:info "EIGRP metric coefficients";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf tos {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-0>;;Type of Service (Only TOS 0 supported)";
            range "0";
          }
        }
        leaf k1 {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;K1";
          }
        }
        leaf k2 {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;K2";
          }
        }
        leaf k3 {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;K3";
          }
        }
        leaf k4 {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;K4";
          }
        }
        leaf k5 {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;K5";
          }
        }
      }
    }

    // router eigrp * / address-family * / default-metric
    container default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf bandwidth {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Bandwidth in Kbits per second";
          range "1..4294967295";
        }
      }
      leaf delay {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Delay metric, in 10 microsecond units";
          range "1..4294967295";
        }
      }
      leaf reliability {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Reliability metric where 255 is 100% reliable";
        }
      }
      leaf loading {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;Effective bandwidth metric (Loading) where 255 is 100% loaded";
          range "1..255";
        }
      }
      leaf mtu {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;Maximum Transmission Unit metric of the path";
        }
      }
    }

    // router eigrp * / address-family * / log-neighbor-changes
    leaf log-neighbor-changes {
      tailf:info "Enable/Disable EIGRP neighbor logging";
      type empty;
    }

    // router eigrp * / address-family * / log-neighbor-warnings
    leaf log-neighbor-warnings {
      tailf:info "Enable/Disable EIGRP neighbor warnings";
      type empty;
    }

    // router eigrp * / address-family * / autonomous-system
    leaf autonomous-system {
      tailf:info "Set the autonomous system of VRF";
      type uint16 {
        tailf:info "<1-65535>;;Autonomous system number";
        range "1..65535";
      }
    }

    // router eigrp * / address-family * / redistribute
    container redistribute {
      tailf:info "Redistribute another protocol";

      // router eigrp * / address-family * / redistribute bgp *
      // router eigrp * / address-family * / redistribute isis *
      // router eigrp * / address-family * / redistribute ospf *
      // router eigrp * / address-family * / redistribute eigrp *
      list protocol-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "protocol id";
        leaf protocol {
          type enumeration {
            enum bgp {
              tailf:info "Border Gateway Protocol (BGP) routes";
            }
            enum isis {
              tailf:info "Intermediate System-to-Intermediate System (IS-IS) routes";
            }
            enum ospf {
              tailf:info "Open Shortest Path First (OSPF) routes";
            }
            enum eigrp {
              tailf:info "EIGRP routes";
            }
          }
        }
        leaf id {
          type string {
            tailf:info "WORD;;Process ID (AS number, instance name or number";
          }
        }
        leaf route-policy {
          tailf:info "Filter using an RPL policy";
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
          type string {
            tailf:info "WORD;;Name of the policy";
          }
        }
      }

      // router eigrp * / address-family * / redistribute connected
      // router eigrp * / address-family * / redistribute rip
      // router eigrp * / address-family * / redistribute static
      // router eigrp * / address-family * / redistribute subscriber
      list name-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type enumeration {
            enum connected {
              tailf:info "Connected routes";
            }
            enum rip {
              tailf:info "Routing Information Protocol (RIP) routes";
            }
            enum static {
              tailf:info "Static routes";
            }
            enum subscriber {
              tailf:info "Subscriber routes";
            }
          }
        }
        leaf route-policy {
          tailf:info "Filter using an RPL policy";
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
          type string {
            tailf:info "WORD;;Name of the policy";
          }
        }
      }
    }

    // router eigrp * / address-family * / interface *
    list interface {
      tailf:info "EIGRP interface configuration submode";
      tailf:cli-mode-name "config-eigrp-vrf-af-if";
      key name;
      leaf name {
        type ifname;
      }

      // router eigrp * / address-family * / interface * / authentication keychain
      container authentication {
        tailf:info "Authentication configuration";
        leaf keychain {
          tailf:info "Authentication keychain configuration";
          type string {
            tailf:info "WORD;;Authentication keychain name";
          }
        }
      }

      // router eigrp * / address-family * / interface * / hold-time
      leaf hold-time {
        tailf:info "Hold Time";
        type uint16 {
          tailf:info "<1-65535>;;Neighbor hold time (in seconds)";
          range "1..65535";
        }
      }

      // router eigrp * / address-family * / interface * / summary-address *
      list summary-address {
        tailf:info "Summary address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "prefix";
        leaf "prefix" {
          type union {
            type ipv4-prefix {
              tailf:info "A.B.C.D/length;;IPv4 Prefix/length or Prefix and Mask";
            }
            type tailf:ipv6-address-and-prefix-length {
              tailf:info "X:X::X/length;;IPv6 Prefix";
            }
          }
        }
        leaf admin-distance {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
      }

      // router eigrp * / address-family * / interface * / bandwidth-percent
      leaf bandwidth-percent {
        tailf:info "Bandwidth limit";
        type uint32 {
          tailf:info "<1-999999>;;Percent";
          range "1..999999";
        }
      }

      // router eigrp * / address-family * / interface * / route-policy * in|out
      uses route-policy-list-grouping;

      // router eigrp * / address-family * / interface * / site-of-origin
      leaf site-of-origin {
        tailf:info "Configure Site-of-origin";
        type asn-ip-type;
      }
    }
  }

  // router eigrp * /
  // router eigrp * / vrf *
  grouping router-eigrp-grouping {

    // router eigrp * / address-family
    container address-family {
      tailf:info "EIGRP address-family configuration submode";

      // router eigrp * / address-family ipv4
      container ipv4 {
        tailf:info "IPv4 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-eigrp-af";
        presence true;
        uses router-eigrp-af-grouping;
      }

      // router eigrp * / address-family ipv6
      container ipv6 {
        tailf:info "IPv6 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-eigrp-af";
        presence true;
        uses router-eigrp-af-grouping;
      }
    }
  }

  // router rip / route-policy * in|out
  // router bgp * / neighbor * / address-family * / route-policy * in|out
  // router eigrp * / address-family * / route-policy * in|out
  grouping route-policy-list-grouping {
    list route-policy {
      tailf:info "Apply route policy";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Apply route policy to inbound routes";
          }
          enum out {
            tailf:info "Apply route policy to outbound routes";
          }
        }
      }
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        tailf:meta-data "string-remove-quotes" {
          tailf:meta-value "route-policy <STRING>";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
    }
  }

  grouping apply-group-grouping {
    leaf-list apply-group {
      tailf:info "Apply configuration from a group";
      tailf:cli-flat-list-syntax;
      tailf:cli-remove-before-change;
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:group/name";
      }
      type string {
        tailf:info "WORD;;Group name";
      }
    }
  }


  grouping telemetry-policy-driven-encoder-grouping {

    // telemetry policy-driven / encoder * / policy group *
    container policy {
      tailf:info "policy";
      list group {
        tailf:info "group";
        tailf:cli-mode-name "config-policy-group";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;policy group name";
          }
        }

        // telemetry policy-driven / encoder * / policy group * / policy *
        list policy {
          tailf:info "Policy name";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Policy name";
            }
          }
        }

        // telemetry policy-driven / encoder * / policy group * / source interface
        container source {
          tailf:info "Bind point for destinations in this policy group";
          container interface {
            tailf:info "Source interface name";
            uses interface-name-grouping;
          }
        }

        // telemetry policy-driven / encoder * / policy group * / transport
        container transport {
          tailf:info "Encoder configuration";

          // telemetry policy-driven / encoder * / policy group * / transport tcp
          container tcp {
            tailf:info "Encoder configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-telem-plcy-driven-gpb";

            // telemetry policy-driven / encoder * / policy group * / transport tcp / encoding-format gpb-compact
            container encoding-format {
              tailf:info "Encoding Format configuration";
              leaf gpb-compact {
                tailf:info "GPB compact format";
                type empty;
              }
            }
          }
        }

        // telemetry policy-driven / encoder * / policy group * / destination
        container destination {
          tailf:info "Destination";

          // telemetry policy-driven / encoder * / policy group * / destination ipv4 *
          list ipv4 {
            tailf:info "IPv4 destination";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "address port";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Destination IP address";
              }
            }
            leaf port {
              tailf:info "Destination port number";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-65535>;;Destination port number";
                range "1..65535";
              }
            }
          }

          // telemetry policy-driven / encoder * / policy group * / destination ipv6 *
          list ipv6 {
            tailf:info "IPv6 destination";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "address port";
            leaf address {
              type inet:ipv6-address {
                tailf:info "X:X::X;;Destination IP address";
              }
            }
            leaf port {
              tailf:info "Destination port number";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-65535>;;Destination port number";
                range "1..65535";
              }
            }
          }
        }
      }
    }
  }


  // =========================================================================
  //                        MODEL
  // =========================================================================


  /// ========================================================================
  /// admin
  /// ========================================================================
  // NOTE: admin config (admin show running-config)
  //       to enter: 'admin' in exec mode, then configure

  container admin {
    tailf:info "Enter administrator/owner plane config";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-admin";
    tailf:cli-full-command;
    tailf:cli-exit-command "exit-admin-config";

    // admin / username *
    uses username-grouping;

    // admin / fpd auto-upgrade
    container fpd {
      tailf:info "FPD firmware configuration";
      leaf auto-upgrade {
        tailf:info "FPD auto-upgrade configuration";
        type empty;
      }
    }

    // admin / hw-module
    container hw-module {
      tailf:info "Configure h/w module";

      // admin / hw-module profile
      container profile {
        tailf:info "Configure memory resource profile";

        // admin / hw-module scale
        leaf scale {
          tailf:info "Configure scale profile";
          tailf:cli-full-command;
          type enumeration {
            enum bng-max {
              tailf:info "BNG max scale profile";
            }
            enum "default" {
              tailf:info "Default scale profile";
            }
            enum l2 {
              tailf:info "L2 scale profile";
            }
            enum l3 {
              tailf:info "L3 scale profile (depricated)";
            }
            enum l3xl {
              tailf:info "L3 XL scale profile";
            }
            enum lsr {
              tailf:info "LSR scale profile";
            }
            enum sat {
              tailf:info "nV Satellite scale profile";
            }
          }
        }
      }

      // admin / hw-module bfd-hw-offload enable location
      container bfd-hw-offload {
        tailf:info "Configure BFD hw offload parameters";
        container enable {
          tailf:info "Enable BFD hw offload mode";
          leaf location {
            tailf:info "Configure line card location";
            type string {
              tailf:info "WORD;;Fully qualified line card specification";
            }
          }
        }
      }
    }

    // admin / clock
    uses clock-grouping;

    // admin / exception
    uses exception-grouping;

    // admin / diagnostic
    container diagnostic {
      tailf:info "Configure diagnostic information";

      // diagnostic bootup
      container bootup {
        tailf:info "Configure diagnostic for bootup";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf level {
          tailf:info "Select diagnostic level";
          tailf:cli-incomplete-command;
          type enumeration {
            enum complete {
              tailf:info "Complete level";
            }
            enum minimal {
              tailf:info "Minimal level";
            }
            enum bypass {
              tailf:info "Bypass diagnostic";
            }
          }
        }
        leaf location {
          tailf:info "Select location";
          type string {
            tailf:info "WORD;;Enter Location";
          }
        }
      }

      // diagnostic monitor syslog
      container monitor {
        tailf:info "Configure diagnostic monitoring tests";
        leaf syslog {
          tailf:info "Configure diagnostic monitoring syslog";
          type empty;
        }
      }
    }

    leaf xyzroot {
      tailf:info "Internal state variable, do not modify.";
      tailf:cli-run-template "";
      tailf:cli-show-with-default;
      type uint16;
      default "0";
    }
  }


  /// ========================================================================
  /// version
  /// ========================================================================

  leaf version {
    tailf:info "XR Version";
    type string {
      tailf:info "XR version - READ ONLY";
    }
  }


  /// ========================================================================
  /// configuration
  /// ========================================================================

  container configuration {
    tailf:info "Configuration related settings";
    tailf:cli-explicit-exit;

    container display {
      tailf:info "Display mode";
      container interface {
        tailf:info "hardware interfaces";
        leaf slot-order {
          tailf:info "Display interfaces in the slot-order in show run output";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// hostname
  /// ========================================================================

  leaf hostname {
    tailf:info "Set system's network name";
    type string {
      tailf:info "WORD;;This system's network name";
    }
  }


  /// ========================================================================
  /// group
  /// ========================================================================

  // group *
  list group {
    tailf:info "config group definition mode";
    tailf:cli-mode-name "config-GRP";
    tailf:cli-exit-command "end-group";
    tailf:cli-full-command;
    tailf:cli-reset-container;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;config group name";
      }
    }
    leaf line {
      tailf:cli-drop-node-name;
      type string {
        tailf:info "WORD;;group contents as a single quoted string.";
      }
    }
  }


  /// ========================================================================
  /// apply-group
  /// ========================================================================

  // apply-group
  uses apply-group-grouping;


  /// ========================================================================
  /// clock
  /// ========================================================================

  uses clock-grouping;


  /// ========================================================================
  /// banner
  /// ========================================================================

  container banner {
    tailf:info "Define a login banner";

    // banner exec
    container exec {
      tailf:info "Set EXEC process creation banner";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }

    // banner incoming
    container incoming {
      tailf:info "Set incoming terminal line banner";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }

    // banner motd
    container motd {
      tailf:info "Set Message of the Day banner";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }

    // banner login
    container login {
      tailf:info "Set login banner";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }

    // banner slip-ppp
    container slip-ppp {
      tailf:info "Set Message for SLIP/PPP";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }

    // banner prompt-timeout
    container prompt-timeout {
      tailf:info "Set Message for login authentication timeout";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }
  }


  /// ========================================================================
  /// exception
  /// ========================================================================

  uses exception-grouping;


  /// ========================================================================
  /// cef
  /// ========================================================================

  container cef {
    tailf:info "CEF related commands";
    container load-balancing {
      tailf:info "Load balance ";
      leaf fields {
        type enumeration {
          enum L3 {}
          enum L4 {}
        }
      }
    }
  }


  /// ========================================================================
  /// explicit-path
  /// ========================================================================

  container explicit-path {
    tailf:info "Explicit-path config commands";

    // explicit-path name *
    list name {
      tailf:info "Specify explicit path by name";
      tailf:cli-mode-name "config-expl-path";
      key pathname;
      leaf pathname {
        type string {
          tailf:info "WORD;;Enter name";
        }
      }

      // explicit-path name * / index *
      uses explicit-path-index-list-grouping;
    }

    // explicit-path identifier *
    list identifier {
      tailf:info "Specify explicit path by number";
      tailf:cli-mode-name "config-expl-path";
      key identifier;
      leaf identifier {
        type uint16 {
          tailf:info "<1-65535>;;Enter number";
          range "1..65535";
        }
      }

      // explicit-path identifier * / index *
      uses explicit-path-index-list-grouping;
    }
  }


  /// ========================================================================
  /// selective-vrf-download
  /// ========================================================================

  container selective-vrf-download {
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;
    leaf disable {
      type empty;
    }
  }


  /// ========================================================================
  /// vrf
  /// ========================================================================

  container vrf {
    tailf:info "VRF configuration commands";
    tailf:cli-explicit-exit;

    // vrf *
    list vrf-list {
      tailf:cli-mode-name "config-vrf";
      tailf:cli-drop-node-name;
      key name;
      leaf name {
        tailf:info "VRF name";
        type string {
          tailf:info "WORD;;VRF name";
        }
      }

      // vrf * / description
      leaf "description" {
        tailf:info "A description for the VRF";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description for this VRF";
        }
      }

      // vrf * / rd
      leaf rd {
        tailf:info "Specify Route Distinguisher";
        tailf:cli-full-command;
        type union {
          type inet:ipv4-address;
          type string {
            tailf:info "ASN:nn or IP-address:nn;;VPN Route Distinguisher";
          }
        }
      }

      // vrf * / vpn id
      container vpn {
        tailf:info "VPN ID for the VRF";
        leaf id {
          tailf:info "VPN ID for the VRF";
          type string {
            tailf:info "<0-ffffff>:;;VPN ID, (OUI:VPN-Index) format(hex), "+
              "3 bytes OUI Part";
          }
        }
      }

      // vrf * / address-family
      container address-family {
        tailf:info "AFI/SAFI configuration";

        // vrf * / address-family ipv4
        container ipv4 {
          tailf:info "IPv4 address family";

          // vrf * / address-family ipv4 unicast
          container unicast {
            tailf:info "Unicast topology";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrf-af";
            presence true;
            uses vrf-af-ipv4-grouping;
          }

          // vrf * / address-family ipv4 flowspec
          container flowspec {
            tailf:info "Flowspec sub address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrf-af";
            presence true;
            uses vrf-af-ipv4-grouping;
          }
        }

        // vrf * / address-family ipv6 unicast
        container ipv6 {
          tailf:info "IPv6 address family";
          container unicast {
            tailf:info "Unicast topology";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrf-af";
            presence true;

            // vrf * / address-family ipv6 unicast / import
            container "import" {
              tailf:info "VRF import";

              // vrf * / address-family ipv6 unicast / import route-policy
              leaf route-policy {
                tailf:info "Use route-policy for import filtering";
                type string {
                  tailf:info "WORD;;Name of the policy";
                }
                tailf:non-strict-leafref {
                  path "/cisco-ios-xr:route-policy/name";
                }
              }

              // vrf * / address-family ipv6 unicast / import route-target
              container route-target {
                tailf:info "Specify import route target extended communities";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-vrf-import-rt";
                uses vrf-route-target-grouping;
              }
            }

            // vrf * / address-family ipv6 unicast / export
            container export {
              tailf:info "VRF export";

              // vrf * / address-family ipv6 unicast / export route-policy
              leaf route-policy {
                tailf:info "Use route-policy for export filtering";
                type string {
                  tailf:info "WORD;;Name of the policy";
                }
                tailf:non-strict-leafref {
                  path "/cisco-ios-xr:route-policy/name";
                }
              }

              // vrf * / address-family ipv6 unicast / export route-target
              container route-target {
                tailf:info "Specify export route target extended communities";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-vrf-export-rt";
                uses vrf-route-target-grouping;
              }
            }

            // vrf * / address-family ipv6 unicast / maximum prefix
            container maximum {
              tailf:info "Set maximum prefix limit";
              container "prefix" {
                tailf:info "Set table's maximum prefix limit";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-all-siblings;
                }
                leaf limit {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    tailf:info "<32-5000000>;;Maximum table's prefix limit";
                    range "32..5000000";
                  }
                }
                leaf mid-thresh {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<1-100>;;mid-thresh (% of max)";
                    range "1..100";
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ethernet
  /// ========================================================================

  container ethernet {
    tailf:info "Ethernet configuration commands";

    // ethernet sla
    container sla {
      tailf:info "Service-Level Agreement configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-sla";

      // ethernet sla / profile *
      list profile {
        tailf:info "Per-profile configuration";
        tailf:cli-mode-name "config-sla-prof";
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
        leaf "type" {
          tailf:info "Type of packet that operations using this profile "+
            "will send";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum cfm-delay-measurement {
              tailf:info "CFM delay measurement packets";
            }
            enum cfm-delay-measurement-version-0 {
              tailf:info "CFM delay measurement version 0 packets";
            }
            enum cfm-loopback {
              tailf:info "CFM loopback packets";
            }
            enum cfm-loss-measurement {
              tailf:info "CFM loss measurement packets";
            }
            enum cfm-synthetic-loss-measurement {
              tailf:info "CFM synthetic loss measurement packets";
            }
          }
        }

        // ethernet sla / profile * / probe
        container probe {
          tailf:info "SLA Probe configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-sla-prof-pb";

          // ethernet sla / profile * / probe / send
          container send {
            tailf:info "Configure properties of packets to send";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf "type" {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum burst {
                  tailf:info "Send bursts of packets";
                }
                enum packet {
                  tailf:info "Send single packets";
                }
              }
            }
            leaf every {
              tailf:info "Specify how often packets within a probe should be sent";
              type uint16 {
                tailf:info "<1-10000>;;Interval between packets";
              }
            }
            leaf every-time {
              tailf:cli-drop-node-name;
              //when "../every";
              type enumeration {
                enum seconds {
                  tailf:info "Time is in seconds";
                }
                enum minutes {
                  tailf:info "Time is in minutes";
                }
                enum hours {
                  tailf:info "Time is in hours";
                }
              }
            }
          }

          // ethernet sla / profile * / probe / priority
          leaf priority {
            tailf:info "Specify the priority to use when sending packets";
            type uint8 {
              tailf:info "<0-7>;;Packet priority of each packet in the probe";
              range "0..7";
            }
          }
        }

        // ethernet sla / profile * / schedule
        container schedule {
          tailf:info "SLA Schedule configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-sla-prof-schedule";

          // ethernet sla / profile * / schedule / every
          container every {
            tailf:info "Specify scheduling frequency";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf number {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-90>;;Interval between operations "+
                  "(hours or minutes)";
                range "1..90";
              }
            }
            leaf every-time {
              tailf:cli-drop-node-name;
              type enumeration {
                enum minutes {
                  tailf:info "Time is in minutes";
                }
                enum hours {
                  tailf:info "Time is in hours";
                }
              }
            }
            leaf "for" {
              tailf:info "Specify how long operations should keep running for";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-3600>;;Duration of operation (may be seconds, "+
                  "minutes, hours, days, or weeks)";
                range "1..3600";
              }
            }
            leaf for-time {
              tailf:cli-drop-node-name;
              type enumeration {
                enum seconds {
                  tailf:info "Time is in seconds";
                }
                enum minutes {
                  tailf:info "Time is in minutes";
                }
              }
            }
          }
        }

        // ethernet sla / profile * / statistics
        container statistics {
          tailf:info "SLA Statistics-collection configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-sla-prof-stat";

          // ethernet sla / profile * / statistics / measure *
          list measure {
            tailf:info "Specify the type of statistics to collect";
            tailf:cli-mode-name "config-sla-prof-stat-cfg";
            key id;
            leaf id {
              type enumeration {
                enum one-way-delay-ds {
                  tailf:info "Collect one-way (destination-to-source) delay";
                }
                enum one-way-delay-sd {
                  tailf:info "Collect one-way (source-to-destination) delay";
                }
                enum one-way-jitter-ds {
                  tailf:info "Collect one-way (destination-to-source) jitter";
                }
                enum one-way-jitter-sd {
                  tailf:info "Collect one-way (source-to-destination) jitter";
                }
                enum round-trip-delay {
                  tailf:info "Collect round-trip delay";
                }
                enum round-trip-jitter {
                  tailf:info "Collect round-trip jitter";
                }
              }
            }

            // ethernet sla / profile * / statistics / measure * / aggregate
            container aggregate {
              tailf:info "Specify how results should be aggregated";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              choice aggregate-choice {
                case none {
                  leaf none {
                    tailf:info "Perform no aggregation";
                    type empty;
                  }
                }
                case bins-width {
                  leaf bins {
                    tailf:info "Aggregate results into a number of bins";
                    tailf:cli-incomplete-command;
                    type uint8 {
                      tailf:info "<2-100>;;Number of bins to distribute results between";
                      range "2..100";
                    }
                  }
                  leaf width {
                    tailf:info "Specify the width of each bin (in milliseconds"+
                      "for delay or percentage points for loss)";
                    type uint16 {
                      tailf:info "<1-10000>;;Width (in milliseconds for "+
                        "delay or percentage points for loss)";
                      range "1..10000";
                    }
                  }
                }
              }
            }

            // ethernet sla / profile * / statistics / measure * / buckets
            container buckets {
              tailf:info "Bucket configuration";

              // ethernet sla / profile * / statistics / measure * / buckets size
              container "size" {
                tailf:info "Configure the size of each bucket";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf number {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<1-100>;;Size of each bucket "+
                      "(number of probes-per-bucket)";
                    range "1..100";
                  }
                }
                leaf probes {
                  tailf:info "Buckets span multiple probes";
                  type empty;
                }
              }

              // ethernet sla / profile * / statistics / measure * / buckets archive
              leaf archive {
                tailf:info "Configure the number of buckets to store internally";
                type uint8 {
                  tailf:info "<1-100>;;Number of buckets to store internally";
                  range "1..100";
                }
              }
            }
          }
        }
      }
    }

    // ethernet cfm
    container cfm {
      tailf:info "802.1ag Connectivity Fault Management configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-cfm";

      // ethernet cfm / traceroute cache
      container traceroute {
        tailf:info "Traceroute configuration";
        container cache {
          tailf:info "Configure traceroute cache parameters";
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          leaf hold-time {
            tailf:info "Traceroute cache hold-time";
            type uint32 {
              tailf:info "<1-525600>;;Hold-time, in minutes";
            }
          }
          leaf size {
            tailf:info "Traceroute cache size (number of replies)";
            type uint32 {
              tailf:info "<1-4294967295>;;Number of replies in the traceroute cache";
            }
          }
        }
      }

      // ethernet cfm / domain *
      list domain {
        tailf:info "Per domain configuration";
        tailf:cli-mode-name "config-cfm-dmn";
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Domain name (up to 80 chars)";
          }
        }
        leaf level {
          tailf:info "Level of this domain";
          tailf:cli-hide-in-submode;
          type uint8 {
            tailf:info "<0-7>;;Level";
          }
        }
        container id {
          tailf:info "Maintenance Domain Identifier";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-hide-in-submode;
          choice id-choice {
            leaf "null" {
              tailf:info "No MDID value";
              type empty;
            }
            leaf string {
              tailf:info "String";
              type string {
                tailf:info "WORD;;String (up to 43 chars)";
                length "1..43";
              }
            }
          }
        }

        // ethernet cfm / domain * / service *
        list service {
          tailf:info "Per service configuration";
          tailf:cli-mode-name "config-cfm-dmn-svc";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Service name (up to 80 chars)";
            }
          }

          choice service-type {
            // ethernet cfm / domain * / service * bridge
            container bridge {
              tailf:info "Use a Bridge Domain. All MEPs will be Up MEPs; "+
                "MIPs are permitted";
              tailf:cli-hide-in-submode;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf group {
                tailf:info "Bridge Domain Group";
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "WORD;;Bridge Domain Group Name";
                }
              }
              leaf bridge-domain {
                tailf:info "Bridge Domain";
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;Bridge Domain Name";
                }
              }
            }

            // ethernet cfm / domain * / service * xconnect group * p2p *
            container xconnect {
              tailf:info "Use a Cross Connect. All MEPs will be Up MEPs;"+
                "MIPs are permitted";
              tailf:cli-hide-in-submode;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf group {
                tailf:info "Cross Connect Group";
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "WORD;;Cross Connect Group Name";
                }
              }
              leaf p2p {
                tailf:info "Point-to-Point Cross Connect";
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;Cross Connect Name";
                }
              }
            }

            // ethernet cfm / domain * / service * down-meps
            container down-meps {
              tailf:info "Down MEPs; no MIPs permitted";
              tailf:cli-hide-in-submode;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              presence true;
            }
          }

          // ethernet cfm / domain * / service * / continuity-check
          container continuity-check {
            tailf:cli-break-sequence-commands;
            tailf:info "Continuity-check configuration";
            // ethernet cfm / domain * / service * / continuity-check interval
            container interval {
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf value {
                tailf:info "Set the continuity-check interval";
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;Interval of 3.3ms|10ms|100ms|1s|10s|1m|10m";
                }
              }
              // ethernet cfm / domain * / service * / continuity-check interval loss-threshold
              leaf loss-threshold {
                tailf:info "Set the continuity-check loss threshold";
                type uint8 {
                  tailf:info "<2-255>;;Loss threshold (in number of CCMs)";
                }
              }
            }
            // ethernet cfm / domain * / service * / continuity-check archive
            container archive {
              tailf:info "Set the continuity-check archive hold time";
              leaf hold-time {
                tailf:info "Set the continuity-check archive hold time";
                type uint16 {
                  tailf:info "<1-65535>;;Hold time (in minutes)";
                  range "1..65535";
                }
              }
            }
            // ethernet cfm / domain * / service * / continuity-check loss
            container loss {
              tailf:info "Loss threshold actions";
              leaf auto-traceroute {
                tailf:info "Automatically trigger a traceroute when a MEP times out";
                type empty;
              }
            }
          }

          // ethernet cfm / domain * / service * / log
          container log {
            tailf:info "Enable logging for particular types of event";
            // ethernet cfm / domain * / service * / log continuity-check
            container continuity-check {
              tailf:info "Enable continuity-check logging";
              leaf errors {
                tailf:info "Enable logging when continuity-check errors "+
                  "are detected";
                type empty;
              }
              container mep {
                tailf:info "Enable MEP continuity-check logging";
                leaf changes {
                  tailf:info "Enable logging on peer MEP state changes";
                  type empty;
                }
              }
            }
            // ethernet cfm / domain * / service * / log ais
            leaf ais {
              tailf:info "Enable logging when AIS or LCK messages are received";
              type empty;
            }
            // ethernet cfm / domain * / service * / log crosscheck
            container crosscheck {
              tailf:info "Enable crosscheck logging";
              leaf errors {
                tailf:info "Enable logging when crosscheck errors are detected";
                type empty;
              }
            }
          }

          // ethernet cfm / domain * / service * / mip
          container mip {
            tailf:info "MIP configuration";
            container auto-create {
              tailf:info "MIP auto-creation policy";
              leaf all {
                tailf:info "Create MIPs on all interfaces";
                type empty;
              }
            }
          }

          // ethernet cfm / domain * / service * / mep crosscheck
          container mep {
            tailf:info "MEP configuration";
            container crosscheck {
              tailf:info "Statically define the Maintenence End Points with "+
                "a Maintenance Association to be cross-checked";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-cfm-xcheck";

              // ethernet cfm / domain * / service * / mep crosscheck / mep-id *
              list mep-id {
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key id;
                leaf id {
                  type uint16 {
                    tailf:info "<1-8191>;;MEP ID";
                    range "1..8191";
                  }
                }
                leaf mac-address {
                  tailf:info "Expected MAC Address for the specified MEP";
                  type string {
                    tailf:info "H.H.H;;48-bit MAC address";
                  }
                }
              }
            }
          }

          // ethernet cfm / domain * / service * / efd
          container efd {
            presence true;
          }
        }
      }
    }

    // ethernet oam profile *
    container oam {
      tailf:info "Configure information relating to Ethernet Link OAM";
      list profile {
        tailf:info "802.3 OAM profiles";
        tailf:cli-mode-name "config-eoam";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;The name of the profile";
          }
        }

        // ethernet oam profile * / hello-interval
        leaf hello-interval {
          tailf:info "Hello interval time";
          tailf:cli-full-command;
          type enumeration {
            enum "100ms" {
              tailf:info "100 millisecond hello interval";
            }
          }
        }

        // ethernet oam profile * / link-monitor
        container link-monitor {
          tailf:info "Enter link-monitor submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-eoam-lm";

          // ethernet oam profile * / link-monitor / frame
          container frame {
            tailf:info "Frame event configuration";

            // ethernet oam profile * / link-monitor / frame window
            leaf window {
              tailf:info "window size for frame event configuration";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1000-60000>;;Size of the frame window in milliseconds";
                range "1000..60000";
              }
            }

            // ethernet oam profile * / link-monitor / threshold
            container threshold {
              tailf:info "threshold configuration for frame events";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf low {
                tailf:info "low threshold for frame events";
                type uint32 {
                  tailf:info "<0-12000000>;;The low threshold for frame events";
                  range "0..12000000";
                }
              }
              leaf high {
                tailf:info "high threshold for frame events";
                type uint32 {
                  tailf:info "<1-12000000>;;The high threshold for frame events";
                  range "1..12000000";
                }
              }
            }
          }
        }

        // ethernet oam profile * / require-remote
        container require-remote {
          tailf:info "Enter require-remote submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-eoam-require";

          // ethernet oam profile * / require-remote / link-monitoring
          leaf link-monitoring {
            tailf:info "Requirement of Link monitoring support";
            type empty;
          }
        }

        // ethernet oam profile * / action
        container action {
          tailf:info "Enter action submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-eoam-action";

          // ethernet oam profile * / action / high-threshold
          leaf high-threshold {
            tailf:info "Action to perform when a high-threshold is crossed";
            tailf:cli-full-command;
            type enumeration {
              enum error-disable-interface {
                tailf:info "disable the interface";
              }
              enum log {
                tailf:info "Log the event";
              }
            }
          }
        }
      }
    }
  }



  /// ========================================================================
  /// pppoe
  /// ========================================================================

  container pppoe {
    tailf:info "PPPoE";
    tailf:cli-explicit-exit;

    // pppoe bba-group *
    container bba-group-list {
      tailf:cli-drop-node-name;
      list bba-group {
        tailf:cli-mode-name "config-bbagroup";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;BBA Group Name";
          }
        }
        uses pppoe-bba-group-grouping;
      }
    }

    // pppoe bba-group
    container bba-group {
      tailf:info "BBA-Group";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-bbagroup";
      uses pppoe-bba-group-grouping;
    }

    // pppoe in-flight-window
    leaf in-flight-window {
      tailf:info "Set the PPPoE in-flight window size(cisco-support)";
      type uint16 {
        tailf:info "<1-20000>;;PPPoE in-flight window size";
        range "1..20000";
      }
    }
  }


  /// ========================================================================
  /// rp
  /// ========================================================================

  // rp mgmtethernet forwarding
  container rp {
    tailf:info "rp configuration commands";
    container mgmtethernet {
      tailf:info "Management ethernet configuration commands";
      leaf forwarding {
        tailf:info "LC to RP switching ON";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// logging
  /// ========================================================================

  container logging {
    tailf:info "Modify message logging facilities";
    tailf:cli-explicit-exit;
    //tailf:cli-diff-dependency "/cisco-ios-xr:vrf";

    // logging disable
    leaf disable {
      tailf:cli-full-command;
      type empty;
    }

    // logging trap
    leaf trap {
      tailf:info "Set syslog server logging level";
      tailf:cli-full-command;
      type severity-type;
    }

    // logging events
    container events {
      tailf:info "Configure event monitoring parameters";
      leaf level {
        tailf:info "Log all events with equal or higher (lower level) severity";
        type severity-type;
      }
      leaf link-status {
        tailf:info "Enable or disable UP/DOWN state notifications "+
          "for all interfaces";
        type enumeration {
          enum disable {
            tailf:info "Disable state UP/DOWN notifications for "+
              "all interfaces";
          }
          enum software-interfaces {
            tailf:info "Enable state UP/DOWN notification for "+
              "software interfaces";
          }
        }
      }
      leaf threshold {
        tailf:info "Configure threshold (%) for capacity alarm";
        type uint8 {
          tailf:info "<10-100>;;Capacity alarm threshold";
        }
      }
    }

    // logging archive
    container archive {
      tailf:info "logging to a persistent device(disk/harddisk)";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-logging-arch";

      // logging archive / device
      leaf device {
        tailf:info "Configure the archive device";
        type string {
          tailf:info "WORD;;Disk to use as the archive device";
        }
      }

      // logging archive / severity
      leaf severity {
        tailf:info "The minimum severity of log messages to archive";
        type severity-type;
      }

      // logging archive / file-size
      leaf file-size {
        tailf:info "The maximum file size for a single log file";
        type uint32 {
          tailf:info "<1-2047>;;Size in MB";
          range "1..2047";
        }
      }

      // logging archive / frequency
      leaf frequency {
        tailf:info "The collection interval for logs";
        type enumeration {
          enum daily {
            tailf:info "Collect log in files on a daily basis";
          }
          enum weekly {
            tailf:info "Collect log in files on a weekly basis";
          }
        }
      }

      // logging archive / archive-size
      leaf archive-size {
        tailf:info "The total size of the archive";
        type uint32 {
          tailf:info "<1-2047>;;Size in MB";
          range "1..2047";
        }
      }

      // logging archive / archive-length
      leaf archive-length {
        tailf:info "The maximum no of weeks of log to maintain";
        type uint32 {
          tailf:info "<0-4294967295>;;Number of weeks";
        }
      }
    }

    // logging monitor
    leaf monitor {
      tailf:info "Set terminal line (monitor) logging parameters";
      tailf:cli-full-command;
      type severity-type;
    }

    // logging buffered
    container buffered {
      tailf:info "Set buffered logging parameters";
      leaf size {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<4096-2147483647>;;Logging buffer size";
          range "4096..2147483647";
        }
      }
      leaf "type" {
        tailf:cli-drop-node-name;
        type severity-type;
      }
    }

    // logging facility
    leaf facility {
      tailf:info "Facility parameter for syslog messages";
      tailf:cli-full-command;
      type union {
        type enumeration {
          enum local0;
          enum local1;
          enum local2;
          enum local3;
          enum local4;
          enum local5;
          enum local6;
          enum local7;
        }
        type string {
          tailf:info "WORDD;logging facility param";
        }
      }
    }

    // logging *
    list host {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key address;
      leaf address {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address of the logging host";
          }
          type inet:ipv6-address {
            tailf:info "X:X::X;;IPv6 address of the logging host";
          }
        }
      }

      // logging host * vrf
      leaf vrf {
        tailf:info "Set VRF option";
        type string {
          tailf:info "WORD  VPN Routing/Forwarding instance name";
        }
      }

      // logging host * severity
      leaf severity {
        tailf:info "Set severity of  messages for particular remote host/vrf";
        type severity-type;
      }

      // logging host * port
      leaf port {
        tailf:info "Set UDP port for this remote host/vrf";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "default Port";
            }
          }
          type uint32 {
            tailf:info "<0-4294967295>;;non-default Port";
            range "0..4294967295";
          }
        }
      }
    }

    // logging localfilesize
    leaf localfilesize {
      tailf:info "Set size of the local log file";
      type uint32 {
        tailf:info "<0-4294967295>;;Size of the local log file";
      }
    }

    // logging source-interface
    container source-interface {
      tailf:info "Specify interface for source address in logging transactions";
      uses interface-name-grouping;
    }

    // logging cns-events
    container cns-events {
      tailf:info "Set CNS Event logging level";
      presence true;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      leaf severity {
        type severity-type;
      }
    }

    // logging console
    leaf console {
      tailf:info "Set console logging parameters";
      tailf:cli-full-command;
      type union {
        type severity-type;
        type enumeration {
          enum disable {
            tailf:info "Disable logging";
            value -1;
          }
        }
      }
    }

    // logging count
    leaf count {
      tailf:info "Count every log message and timestamp last occurance";
      tailf:cli-full-command;
      type empty;
    }

    // logging history
    leaf history {
      tailf:info "Set history logging";
      tailf:cli-full-command;
      type severity-type;
    }

    // logging suppress
    container suppress {
      tailf:info "Configure properties for the event suppression";

      // logging suppress duplicates
      leaf duplicates {
        tailf:info "Suppress consecutive duplicate messages";
        tailf:cli-full-command;
        type empty;
      }

      // logging suppress rule *
      list rule {
        tailf:info "Configure a specified suppression rule";
        tailf:cli-mode-name "config-suppr-rule";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Rule name";
          }
        }
        list alarm {
          tailf:info "Specify alarm: Category/Group/Code combos";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "msg-category group-name msg-code";
          leaf msg-category {
            type string {
              tailf:info "WORD;;Message category of the suppressed message";
            }
          }
          leaf group-name {
            type string {
              tailf:info "WORD;;Group name of suppressed message";
            }
          }
          leaf msg-code {
            type string {
              tailf:info "WORD;;Message code of suppressed message";
            }
          }
        }
      }

      // logging suppress apply
      container apply {
        tailf:info "Apply suppression rule";

        // logging suppress apply rule *
        list rule {
          tailf:info "Apply suppression rule";
          tailf:cli-mode-name "config-suppr-apply-rule";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Rule name";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:logging/suppress/rule/name";
            }
          }

          // logging suppress apply rule * / all-of-router
          leaf all-of-router {
            tailf:info "Apply the rule to all of the router";
            tailf:cli-full-command;
            type empty;
          }

          // logging suppress apply rule * / source location
          container source {
            tailf:info "Apply rule to specified source";
            leaf location {
              tailf:info "Apply rule to specified location";
              type string {
                tailf:info "WORD;;Fully qualified source specification";
              }
            }
          }
        }
      }
    }

    // logging hostnameprefix
    leaf hostnameprefix {
      tailf:info "Hostname prefix to add on msgs to servers";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;hostname prefix string";
      }
    }
  }


  /// ========================================================================
  /// service
  /// ========================================================================

  container service {
    tailf:info "Modify use of network based services";
    tailf:cli-explicit-exit;

    container alignment {
      tailf:info "Control alignment correction and logging";
      leaf detection {
        tailf:info "Enable detection of alignment issues";
        tailf:cli-full-command;
        type empty;
      }
      leaf logging {
        tailf:info "Enable logging of alignment issues";
        tailf:cli-full-command;
        type empty;
      }
    }
    leaf call-home {
      tailf:info "Enable call-home service";
      tailf:cli-full-command;
      type empty;
    }
    leaf compress-config {
      tailf:info "Compress the nvram configuration file";
      type empty;
      tailf:cli-full-command;
    }
    container counters {
      tailf:info "Control aging of interface counters";
      container max {
        tailf:info "Maximum counter aging threshold";
        leaf age {
          tailf:info "Aging threshold";
          type uint8 {
            tailf:info "<0-60>;;Aging threshold value in seconds";
          }
        }
      }
    }
    leaf dhcp {
      tailf:info "Enable DHCP server and relay agent";
      tailf:cli-full-command;
      type empty;
    }
    leaf disable-ip-fast-frag {
      tailf:info "Disable IP particle-based fast fragmentation";
      type empty;
    }
    leaf exec-callback {
      tailf:info "Enable exec callback";
      type empty;
    }
    leaf exec-wait {
      tailf:info "Delay EXEC startup on noisy lines";
      type empty;
    }
    leaf finger {
      tailf:info "Allow responses to finger requests";
      type empty;
    }
    container heartbeat {
      tailf:info "Enable heartbeat processing";
      leaf fatal-count {
        tailf:info "Set heartbeat fatal count";
        type uint8 {
          range "1..60";
          tailf:info "<1-60>;;Number of timeouts until fatal error occurs";
        }
      }
      leaf interrupt-interval {
        tailf:info "Set heartbeat interrupt test interval";
        type uint8 {
          range "0..60";
          tailf:info "<0-60>;;Interval between interrupt level tests";
        }
      }
      leaf interrupt-max {
        tailf:info "Set maximum message count from interrupt test";
        type uint8 {
          tailf:info "<0-60>;;Maximum number of messages from interrupt test";
          range "0..60";
        }
      }
      leaf transmit-interval {
        tailf:info "Set heartbeat transmit interval";
        type uint8 {
          tailf:info "<1-30>;;Interval between heartbeat transmissions";
          range "1..30";
        }
      }
      leaf warning-timeout {
        tailf:info "Set heartbeat warning timeout interval";
        type uint8 {
          tailf:info "<5-60>;;Interval between heartbeat timeout warnings";
          range "5..60";
        }
      }
    }
    leaf hide-telnet-addresses {
      tailf:info "Hide destination addresses in telnet command";
      type empty;
    }
    leaf linenumber {
      tailf:info "enable line number banner for each exec";
      type empty;
    }
    leaf nagle {
      tailf:info "Enable Nagle's congestion control algorithm";
      type empty;
    }
    leaf old-slip-prompts {
      tailf:info "Allow old scripts to operate with slip/ppp";
      type empty;
    }
    container pad {
      tailf:info "Enable PAD commands";
      presence true;
      leaf cmns {
        tailf:info "Enable PAD over CMNS connections";
        type empty;
      }
      leaf from-xot {
        tailf:info "Accept XOT to PAD connections";
        type empty;
      }
      leaf to-xot {
        tailf:info "Allow outgoing PAD over XOT connections";
        type empty;
      }
    }
    leaf password-encryption {
      tailf:info "Encrypt system passwords";
      type empty;
    }
    container prompt {
      tailf:info "Enable mode specific prompt";
      leaf "config" {
        tailf:info "Enable configuration mode prompt";
        type empty;
      }
    }
    leaf pt-vty-logging {
      tailf:info "Log significant VTY-Async events";
      type empty;
    }
    leaf sequence-numbers {
      tailf:info "Stamp logger messages with a sequence number";
      type empty;
    }
    leaf slave-log {
      tailf:info "Enable log capability of slave IPs";
      type empty;
    }
    leaf tcp-keepalives-in {
      tailf:info "Generate keepalives on idle incoming network connections";
      type empty;
      tailf:cli-full-command;
    }
    leaf tcp-keepalives-out {
      tailf:info "Generate keepalives on idle outgoing network connections";
      type empty;
      tailf:cli-full-command;
    }

    // service tcp-small-servers
    container tcp-small-servers {
      tailf:info "Enable small TCP servers (e.g., ECHO)";
      presence true;
      leaf max-servers {
        tailf:info "Set number of allowable TCP small servers";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;Maximum TCP small servers";
            range "1..2147483647";
          }
          type enumeration {
            enum "no-limit" {
              tailf:info "No limit to number of allowable TCP small servers";
            }
          }
        }
      }
    }

    // service telnet-zeroidle
    leaf telnet-zeroidle {
      tailf:info "Set TCP window 0 when connection is idle";
      type empty;
    }

    // service timestamps
    container timestamps {
      tailf:info "Timestamp debug/log messages";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      // service timestamps debug
      container debug {
        tailf:info "Timestamp debug messages";
        choice log-time-choice {
          container datetime {
            tailf:info "Timestamp with date and time";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf localtime {
              tailf:info "Use local time zone for timestamps";
              type empty;
            }
            leaf msec {
              tailf:info "Include milliseconds in timestamp";
              type empty;
            }
            leaf show-timezone {
              tailf:info "Add time zone information to timestamp";
              type empty;
            }
            leaf year {
              tailf:info "Include year in timestamp";
              type empty;
            }
          }
          leaf uptime {
            tailf:info "Timestamp with system uptime";
            type empty;
          }
        }
      }

      // service timestamps log
      container log {
        tailf:info "Timestamp log messages";
        choice log-time-choice {
          container datetime {
            tailf:info "Timestamp with date and time";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf localtime {
              tailf:info "Use local time zone for timestamps";
              type empty;
            }
            leaf msec {
              tailf:info "Include milliseconds in timestamp";
              type empty;
            }
            leaf show-timezone {
              tailf:info "Add time zone information to timestamp";
              type empty;
            }
            leaf year {
              tailf:info "Include year in timestamp";
              type empty;
            }
          }
          leaf uptime {
            tailf:info "Timestamp with system uptime";
            type empty;
          }
        }
      }
    }

    // service udp-small-servers
    container udp-small-servers {
      tailf:info "Enable small UDP servers (e.g., ECHO)";
      presence true;
      leaf max-servers {
        tailf:info "Set number of allowable UDP small servers";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;Maximum UDP small servers";
            range "1..2147483647";
          }
        }
      }
    }

    // service unsupported-transceiver
    leaf unsupported-transceiver {
      tailf:cli-full-command;
      type empty;
    }
  }


  /// ========================================================================
  /// event
  /// ========================================================================

  container event {
    tailf:info "Event related commands";
    tailf:cli-explicit-exit;

    // event manager
    container manager {
      tailf:info "Event Manager configuration commands";

      // event manager directory user
      container directory {
        tailf:info "Set Embedded Event Manager directory information";
        container user {
          tailf:info "Set Embedded Event Manager user directory information";

          // event manager directory user policy
          leaf policy {
            tailf:info "Set Embedded Event Manager user policy directory";
            type string {
              tailf:info "WORD;;Path of the Embedded Event Manager user "+
                "policy directory";
            }
          }

          // event manager directory library
          leaf library {
            tailf:info "Set Embedded Event Manager user library directory";
            type string {
              tailf:info "WORD;;Path of the Embedded Event Manager user "+
                "library directory";
            }
          }
        }
      }

      // event manager policy *
      list policy {
        tailf:info "Register an Event Manager policy";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the policy file";
          }
        }
        // event manager policy * username
        leaf username {
          tailf:info "Username under whom this policy will execute";
          type string {
            tailf:info "WORD;;A Configured username";
          }
        }

        // event manager policy * persist-time
        leaf persist-time {
          tailf:cli-break-sequence-commands;
          tailf:info "Time of validity (in seconds) for cached AAA "+
            "taskmap of username (default is 3600)";
          type union {
            type enumeration {
              enum infinite {
                tailf:info "Cached AAA taskmap of username is always "+
                  "treated valid";
              }
            }
            type uint32 {
              tailf:info "<0-4294967294>;;Integer value for this policy's "+
                "persist-time";
            }
          }
        }

        // event manager policy * type
        leaf "type" {
          tailf:info "The Event Manager type of this policy";
          type enumeration {
            enum system {
              tailf:info "Event Manager system policy";
            }
            enum user {
              tailf:info "Event Manager user policy";
            }
          }
        }
      }

      // event manager environment *
      list environment {
        tailf:info "Set an Embedded Event Manager global variable for "+
          "policies";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the global variable";
          }
        }
        leaf var-value {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Value of the global variable";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// domain
  /// ========================================================================

  container domain {
    tailf:info "Domain service related commands";
    tailf:cli-explicit-exit;

    // domain ipv4 host *
    container ipv4 {
      tailf:info "Ipv4 hosts";
      list host {
        tailf:info "Add an entry to the ip hostname table";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key host-name;
        leaf host-name {
          type string {
            tailf:info "WORD;;Name of host";
          }
        }
        leaf-list address {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          ordered-by user;
          max-elements 8;
          type string {
            tailf:info "A.B.C.D;;Host IP address (maximum of 8";
          }
        }
      }
    }

    // domain ipv6 host *
    container ipv6 {
      tailf:info "Ipv6 hosts";
      list host {
        tailf:info "Add an entry to the ipv6 hostname table";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key host-name;
        leaf host-name {
          type string {
            tailf:info "WORD;;Name of host";
          }
        }
        leaf-list address {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          ordered-by user;
          max-elements 4;
          type string {
            tailf:info "X:X::X;;IPv6 name or address (maximum four addresses";
          }
        }
      }
    }

    // domain lookup
    container lookup {
      tailf:info "Enable Domain Name System hostname translation";

      // domain lookup disable
      leaf disable {
        tailf:info "Disable Domain Name System hostname translation";
        tailf:cli-full-command;
        type empty;
      }

      // domain lookup source-interface
      container source-interface {
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
    }

    // domain name
    leaf name {
      tailf:info "Define the default domain name";
      type string {
        tailf:info "WORD;;Default domain name";
      }
    }

    // domain list
    leaf "list" {
      tailf:info "Domain name to complete unqualified host names";
      type string {
        tailf:info "WORD;;A domain name";
      }
    }

    // domain name-server *
    list name-server {
      tailf:info "Specify address of name server to use";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key address;
      leaf address {
        type inet:host;
      }
    }

    // domain vrf *
    list vrf {
      tailf:info "VRF name for domain services";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        tailf:info "VRF name";
        type string {
          tailf:info "WORD;;VRF name";
        }
      }

      // domain vrf * name
      leaf name {
        tailf:info "Define the default domain name";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Default domain name";
        }
      }

      // domain vrf * lookup
      container lookup {
        tailf:info "Enable Domain Name System hostname translation";
        tailf:cli-reset-container;
        leaf disable {
          tailf:info "Disable Domain Name System hostname translation";
          tailf:cli-full-command;
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// forward-protocol
  /// ========================================================================

  // forward-protocol udp *
  container forward-protocol {
    tailf:info "Controls forwarding of physical and directed IP broadcasts";

    container udp {
      tailf:info "Packets to a specific UDP port";
      list port-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key port;
        leaf port {
          type union {
            type uint16 {
              tailf:info "<1-65535>;;Port number";
              range "1..65535";
            }
            type enumeration {
              enum domain {
                tailf:info "Domain Name Service (DNS, 53)";
                value 53;
              }
              enum nameserver {
                tailf:info "IEN116 name service (obsolete, 42)";
                value 42;
              }
              enum netbios-dgm {
                tailf:info "NetBios datagram service (138)";
                value 138;
              }
              enum netbios-ns {
                tailf:info "NetBios name service (137)";
                value 137;
              }
              enum tacacs {
                tailf:info "TAC Access Control System (49)";
                value 49;
              }
              enum tftp {
                tailf:info "Trivial File Transfer Protocol (69)";
                value 69;
              }
            }
          }
        }
        leaf disable {
          tailf:info "Disable IP Forward Protocol UDP for a specific port";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// taskgroup
  /// ========================================================================

  list taskgroup {
    tailf:info "Configure task group";
    tailf:cli-mode-name "config-tg";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Taskgroup name";
      }
    }

    // taskgroup * / task
    container task {
      tailf:info "Specify a task ID to be part of this group";

      // taskgroup * / task execute *
      list execute {
        tailf:info "Specify a execute-type task ID";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type task-type;
        }
      }

      // taskgroup * / task read *
      list read {
        tailf:info "Specify a read-type task ID";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type task-type;
        }
      }

      // taskgroup * / task write *
      list write {
        tailf:info "Specify a write-type task ID";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type task-type;
        }
      }

      // taskgroup * / task debug *
      list debug {
        tailf:info "Specify a debug-type task ID";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type task-type;
        }
      }
    }

    // taskgroup * / inherit
    container inherit {
      tailf:info "Inherit to include into this taskgroup";
      list taskgroup {
        tailf:info "Specify a taskgroup to inherit from";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the task group to include";
          }
        }
      }
    }
    // taskgroup * / description
    leaf "description" {
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;description";
      }
    }
  }


  /// ========================================================================
  /// radius
  /// ========================================================================

  container radius {
    tailf:info "RADIUS configuration commands";
    tailf:cli-explicit-exit;

    // radius source-interface
    container source-interface {
      tailf:info "Specify interface for source address in RADIUS packets";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      uses interface-name-grouping;
      leaf vrf {
        tailf:info "VRF for this source interface configuration";
        type string {
          tailf:info "WORD;;Name of the VRF";
        }
      }
    }
  }


  /// ========================================================================
  /// radius-server
  /// ========================================================================

  container radius-server {
    tailf:info "RADIUS server definition";
    tailf:cli-explicit-exit;

    // radius-server ipv4 dscp
    container ipv4 {
      tailf:info "Mark the dscp bit for ipv4 packets";
      leaf dscp {
        tailf:info "Set IP DSCP (DiffServ CodePoint)";
        type dscp-type;
      }
    }

    // radius-server deadtime
    leaf deadtime {
      tailf:info "Time in minutes for which a RADIUS server will be marked dead";
      type uint16 {
        tailf:info "<1-1440>;;Deadtime limit in minutes (default 0)";
        range "1..1440";
      }
    }

    // radius-server disallow null-username
    container disallow {
      tailf:info "disallow null-username";
      leaf null-username {
        tailf:info "null-username";
        type empty;
      }
    }

    // radius-server host *
    list host {
      tailf:info "Specify a RADIUS server";
      tailf:cli-mode-name "config-radius-host";
      tailf:cli-compact-syntax;
      key id;
      leaf id {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
        }
      }
      // radius-server host * auth-port
      leaf auth-port {
        tailf:info "UDP port for RADIUS authentication server (default is 1645)";
        tailf:cli-hide-in-submode;
        type uint16 {
          tailf:info "<0-65535>;;Authentication port number";
          range "0..65535";
        }
      }

      // radius-server host * acct-port
      leaf acct-port {
        tailf:info "UDP port for RADIUS accounting server (default is 1646)";
        tailf:cli-hide-in-submode;
        type uint16 {
          tailf:info "<0-65535>;;Accounting port number";
          range "0..65535";
        }
      }

      // radius-server host * / key
      container "key" {
        tailf:info "per-server encryption key (overrides default)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses key-grouping;
      }

      // radius-server host * / timeout
      leaf timeout {
        tailf:info "Time to wait for this RADIUS server to reply "+
          "(overrides global timeout)";
        type uint16 {
          tailf:info "<1-1000>;;Timeout value in seconds to wait "+
            "for server to reply";
          range "1..1000";
        }
      }

      // radius-server host * / retransmit
      leaf retransmit {
        tailf:info "Number of times a RADIUS request is re-sent to a server "+
          "(overrides global retransmit value)";
        type uint8 {
          tailf:info "<1-100>;;Retransmit value";
        }
      }
    }

    // radius-server key
    container "key" {
      tailf:info "Set RADIUS encryption key";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses key-grouping;
    }

    // radius-server timeout
    leaf timeout {
      tailf:info "Time to wait for a RADIUS server to reply (default 5)";
      type uint16 {
        tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
      }
    }

    // radius-server retransmit
    leaf retransmit {
      tailf:info "Specify the number of retries to active server";
      type union {
        type uint8 {
          tailf:info "<1-100>;;Number of retries for a transaction (default is 3)";
        }
        type enumeration {
          enum disable {
            tailf:info "Disable Radius server retransmit";
          }
        }
      }
    }

    // radius-server source-port extended
    container source-port {
      tailf:info "Source-Port";
      leaf extended {
        tailf:info "Extended";
        type empty;
      }
    }

    // radius-server dead-criteria
    container dead-criteria {
      tailf:info "Dead server detection criteria for a configured RADIUS server";

      // radius-server dead-criteria time
      leaf time {
        tailf:info "Minimum time that must elapse since a response was received from this RADIUS server";
        type uint8 {
          tailf:info "<1-120>;;Time in seconds";
          range "1..120";
        }
      }

      // radius-server dead-criteria tries
      leaf tries {
        tailf:info "The minimum number of transmissions (original attempts plus retransmits) to this RADIUS server";
        type uint8 {
          tailf:info "<1-100>;;Number of tries";
          range "1..100";
        }
      }
    }
  }


  /// ========================================================================
  /// usergroup
  /// ========================================================================

  list usergroup {
    tailf:info "Configure user group";
    tailf:cli-mode-name "config-ug";
    tailf:cli-explicit-exit;
    //tailf:cli-diff-dependency "/cisco-ios-xr:taskgroup";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Usergroup name";
      }
    }

    // usergroup * / taskgroup
    leaf-list taskgroup {
      tailf:info "Task group associated with this group";
      tailf:cli-list-syntax;
      type string {
        tailf:info "WORD;;Name of the task group";
      }
    }

    // usergroup * / description
    leaf "description" {
      tailf:info "Description for the user group";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description for this group";
      }
    }
  }


  /// ========================================================================
  /// netconf
  /// ========================================================================

  container xnetconf {
    tailf:info "NETCONF configuration commands";
    tailf:alt-name netconf;
    tailf:cli-explicit-exit;

    container agent {
      tailf:info "NETCONF agent configuration commands";
      container tty {
        tailf:info "Enable NETCONF agent over TTY";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-netconf-tty";
        container session {
          tailf:info "Session timeout for transport agents";
          leaf timeout {
            tailf:info "Session timeout for agents";
            type uint16 {
              tailf:info "<1-1440>;;Timeout in minutes";
            }
          }
        }
        container throttle {
          tailf:info "Configuration for throttling NETCONF agent";
          leaf memory {
            tailf:info "Memory usage";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<100-600>;;Size of the memory usage in Mbytes "+
                "per session (default 300 Mbytes)";
              range "100..600";
            }
          }
          leaf process-rate {
            tailf:info "Process rate";
            type uint16 {
              tailf:info "<1000-30000>;;Number of tags to process per sec";
              range "1000..30000";
            }
          }
        }
      }
      leaf ssh {
        tailf:info "Enable NETCONF agent over SSH connection";
        type empty;
      }
    }
  }

  /// ========================================================================
  /// network-controller
  /// ========================================================================

  container network-controller {
    tailf:info "Configure Network Controller Functionality";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-net-ctrl";
    tailf:cli-explicit-exit;
    presence true;

    // network-controller / anycast-gateway
    container anycast-gateway {
      tailf:info "Anycast-gateway configuration";

      // network-controller / anycast-gateway mac
      leaf mac {
        tailf:info "MAC address of gateway";
        type string {
          tailf:info "H.H.H;;VSWitch MAC Address";
        }
      }
    }

    // network-controller / standby
    leaf standby {
      tailf:info "Set this network-controller in standby mode";
      tailf:cli-full-command;
      type empty;
    }

    // network-controller / dhcp-server
    leaf dhcp-server {
      tailf:info "Set the DHCP Server Address for this network-controller "
        +"domain";
      tailf:cli-full-command;
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;DHCP Server IP Address";
      }
    }

    // network-controller / switch *
    list "switch" {
      tailf:info "Switch to configure";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "mac ip-address";
      leaf mac {
        tailf:info "MAC address of Switch";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "H.H.H;;VSWitch MAC Address";
        }
      }
      leaf ip-address {
        tailf:info "VSwitch Nexthop Address";
        tailf:cli-expose-key-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Switch IP Address";
        }
      }
    }
  }


  /// ========================================================================
  /// netconf-yang
  /// ========================================================================

  container netconf-yang {
    tailf:info "NETCONF YANG configuration commands";
    tailf:cli-explicit-exit;

    // netconf-yang agent
    container agent {
      tailf:info "NETCONF YANG agent configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ncy-agent";
      presence true;

      // netconf-yang agent / ssh
      leaf ssh {
        tailf:info "Enable NETCONF-YANG agent over SSH connection";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// nsr
  /// ========================================================================

  container nsr {
    tailf:info "Global NSR configuration commands";
    tailf:cli-explicit-exit;

    leaf process-failures {
      tailf:info "Recovery action for Process failures on active RP/DRP";
      type enumeration {
        enum switchover {
          tailf:info "Switch over to standby RP/DRP to maintain NSR";
        }
      }
    }
  }


  /// ========================================================================
  /// ftp
  /// ========================================================================

  container ftp {
    tailf:info "Global FTP configuration commands";
    tailf:cli-explicit-exit;

    container client {
      tailf:info "FTP client configuration commands";

      // ftp client passive
      leaf passive {
        tailf:info "Connect using passive mode";
        type empty;
      }

      // ftp client password
      container password {
        tailf:info "Specify password for ftp connection";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping;
      }

      // ftp client username
      leaf username {
        tailf:info "Specify username for FTP connections";
        type string {
          tailf:info "WORD;;FTP username";
        }
      }

      // ftp client vrf *
      list vrf {
        tailf:info "VRF name for FTP service";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of VRF";
          }
        }

        // ftp client vrf * source-interface
        container source-interface {
          tailf:info "Specify interface for source address in FTP connections";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }

      // ftp client source-interface
      container source-interface {
        tailf:info "Specify interface for source address in FTP connections";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
    }
  }


  /// ========================================================================
  /// icmp
  /// ========================================================================

  container icmp {
    tailf:info "ICMP options";
    tailf:cli-explicit-exit;

    container ipv4 {
      tailf:info "IPv4 specific";

      // icmp ipv4 source
      container source {
        tailf:info "source address selection policy";

        // icmp ipv4 source rfc
        leaf rfc {
          tailf:info "Enable RFC compliance for source address selection";
          tailf:cli-full-command;
          type empty;
        }

        // icmp ipv4 source vrf
        leaf vrf {
          tailf:info "Enable Strct VRF source address selection";
          tailf:cli-full-command;
          type empty;
        }
      }

      // icmp ipv4 rate-limit unreachable
      container rate-limit {
        tailf:info "rate limit generation of ICMP messages";
        container unreachable {
          tailf:info "Destination Unreachable (type3)";

          // icmp ipv4 rate-limit unreachable DF
          leaf DF {
            tailf:info "Fragmentation needed and DF set (code4)";
            type union {
              type uint32 {
                tailf:info "<1-4294967295>;;One ICMP unreachable message "+
                  "in x milliseconds(default is 500ms)";
              }
              type enumeration {
                enum disable {
                  tailf:info "Disable rate limit of ICMP messages";
                }
              }
            }
          }

          // icmp ipv4 rate-limit unreachable
          leaf milliseconds {
            tailf:cli-drop-node-name;
            type union {
              type uint32 {
                tailf:info "<1-4294967295>;;One ICMP unreachable message "+
                  "in x milliseconds(default is 500ms)";
              }
              type enumeration {
                enum disable {
                  tailf:info "Disable rate limit of ICMP messages";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ntp
  /// ========================================================================

  container ntp {
    tailf:info "Go into NTP submode";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;

    // ntp / max-associations
    leaf max-associations {
      tailf:info "Set maximum number of associations";
      type uint32 {
        tailf:info "<0-4294967295>;;Number of associations";
      }
    }

    // ntp / server *
    container server {
      tailf:info "Configure NTP server";
      uses ntp-server-grouping;

      // ntp / server vrf *
      list vrf {
        tailf:info "Specify non-default VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Non-default VRF of peer";
          }
        }
        uses ntp-server-grouping;
      }
    }

    // ntp / access-group *
    list access-group {
      tailf:info "Control NTP access";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-suppress-list-no;
      key "type name";
      leaf "type" {
        type enumeration {
          enum peer {
            tailf:info "Provide full access";
          }
          enum query-only {
            tailf:info "Allow only control queries";
          }
          enum serve {
            tailf:info "Provide server and query access";
          }
          enum serve-only {
            tailf:info "Provide only server access";
          }
        }
      }
      leaf name {
        //tailf:cli-diff-dependency "/cisco-ios-xr:ipv4/access-list/named-acl";
        //tailf:cli-diff-dependency "/cisco-ios-xr:ipv6/access-list/named-acl";
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
        }
      }
      leaf vrf {
        tailf:info "Specify non-default VRF";
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Non-default VRF of peer";
        }
      }
      leaf version {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum ipv4 {
            tailf:info "Configure IPv4 access";
          }
          enum ipv6 {
            tailf:info "Configure IPv6 access";
          }
        }
      }
    }

    // ntp / interface *
    list interface {
      tailf:info "Configure NTP on an interface";
      tailf:cli-mode-name "config-ntp-int";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // ntp / interface * / broadcast
      container broadcast {
        tailf:info "Configure NTP broadcast service";
        tailf:cli-delete-when-empty;
        presence true;
        // ntp / interface * / broadcast version
        leaf version {
          tailf:info "Configure NTP version";
          type int8 {
            tailf:info "<1-4>;;NTP version number";
            range "1..4";
          }
        }
      }
    }

    // ntp / master
    leaf master {
      tailf:info "Choose a refclock as master clock for NTP";
      tailf:cli-full-command;
      type uint16;
    }

    // ntp / source
    container source {
      tailf:info "Configure default interface";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      uses interface-name-grouping;
    }

    // ntp / update-calendar
    leaf update-calendar {
      tailf:info "Periodically update calendar with NTP time";
      tailf:cli-full-command;
      type empty;
    }

    // ntp / authentication-key * md5
    list authentication-key {
      tailf:info "Authentication key for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-65535>;;Key number";
          range "1..65535";
        }
      }
      container md5 {
        tailf:info "MD5 authentication";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping {
          refine "secret" {
            tailf:meta-data "secret-password" {
              tailf:meta-value "ntp<NL><*> ::  authentication-key <authentication-key> md5 <PASSWORD>";
            }
          }
        }
      }
    }

    // ntp / authenticate
    leaf authenticate {
      tailf:info "Authenticate time sources";
      type empty;
    }

    // ntp / trusted-key *
    leaf-list trusted-key {
      tailf:info "Key numbers for trusted time sources";
      tailf:cli-list-syntax;
      type uint16 {
        tailf:info "<1-65535>;;Key number";
      }
    }
  }


  /// ========================================================================
  /// rcp
  /// ========================================================================

  container rcp {
    tailf:info "Global RCP configuration commands";

    // rcp client
    container client {
      tailf:info "RCP client configuration commands";

      // rcp client source-interface
      container source-interface {
        tailf:info "Specify interface for source address in RCP connections";
        uses interface-name-grouping;
      }
    }
  }


  /// ========================================================================
  /// telnet
  /// ========================================================================

  container telnet {
    tailf:info "Global Telnet configuration commands";
    tailf:cli-explicit-exit;

    // telnet ipv4 client source-interface
    container ipv4 {
      tailf:info "IPv4 configuration";
      container client {
        tailf:info "Telnet client configuration commands";
        container source-interface {
          tailf:info "Source interface for telnet sessions";
          uses interface-name-grouping;
        }
      }
    }

    // telnet ipv6 client source-interface
    container ipv6 {
      tailf:info "IPv6 configuration";
      container client {
        tailf:info "Telnet client configuration commands";
        container source-interface {
          tailf:info "Source interface for telnet sessions";
          uses interface-name-grouping;
        }
      }
    }

    // telnet *
    uses telnet-server-grouping;

    // telnet vrf *
    list vrf {
      tailf:info "VRF name for telnet server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-incomplete-command;
      //tailf:cli-diff-dependency "/cisco-ios-xr:vrf";
      key name;
      leaf name {
        type vrf-type;
      }
      uses telnet-server-grouping;
    }
  }


  /// ========================================================================
  /// bfd
  /// ========================================================================

  container bfd {
    tailf:info "Global BFD configuration commands";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-bfd";
    tailf:cli-explicit-exit;

    // bfd / interface *
    list interface {
      tailf:info "Configure BFD on an interface";
      tailf:cli-mode-name "config-bfd-if";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // bfd / interface * / echo
      leaf echo {
        tailf:info "Configure BFD echo mode";
        tailf:cli-full-command;
        type empty;
      }

      // bfd / interface * / echo X
      container echo-conf {
        tailf:cli-drop-node-name;
        container echo {
          tailf:info "Configure BFD echo mode";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;

          // bfd / interface * / echo disable
          leaf disable {
            tailf:info "Disable BFD echo mode for this interface";
            tailf:cli-full-command;
            type empty;
          }

          // bfd / interface * / echo ipv4 source
          container ipv4 {
            tailf:info "IPv4 commands";
            leaf source {
              tailf:info "BFD echo source IP addres";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address";
              }
            }
          }
        }
      }
    }

    // bfd / multihop ttl-drop-threshold
    container multihop {
      tailf:info "Configure BFD multihop";
      leaf ttl-drop-threshold {
        tailf:info "TTL Drop Threshold";
        type uint8 {
          tailf:info "<0-254>;;Drop Threshold";
          range "0..254";
        }
      }
    }

    // bfd / multipath include location *
    container multipath {
      tailf:info "Configure BFD multiple path";
      container "include" {
        tailf:info "Include a LC node";
        list location {
          tailf:info "Specify a location";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Fully qualified location specification";
            }
          }
        }
      }
    }

    // bfd / echo
    container echo {
      tailf:info "Configure BFD echo parameters";
      leaf disable {
        tailf:info "Disable BFD echo mode";
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
    }

    // bfd / trap
    container trap {
      tailf:info "Configure BFD trap parameters";
      container singlehop {
        tailf:info "Configure BFD mode";
        leaf pre-mapped {
          tailf:info "Configure BFD trap pre-mapped";
          type empty;
        }
      }
    }

    // bfd / dampening
    container dampening {
      tailf:info "Configure BFD dampening intervals";

      // bfd / dampening bundle-member
      container bundle-member {
        tailf:info "Configure BFD dampening for bfd over bundle per member feature";

        // bfd / dampening bundle-member l3-only-mode
        leaf l3-only-mode {
          tailf:info "Apply immedite dampening and only when failure is L3 specific";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// sbfd
  /// ========================================================================

  // sbfd
  container sbfd {
    tailf:info "Global SBFD configuration commands ";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-sbfd";
    tailf:cli-explicit-exit;

    // sbfd / remote-target
    container remote-target {
      tailf:info "configure remote-target";

      // sbfd / remote-target ipv4 *
      list ipv4 {
        tailf:info "Ipv4 address only";
        tailf:cli-mode-name "config-sbfd-rtarget";
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address";
          }
        }

        // sbfd / remote-target ipv4 * / remote-discriminator
        leaf remote-discriminator {
          tailf:info "Configure remote-discriminator";
          type uint32 {
            tailf:info "<1-4294967295>;;32-bit remote-discriminator";
            range "1..4294967295";
          }
        }
      }
    }

    // sbfd / local-discriminator
    container local-discriminator {
      tailf:info "configure local-discriminator";

      // sbfd / local-discriminator *
      list address-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key ipv4;
        leaf ipv4 {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;ipv4 address as local-discriminator";
          }
        }
      }

      // sbfd / local-discriminator *
      list id-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-4294967295>;;32-bit local-discriminator";
          }
        }
      }

      // sbfd / local-discriminator dynamic
      leaf dynamic {
        tailf:info "configure local-discriminator dynamically";
        tailf:cli-full-command;
        type empty;
      }

      // sbfd / local-discriminator interface *
      list interface {
        tailf:info "Interface whose IPv4 address is to be used as local discriminator";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type ifname;
        }
      }
    }
  }


  /// ========================================================================
  /// tftp
  /// ========================================================================

  container tftp {
    tailf:info "Global TFTP configuration commands";
    tailf:cli-explicit-exit;
    //tailf:cli-diff-dependency "/cisco-ios-xr:ipv4/access-list";

    // tftp client
    container client {
      tailf:info "TFTP client configuration commands";

      // tftp client vrf *
      list vrf {
        tailf:info "VRF name for TFTP service";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of VRF";
          }
        }

        // tftp client vrf * source-interface
        container source-interface {
          tailf:info "Specify interface for source address in TFTP connections";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }

      // tftp client source-interface
      container source-interface {
        tailf:info "Specify interface for source address in TFTP connections";
        uses interface-name-grouping;
      }
    }

    // tftp *
    uses tftp-server-grouping;

    // tftp vrf *
    list vrf {
      tailf:info "VRF name for tftp server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-incomplete-command;
      //tailf:cli-diff-dependency "/cisco-ios-xr:vrf";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of VRF";
        }
      }
      uses tftp-server-grouping;
    }
  }


  /// ========================================================================
  /// nv
  /// ========================================================================

  container nv {
    tailf:info "Network Virtualisation configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-nV";
    tailf:cli-explicit-exit;

    // nv / optical
    container optical {
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-nV-optical";

      // nv / optical / satellite *
      list satellite {
        tailf:info "Satellite configuration";
        tailf:cli-mode-name "config-nV-optical-satellite";
        key id;
        leaf id {
          type uint32 {
            tailf:info "NUM;;Satellite ID";
          }
        }

        // nv / optical / satellite * / ipv6
        container ipv6 {
          leaf address {
            type inet:ipv6-address;
          }
        }

        // nv / optical / satellite * / username
        container username {
          tailf:cli-compact-syntax;
          leaf name {
            tailf:cli-drop-node-name;
            type string;
          }
          leaf password {
            type string;
          }
        }

        // nv / optical / satellite * / trunk slot *
        container trunk {
          list slot {
            key id;
            leaf id {
              type uint32;
            }
            leaf port {
              tailf:cli-hide-in-submode;
              type uint32;
            }
            leaf local-port {
              tailf:cli-hide-in-submode;
              type string;
            }
          }
        }
      }
    }

    // nv / controller
    container controller {

      // nv controller dwdm *
      // FIXME: differs on g709 and proactive
      uses controller-dwdm-grouping;

      // nv controller HundredGigE *
      list HundredGigE {
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          type string {
            pattern "[0-9]+(/[0-9]+)*";
          }
        }
        leaf admin-state {
          type enumeration {
            enum in-service;
            enum maintenance;
            enum out-of-service;
            enum in-service-config-allowed;
          }
        }
      }
    }

    // nv / satellite *
    list satellite {
      tailf:info "ICPE satellite configuration";
      tailf:cli-mode-name "config-satellite";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<100-65534>;;Satellite ID";
          range "100..65534";
        }
      }

      // nv / satellite * / type
      leaf "type" {
        tailf:info "Satellite type";
        type string {
          tailf:info "WORD;;Satellite type";
        }
      }

      // nv / satellite * / ipv4 address
      container ipv4 {
        tailf:info "IPv4 address";
        leaf address {
          tailf:info "IPv4 address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address";
          }
        }
      }

      // nv / satellite * / redundancy
      container redundancy {
        tailf:info "Redundancy configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-nV-red";

        // nv / satellite * / redundancy / host-priorityp
        leaf host-priority {
          tailf:info "Priority of this host for the given satellite";
          type uint8 {
            tailf:info "<0-255>;;Priority. A lower number denotes a higher "+
              "priority. (Default: 128)";
          }
        }
      }

      // nv / satellite * / serial-number
      leaf serial-number {
        tailf:info "Serial number of the connected satellite";
        type string {
          tailf:info "WORD;;Satellite serial number";
        }
      }

      // nv / satellite * / description
      leaf "description" {
        tailf:info "Satellite description.";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
          type string {
            tailf:info "WORD;;description";
          }
      }

      // nv / satellite * / secret
      container secret {
        tailf:info "Secure";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf "type" {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum "5" {
              tailf:info "Specifies an ENCRYPTED secret will follow";
            }
          }
        }
        leaf secret {
          tailf:cli-drop-node-name;
          tailf:cli-reset-container;
          tailf:meta-data "secret-password";
          type string {
            tailf:info "LINE;;The ENCRYPTED secret string";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// enable
  /// ========================================================================

  container enable {
    tailf:info "Modify enable password parameters";
    tailf:cli-explicit-exit;

    container password {
      tailf:info "Assign the privileged level password (MAX of 25 characters)";
    }

    container secret {
      tailf:info "Assign the privileged level secret (MAX of 25 characters)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf "type" {
        tailf:cli-drop-node-name;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "5" {
            tailf:info "Specifies an ENCRYPTED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "LINE;;The ENCRYPTED 'enable' secret string";
        }
      }
    }
  }


  /// ========================================================================
  /// username
  /// ========================================================================

  // username *
  uses username-grouping;


  /// ========================================================================
  /// tacacs-server
  /// ========================================================================

  container tacacs-server {
    tailf:info "TACACS+ server definition";
    tailf:cli-explicit-exit;

    // tacacs-server host *
    list host {
      tailf:info "Specify a TACACS+ server";
      tailf:cli-compact-syntax;
      tailf:cli-mode-name "config-tacacs-host";
      tailf:cli-show-long-obu-diffs;
      ordered-by "user";
      key "name port";
      leaf name {
        type inet:host {
          tailf:info "Hostname or A.B.C.D  IP address of TACACS+ server";
        }
      }
      leaf port {
        tailf:info "TCP port for TACACS+ server (default is 49)";
        tailf:cli-expose-key-name;
        type uint16 {
          tailf:info "<1-65535>;;Port number";
          range "1..65535";
        }
      }

      // tacacs-server host * / key
      container "key" {
        tailf:info "per-server encryption key (overrides default)";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum 0 {
              tailf:info "Specifies that an UNENCRYPTED key will follow";
            }
            enum 7 {
              tailf:info "Specifies that an encrypted key will follow";
            }
          }
        }
        leaf "key" {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;The UNENCRYPTED (cleartext) key";
          }
        }
      }

      // tacacs-server host * / timeout
      leaf timeout {
        tailf:info "Time to wait for this TACACS server to reply "+
          "(overrides default)";
        type uint16 {
          tailf:info "<1-1000>;;Timeout value in seconds to wait for "+
            "server to reply";
          range "1..1000";
        }
      }
    }

    // tacacs-server key
    container "key" {
      tailf:info "Set TACACS+ encryption key";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum 0 {
            tailf:info "Specifies that an UNENCRYPTED key will follow";
          }
          enum 7 {
            tailf:info "Specifies that an encrypted key will follow";
          }
        }
      }
      leaf "key" {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) key";
        }
      }
    }

    // tacacs-server timeout
    leaf timeout {
      tailf:info "Time to wait for a TACACS server to reply";
      type uint16 {
        tailf:info "<1-1000>;;Wait time (default 5 seconds)";
        range "1..1000";
      }
    }

  }


  /// ========================================================================
  /// tacacs
  /// ========================================================================

  container tacacs {
    tailf:info "TACACS+ configuration commands";
    tailf:cli-explicit-exit;

    // tacacs source-interface
    container source-interface {
      tailf:info "Specify interface for source address in TACACS+ packets";
      //tailf:cli-diff-dependency "/cisco-ios-xr:vrf";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      uses interface-name-grouping;
      leaf vrf {
        tailf:info "VRF for this source interface configuration";
        type string {
          tailf:info "WORD;;Name of the VRF";
        }
      }
    }
  }


  /// ========================================================================
  /// aaa
  /// ========================================================================

  container aaa {
    tailf:info "Authentication, Authorization and Accounting.";
    tailf:cli-explicit-exit;

    // aaa new-model
    leaf new-model {
      tailf:info "Enable NEW access control commands and functions."
        +" (Disables OLD commands.)";
      tailf:cli-full-command;
      type empty;
    }

    // aaa server radius dynamic-author
    container server {
      tailf:info "AAA Server";
      container radius {
        tailf:info "AAA Server - Radius Definition";
        container dynamic-author {
          tailf:info "Radius Dynamic Author Server Configurations";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-dynamic-author";

          // aaa server radius dynamic-author / port
          leaf port {
            tailf:info "Specify the COA Server port to listen on";
            type uint16 {
              tailf:info "<1000-5000>;;port number";
              range "1000..5000";
            }
          }

          // aaa server radius dynamic-author / client * vrf *
          list client {
            tailf:info "COA client configuration";
            tailf:cli-mode-name "config-dynamic-author-client";
            key "address vrf";
            leaf address {
              type inet:host {
                tailf:info "A.B.C.D or X:X::X;;IP address of COA Client";
              }
            }
            leaf vrf {
              tailf:info "VRF to which COA Client belongs";
              tailf:cli-expose-key-name;
              type vrf-type;
            }

            // aaa server radius dynamic-author / client * vrf * / server-key
            container server-key {
              tailf:info "COA client shared secret key";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses key-grouping;
            }
          }
        }
      }
    }

    // aaa group server
    container group {
      tailf:info "AAA group definitions";
      container server {
        tailf:info "AAA Server group definitions";

        // aaa group server radius *
        list radius {
          tailf:info "Radius server-group definition";
          tailf:cli-mode-name "config-sg-radius";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server-group name";
            }
          }

          // aaa group server radius * / vrf
          leaf vrf {
            tailf:info "VRF to which this server group belongs to";
            type string {
              tailf:info "WORD;;Name of the VRF";
            }
          }

          // aaa group server radius * / server *
          container server {
            tailf:info "Specify a RADIUS server";

            // aaa group server radius * / server name *
            list name {
              tailf:info "WORD;;Name of radius server";
              key name;
              leaf name {
                tailf:non-strict-leafref {
                  path "/cisco-ios-xr:aaa/group/server/radius/name";
                }
                type string {
                }
              }
            }

            // aaa group server radius * / server *
            list direct {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key name;
              leaf name {
                tailf:cli-disallow-value "name";
                type inet:host {
                  tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
                }
              }
              leaf auth-port {
                tailf:info "UDP port for RADIUS authentication server (default is 1645)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }
              leaf acct-port {
                tailf:info "UDP port for RADIUS accounting server (default is 1646)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }
            }
          }

          // aaa group server radius * / ip vrf forwarding
          container ip {
            tailf:info "Internet Protocol config commands";
            container vrf {
              tailf:info "Set VPN Routing Forwarding to use with the servers";
              leaf forwarding {
                tailf:info "Configure forwarding table";
                type string {
                  tailf:info "WORD;;Table name";
                }
              }
            }
          }

          // aaa group server radius * / deadtime
          leaf deadtime {
            tailf:info "Time in minutes after which a RADIUS server will be marked UP after it has gone dead";
            type uint16 {
              tailf:info "<1-1440>;;Deadtime limit in minutes (default 0)";
              range "1..1440";
            }
          }

          // aaa group server radius * / source-interface
          container source-interface {
            tailf:info "Specify interface for source address in RADIUS packets";
            uses interface-name-grouping;
          }
        }

        // aaa group server tacacs+ *
        list tacacs {
          tailf:alt-name "tacacs+";
          tailf:info "tacacs+  TACACS+ server-group definition";
          tailf:cli-mode-name "config-sg-tacacs";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server group name";
            }
          }
          leaf-list server {
            tailf:info "Specify a TACACS+ server";
            tailf:cli-list-syntax;
            type inet:host {
              tailf:info "Hostname or A.B.C.D IP address or "+
                "Hostname of TACACS+ server";
            }
          }
          leaf vrf {
            tailf:info "VRF to which this server group belongs to";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Name of the VRF";
            }
          }
        }
      }
    }

    // aaa authentication
    container authentication {
      tailf:info "Authentication configurations parameters.";

      // aaa authentication login *
      list login {
        tailf:info "Set authentication lists for logins.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named authentication list (max 31 characters)";
            length "1..31";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }

      // aaa authentication subscriber *
      list subscriber {
        tailf:info "Set authentication lists for Subscriber";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authentication";
            length "1..31";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }
    }

    // aaa authorization
    container authorization {
      tailf:info "Authorization configurations parameters.";

      // aaa authorization commands *
      list commands {
        tailf:info "For EXEC (shell) commands";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authorization";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }

      // aaa authorization exec *
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authorization";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }

      // aaa authorization eventmanager *
      list eventmanager {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authorization";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }

      // aaa authorization subscriber *
      list subscriber {
        tailf:info "Set authorization lists for Subscriber";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authorization";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }
    }

    // aaa accounting
    container accounting {
      tailf:info "Accounting configurations parameters.";

      // aaa accounting exec *
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named Accounting list";
          }
        }
        leaf notice {
          tailf:cli-drop-node-name;
          type enumeration {
            enum start-stop {
              tailf:info "start and stop records";
            }
            enum stop-only {
              tailf:info "stop records only";
            }
          }
        }
        leaf group {
          tailf:info "Use Server-group";
          tailf:cli-optional-in-sequence;
          type union {
            type string {
              tailf:info "WORD;;server-group name";
            }
            type enumeration {
              enum radius {
                tailf:info "Use list of all Radius hosts";
              }
              enum "tacacs+" {
                tailf:info "Use list of all TACACS+ hosts";
              }
            }
          }
        }
        leaf none {
          tailf:info "No accounting";
          type empty;
        }
      }

      // aaa accounting system *
      list system {
        tailf:info "For System events";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named Accounting list";
          }
        }
        leaf start-stop {
          tailf:info "start and stop records";
          type empty;
        }
        leaf group {
          tailf:info "Use Server-group";
          tailf:cli-optional-in-sequence;
          type union {
            type string {
              tailf:info "WORD;;server-group name";
            }
            type enumeration {
              enum radius {
                tailf:info "Use list of all Radius hosts";
              }
              enum "tacacs+" {
                tailf:info "Use list of all TACACS+ hosts";
              }
            }
          }
        }
        leaf none {
          tailf:info "No accounting";
          type empty;
        }
      }

      // aaa accounting network *
      list network {
        tailf:info "For network services (such as IKE, PPP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named Accounting list";
          }
        }
        leaf notice {
          tailf:cli-drop-node-name;
          type enumeration {
            enum start-stop {
              tailf:info "start and stop records";
            }
            enum stop-only {
              tailf:info "stop records only";
            }
          }
        }
        leaf group {
          tailf:info "Use Server-group";
          tailf:cli-optional-in-sequence;
          type union {
            type string {
              tailf:info "WORD;;server-group name";
            }
            type enumeration {
              enum radius {
                tailf:info "Use list of all Radius hosts";
              }
              enum "tacacs+" {
                tailf:info "Use list of all TACACS+ hosts";
              }
            }
          }
        }
        leaf none {
          tailf:info "No accounting";
          type empty;
        }
      }

      // aaa accounting commands *
      list commands {
        tailf:info "For EXEC (shell) commands";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named Accounting list";
          }
        }
        leaf notice {
          tailf:cli-drop-node-name;
          type enumeration {
            enum start-stop {
              tailf:info "start and stop records";
            }
            enum stop-only {
              tailf:info "stop records only";
            }
          }
        }
        leaf group {
          tailf:info "Use Server-group";
          tailf:cli-optional-in-sequence;
          type union {
            type string {
              tailf:info "WORD;;server-group name";
            }
            type enumeration {
              enum radius {
                tailf:info "Use list of all Radius hosts";
              }
              enum "tacacs+" {
                tailf:info "Use list of all TACACS+ hosts";
              }
            }
          }
        }
        leaf none {
          tailf:info "No accounting";
          type empty;
        }
      }

      // aaa accounting subscriber *
      list subscriber {
        tailf:info "Set accounting lists for Subscriber";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA accounting";
          }
        }
        leaf broadcast {
          tailf:info "Set broadcast accounting for Subscriber";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf group {
          tailf:info "Use Server-group";
          type string {
            tailf:info "WORD;;server-group name";
          }
        }
      }
    }

    // aaa session-id
    leaf session-id {
      tailf:info "AAA Session ID";
      tailf:cli-full-command;
      type enumeration {
        enum common {
          tailf:info "Common Session ID";
        }
        enum "unique" {
          tailf:info "Unique Session ID for different accounting types";
        }
      }
    }

    // aaa default-taskgroup
    leaf default-taskgroup {
      tailf:info "Default taskgroup to be used for remote authentication";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of the taskgroup to be used";
      }
    }

    // aaa intercept
    container intercept {
      presence true;
    }
  }


  /// ========================================================================
  /// cdp
  /// ========================================================================

  container cdp {
    tailf:info "Enable CDP, or configure global CDP subcommands";
    tailf:cli-display-separated;
    presence true;

    // cdp advertise v1
    container advertise {
      tailf:info "Specify the version of CDP advertisements";
      leaf v1 {
        tailf:info "CDP sends version-1 advertisements only";
        type empty;
      }
    }

    // cdp timer
    leaf timer {
      tailf:info "Specify the rate at which CDP packets are sent (in sec)";
      type uint8 {
        tailf:info "<5-254>;;Rate at which CDP packets are sent (in sec)";
        range "5..254";
      }
    }

    // cdp holdtime
    leaf holdtime {
      tailf:info "Specify the holdtime (in sec) to be sent in packets";
      type uint8 {
        tailf:info "<10-255>;;Length of time (in sec) that receiver must "+
          "keep this packet";
        range "10..255";
      }
    }
  }


  /// ========================================================================
  /// tcp
  /// ========================================================================

  container tcp {
    tailf:info "Global TCP configuration commands";
    tailf:cli-explicit-exit;

    // tcp mss
    leaf mss {
      tailf:info "Set the TCP initial maximum segment size";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<68-10000>;;TCP initial maximum segment size";
        range "68..10000";
      }
    }

    // tcp selective-ack
    leaf selective-ack {
      tailf:info "Enable TCP selective-ACK";
      type empty;
    }


    // tcp path-mtu-discovery
    container path-mtu-discovery {
      tailf:info "Enable Path MTU Discovery on new TCP connections";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf age-timer {
        type union {
          type uint8 {
            tailf:info "<10-30>;;Aging time (in minutes)";
          }
          type enumeration {
            enum infinite {
              tailf:info "Disable Path MTU aging timer";
            }
          }
        }
      }
    }

    // tcp timestamp
    leaf timestamp {
      tailf:info "Enable TCP timestamp option";
      type empty;
    }

    // tcp directory
    container directory {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf directory {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Place debug files in this directory";
        }
      }
      leaf files {
        tailf:cli-break-sequence-commands;
        tailf:info "Set maximum debug files";
        type uint16 {
          tailf:info "<1-10000>;;Maximum debug files";
        }
      }
      leaf size {
        tailf:info "Set maximum file size";
        type uint32 {
          tailf:info "<1024-4294967295>;;Maximum file size in bytes";
          range "1024..4294967295";
        }
      }
    }

    // tcp window-size
    leaf window-size {
      tailf:info "TCP receive window size";
      type uint32 {
        tailf:info "<2048-65535>;;Window size (bytes)";
      }
    }

    // tcp synwait-time
    leaf synwait-time {
      tailf:info "Set time to wait on new TCP connections";
      type uint8 {
        tailf:info "<5-30>;;Wait time in seconds";
        range "5..30";
      }
    }
  }


  /// ========================================================================
  /// line
  /// ========================================================================

  container line {
    tailf:info "Line subcommands";
    tailf:cli-explicit-exit;
    //tailf:cli-diff-dependency "/cisco-ios-xr:ipv4/access-list/named-acl";
    //tailf:cli-diff-dependency "/cisco-ios-xr:ipv6/access-list/named-acl";

    // line console
    container console {
      tailf:info "console template";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-line";
      uses line-grouping;
    }

    // line default
    container "default" {
      tailf:info "default template";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-line";
      uses line-grouping;
    }

    // line template *
    list template {
      tailf:info "user defined template";
      tailf:cli-mode-name "config-line";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of template to configure";
        }
      }
      uses line-grouping;
    }
  }


  /// ========================================================================
  /// pool
  /// ========================================================================

  container pool {
    tailf:info "Distributed Address Pool Service";
    tailf:cli-explicit-exit;

    // pool vrf * ipv4 *
    list vrf {
      tailf:info "Specify VRF name";
      tailf:cli-mode-name "config-pool-ipv4";
      key "vrf ipv4";
      leaf vrf {
        type string {
          tailf:info "WORD;;Enter the VRF name";
        }
      }
      leaf ipv4 {
        tailf:info "Specify IPv4 Pool name";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Enter the IPv4 Pool name";
        }
      }

      // pool vrf * ipv4 * / network *
      list network {
        tailf:info "Specify network for allocation";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "prefix";
        leaf "prefix" {
          type ipv4-prefix {
            tailf:info "A.B.C.D/length;;IP Network";
          }
        }
      }

      // pool vrf * ipv4 * / address-range *
      list address-range {
        tailf:info "Specify address range for allocation";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key first_range;
        leaf first_range {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Specify first address in range";
          }
        }
        leaf last_range {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Specify last address in range";
          }
        }
      }

      // pool vrf * ipv4 * / utilization-mark
      container utilization-mark {
        tailf:info "Specify utilization mark";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf high {
          tailf:info "Specify high mark";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-100>;;Specify numerical value as percentage";
            range "0..100";
          }
        }
        leaf low {
          tailf:info "Specify low mark";
          type uint8 {
            tailf:info "<0-100>;;Specify numerical value as percentage";
            range "0..100";
          }
        }
      }
    }

    // pool vrf * ipv6 *
    container pool-ipv6 {
      tailf:cli-drop-node-name;

      list vrf {
        tailf:info "Specify VRF name";
        tailf:cli-mode-name "config-pool-ipv6";
        key "vrf ipv6";
        leaf vrf {
          type string {
            tailf:info "WORD;;Enter the VRF name";
          }
        }
        leaf ipv6 {
          tailf:info "Specify IPv6 Pool name";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;Enter the IPv6 Pool name";
          }
        }

        // pool vrf * ipv6 * / prefix-length
        leaf prefix-length {
          tailf:info "Specify prefix-length to be used";
          type uint8 {
            tailf:info "<1-128>;;Enter the prefix-length";
            range "1..128";
          }
        }

        // pool vrf * ipv6 * / network
        leaf network {
          tailf:info "Specify network for allocation";
          type tailf:ipv6-address-and-prefix-length {
            tailf:info "X:X::X/length;;Enter IPv6 prefix";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vty-pool
  /// ========================================================================

  container vty-pool {
    tailf:info "VTY Pools";
    tailf:cli-explicit-exit;

    // vty-pool default
    container "default" {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses vty-pool-grouping;
    }

    // vty-pool eem
    container eem {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses vty-pool-grouping;
    }

    // vty-pool *
    list pool-name-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key pool-name;
      leaf pool-name {
        tailf:cli-disallow-value "(eem|default)";
        type string {
          tailf:info "WORD;;VTY range";
        }
      }
      uses vty-pool-grouping;
    }
  }


  /// ========================================================================
  /// aps
  /// ========================================================================

  container aps {
    tailf:info "Configure SONET Automatic Protection Switching (APS)";
    tailf:cli-explicit-exit;

    // aps group *
    list group {
      tailf:info "APS group to configure";
      tailf:cli-mode-name "config-aps";
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-255>;;Group number";
          range "1..255";
        }
      }

      // aps group * / revert
      leaf revert {
        tailf:info "Set revertive operation";
        type uint8 {
          tailf:info "<0-255>;;Revert time in minutes "+
            "(default = 0 - non-revertive APS)";
        }
      }

      // aps group * / timers
      container timers {
        tailf:info "Set APS W-P communication timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf hello {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Hello timer in seconds (default 1)";
            range "1..255";
          }
        }
        leaf hold {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Hold timer in seconds (default 3)";
            range "1..255";
          }
        }
      }

      // aps group * / channel *
      list channel {
        tailf:info "Assign a channel to an APS group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands  {
          tailf:cli-reset-siblings;
        }
        key "id location";
        leaf id {
          type uint8 {
            tailf:info "<0-1>;;Channel number (0 = Protect, 1 = Working)";
            range "0..1";
          }
        }
        leaf location {
          type enumeration {
            enum local {
              tailf:info "Channel assignment to a local port";
            }
            enum remote {
              tailf:info "Channel assignment to a remote router port";
            }
          }
        }
        leaf preconfigure {
          tailf:info "Specify a preconfig";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf data {
          tailf:cli-drop-node-name;
          type union {
            type string {
              tailf:info "SONET;;SONET/SDH Port controller(s)";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Remote router IP address";
            }
          }
        }
      }
    }

    // aps rprplus
    leaf rprplus {
      tailf:info "APS extend hold timer for failover";
      tailf:cli-full-command;
      type empty;
    }
  }


  /// ========================================================================
  /// platform
  /// ========================================================================

  container platform {
    tailf:info "platform specific configuration";
    tailf:cli-explicit-exit;

    // platform ip
    container ip {
      tailf:info "ip keyword";
      container cef {
        tailf:info "cef keyword";
        leaf load-sharing {
          tailf:info "load balancing";
          type enumeration {
            enum dst-only {
              tailf:info "load balancing algorithm to include"
                +" destination IP/L4 port";
            }
            enum full {
              tailf:info "default load balancing algorithm to include"
                +" src/dst IPs/L4 ports";
            }
            enum ip-only {
              tailf:info "load balancing algorithm to include src/dst IP";
            }
          }
        }
      }
    }
    container qos {
      tailf:info "qos keyword";
      leaf "qos-10g-only" {
        tailf:alt-name "10g-only";
        tailf:info "qos pure 10G mode";
        type empty;
      }
      list protocol {
        tailf:info "protocol keyword";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key proto;
        leaf proto {
          type enumeration {
            enum isis;
            enum eigrp;
            enum ldp;
            enum ospf;
            enum rip;
            enum bgp;
            enum hsrp;
            enum bfd;
            enum ospfv3;
            enum bgpv2;
            enum ripng;
            enum neigh-discover;
            enum wlccp;
            enum rsvp;
            enum rsvpv6;
            enum arp;
            enum gre {
              tailf:info "gre (ipv4 and ipv6)";
            }
            enum mpls {
              tailf:info "mpls packet";
            }
          }
        }

        choice proto-choice {
          leaf pass-through {
            tailf:info "pass-through keyword";
            type empty;
          }
          container police {
            tailf:info "police keyword";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            tailf:cli-sequence-commands;
            leaf bit-rate {
              tailf:cli-drop-node-name;
              type uint64 {
                tailf:info "<32000-128000000000>;;Target Bit Rate (bits"
                  +" per second) "
                  +"(postfix k, m, g optional; decimal point allo";
                range "32000..128000000000";
              }
            }

            leaf burst {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2000000000>;;Normal burst bytes";
                range "1..2000000000";
              }
            }
          }
          container precedence {
            tailf:info "change ip-precedence(used to map the dscp to"
              +" cos value)";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            tailf:cli-sequence-commands;
            leaf cos {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-7>;;new cos value";
                range "0..7";
              }
            }
            leaf bit-rate {
              tailf:cli-drop-node-name;
              type uint64 {
                tailf:info "<32000-128000000000>;;Target Bit Rate"
                  +" (bits per second) "
                  +"(postfix k, m, g optional; decimal point allo";
                range "32000..128000000000";
              }
            }
            leaf burst {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2000000000>;;Normal burst bytes";
                range "1..2000000000";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// control-plane
  /// ========================================================================

  container control-plane {
    tailf:info "Configure Control Plane";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-ctrl";
    tailf:cli-explicit-exit;

    // control-plane / management-plane
    container management-plane {
      tailf:info "Configure management plane protection";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mpp";

      // control-plane / management-plane / inband
      container inband {
        tailf:info "Configure an inband interface/protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mpp-inband";

        // control-plane / management-plane / inband / interface *
        list interface {
          tailf:info "Configure an inband interface";
          tailf:cli-mode-name "config-mpp-inband-xxx";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          list allow {
            tailf:info "Allow a protocol on this interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key proto;
            leaf proto {
              type control-plane-proto;
            }
          }
          // control-plane / management-plane / inband / interface * / ..
          // .. allow all peer
          container allow-peer {
            tailf:cli-drop-node-name;
            list allow {
              tailf:info "Allow a protocol on this interface";
              tailf:cli-mode-name "config-xxx-peer";
              key "proto peer";
              leaf proto {
                type control-plane-proto;
              }
              leaf peer {
                type enumeration {
                  enum peer {
                    tailf:info "Configure peer address on this interface";
                  }
                }
              }
              container address {
                tailf:info "Configure peer address on this interface";
                // address ipv4 *
                list ipv4 {
                  tailf:info "Configure peer IPv4 address on this interface";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key "prefix";
                  leaf "prefix" {
                    type union {
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;Enter IPv4 address";
                      }
                      type ipv4-prefix {
                        tailf:info "A.B.C.D/length;;Enter IPv4 address with prefix";
                      }
                    }
                  }
                }
                // address ipv6 *
                list ipv6 {
                  tailf:info "Configure peer IPv6 address on this interface";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key "prefix";
                  leaf "prefix" {
                    type union {
                      type tailf:ipv6-address-and-prefix-length {
                        tailf:info "X:X::X/length;;Enter IPv6 address with "+
                          "prefix";
                      }
                      type inet:ipv6-address {
                        tailf:info "X:X::X;;Enter IPv6 address";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      // control-plane / management-plane / out-of-band
      container out-of-band {
        tailf:info "Configure an out-of-band interface/protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mpp-outband";

        // control-plane / management-plane / out-of-band / interface *
        list interface {
          tailf:info "Configure an outband interface";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          list allow {
            tailf:info "Allow a protocol on this interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key proto;
            leaf proto {
              type control-plane-proto;
            }
          }

          // control-plane / management-plane / out-of-band / interface * / allow * peer
          container allow-peer {
            tailf:cli-drop-node-name;
            list allow {
              tailf:info "Allow a protocol on this interface";
              key "proto peer";
              leaf proto {
                type control-plane-proto;
              }
              leaf peer {
                type enumeration {
                  enum peer {
                    tailf:info "Configure peer address on this interface";
                  }
                }
              }

              // control-plane / management-plane / out-of-band / interface * / allow * peer / address
              container address {
                tailf:info "Configure peer address on this interface";

                // control-plane / management-plane / out-of-band / interface * / allow * peer / address ipv4 *
                list ipv4 {
                  tailf:info "Configure peer IPv4 address on this interface";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key address;
                  leaf address {
                    type union {
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;Enter IPv4 address";
                      }
                      type ipv4-prefix {
                        tailf:info "A.B.C.D/length;;Enter IPv4 address with prefix";
                      }
                    }
                  }
                }

                // control-plane / management-plane / out-of-band / interface * / allow * peer / address ipv6 *
                list ipv6 {
                  tailf:info "Configure peer IPv6 address on this interface";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key "prefix";
                  leaf prefix {
                    type union {
                      type tailf:ipv6-address-and-prefix-length {
                        tailf:info "X:X::X/length;;Enter IPv6 address "+
                          "with prefix";
                      }
                      type inet:ipv6-address {
                        tailf:info "X:X::X;;Enter IPv6 address";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ip
  /// ========================================================================

  container ip {
    tailf:info "Global IP configuration subcommands";
    tailf:cli-explicit-exit;

    // no ip domain-lookup
    container domain-lookup {
      tailf:info "Enable IP Domain Name System hostname translation";
      leaf do-lookup {
        tailf:cli-drop-node-name;
        type boolean;
        tailf:cli-boolean-no;
        default true;
      }
      leaf nsap {
        tailf:info "Enable IP DNS queries for CLNS NSAP addresses";
        type empty;
      }
    }

    // ip domain-name
    leaf domain-name {
      tailf:info "Define the default domain name";
      type string {
        tailf:info "WORD;;Default domain name";
      }
    }

    // ip forward-protocol
    container forward-protocol {
      tailf:info "Controls forwarding of physical and directed IP broadcasts";
      leaf nd {
        tailf:info "Sun's Network Disk protocol";
        type empty;
      }
      leaf sdns {
        tailf:info "Network Security Protocol";
        type empty;
      }
      leaf spanning-tree {
        tailf:info "Use transparent bridging to flood UDP broadcasts";
        type empty;
      }
      leaf turbo-flood {
        tailf:info "Fast flooding of UDP broadcasts";
        type empty;
      }
      leaf udp {
        tailf:info "Packets to a specific UDP port";
        type empty;
      }


    }

    // ip http
    container http {
      tailf:info "HTTP server configuration";
      leaf server {
        tailf:info "Enable http server";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      leaf secure-server {
        tailf:info "Enable https server";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // ip pim
    container pim {
      tailf:info "PIM global commands";
      container ssm {
        tailf:info "Configure Source Specific Multicast";
        choice ssm-choice {
          leaf default {
            tailf:info "Use 232/8 group range for SSM";
            type empty;
          }
          leaf range {
            tailf:info "ACL for group range to be used for SSM";
            type union {
              type uint8 {
                tailf:info "<1-99>;;Access list number";
                range "1..99";
              }
              type string {
                tailf:info "WORD;;IP named access list";
              }
            }
          }
        }
      }
    }

    // ip route
    container route {
      tailf:info "Establish static routes";
      container vrf {
        tailf:info "Configure static route for a VPN Routing/Forwarding"
          +" instance";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        leaf dest {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination prefix";
          }
        }
        leaf dest-mask {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination prefix mask";
          }
        }
        choice vrf-choice {
          leaf forwarding-address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Forwarding router's address";
            }
          }
          leaf GigabitEthernet {
            tailf:info "GigabitEthernet IEEE 802.3z";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            type string {
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:interface/GigabitEthernet/id";
            }
          }
        }
      }
    }

    // ip multicast-routing
    container multicast-routing {
      tailf:info "Enable IP multicast forwarding";
      presence true;
      tailf:cli-display-separated;
      leaf-list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }
    }

    // ip multicast
    container multicast {
      tailf:info "Global IP Multicast Commands";
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        container route-limit {
          tailf:info "Maximum number of multicast routes";
          tailf:cli-sequence-commands  {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf nr-routes {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;number of routes";
              range "1..2147483647";
            }
          }
          leaf threshold {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Threshold at which to"
                +" generate warning message";
              range "1..2147483647";
            }
          }
        }
      }
    }

    // ip tftp
    container tftp {
      tailf:info "tftp configuration commands";
      container source-interface {
        tailf:info "Specify interface for source address in TFTP connections";
        uses interface-name-grouping;
      }
    }

    // ip ssh
    container ssh {
      tailf:info "Configure ssh options";
      leaf logging {
        tailf:info "Configure logging for SSH";
        type enumeration {
          enum events {
            tailf:info "Log SSH events";
          }
        }
      }
      leaf version {
        tailf:info "Specify protocol version to be supported";
        type uint8 {
          tailf:info "<1-2>;;Protocol version";
          range "1..2";
        }
      }
    }

  }


  /// ========================================================================
  /// mirror
  /// ========================================================================

  container mirror {
    tailf:info "disk mirror enable command";

    // mirror location *
    list location {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;Fully qualified location specification";
        }
      }
    }
  }


  /// ========================================================================
  /// ipv4
  /// ========================================================================

  container ipv4 {
    tailf:info "Global IPv4 configuration commands";
    tailf:cli-explicit-exit;

    // ipv4 netmask-format bit-count
    container netmask-format {
      tailf:info "Display mode of ipv4 address mask";
      leaf bit-count {
        tailf:info "Display ipaddess mask in prefix length format";
        type empty;
      }
    }

    // ipv4 assembler
    container assembler {
      tailf:info "IPv4 Fragmented Packet Assembler";

      // ipv4 assembler max-packets
      leaf max-packets {
        tailf:info "Maxinum packets allowed in assembly queues";
        type uint8 {
          tailf:info "<1-50>;;Percentage of total packets available in the system (default: 1000 packets)";
          range "1..50";
        }
      }

      // ipv4 assembler timeout
      leaf timeout {
        tailf:info "Number of seconds an assembly queue will hold before timeout";
        type uint8 {
          tailf:info "<1-120>;;Number of seconds an assembly queue will hold before timeout";
          range "1..120";
        }
      }
    }

    // ipv4 access-list
    container access-list {
      tailf:info "Configure access lists";
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;

      // ipv4 access-list *
      list named-acl {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-no-key-completion;
        tailf:cli-mode-name "config-ipv4-acl";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;User selected string identifying this "+
              "access list";
          }
        }
        list rule {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "id";
          leaf id {
            type uint32 {
              tailf:info "<1-2147483644>;;Sequence number for this entry";
            }
          }

          leaf line {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info "deny;;Specify packets to reject\n"+
                "permit;;Specify packets to forward\n"+
                "remark;;Comment for access list";
              pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
            }
          }
        }
      }
    }

    // ipv4 unnumbered
    container unnumbered {
      tailf:info "Enable IPv4 processing without an explicit address";
      container mpls {
        tailf:info "Configure MPLS routing protocol parameters";
        container traffic-eng {
          tailf:info "IPv4 commands for MPLS Traffic Engineering";
          uses interface-name-grouping;
        }
      }
    }

    // ipv4 virtual
    container virtual {
      tailf:info "IPv4 virtual address for management interfaces options";
      container address-src {
        tailf:cli-drop-node-name;
        container address {
          leaf use-as-src-addr {
            tailf:info "Use as default src address on sourced packets?";
            type empty;
          }
        }
      }

      // ipv4 virtual address *
      container address {
        tailf:info "IPv4 virtual address for management interfaces";
        list address-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "address mask";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address";
            }
          }
          leaf mask {
            type inet:ipv4-address {
              tailf:info "IP subnet mask";
            }
          }
        }

        // ipv4 virtual address vrf * *
        list vrf {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "Select VRF for which the virtual ip address is "+
                "configured";
            }
          }
          list address-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "address mask";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address";
              }
            }
            leaf mask {
              type inet:ipv4-address {
                tailf:info "IP subnet mask";
              }
            }
          }
        }
      }
    }

    // ipv4 conflict-policy
    // ipv4 prefix-list *
    uses ipv4-ipv6-common-grouping;

    // ipv4 source-route
    leaf source-route {
      tailf:info "Process packets with source routing header options";
      tailf:cli-full-command;
      type empty;
    }


  }


  /// ========================================================================
  /// ipv6
  /// ========================================================================

  container ipv6 {
    tailf:info "Global IPv6 configuration commands";
    tailf:cli-explicit-exit;

    // ipv6 unicast-routing
    leaf unicast-routing {
      tailf:info "Enable unicast routing";
      type empty;
    }

    // ipv6 access-list
    container access-list {
      tailf:info "Configure access lists";
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      // ipv6 access-list *
      list named-acl {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-no-key-completion;
        tailf:cli-mode-name "config-ipv6-acl";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;User selected string identifying this "+
              "access list";
          }
        }
        list rule {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "id";
          leaf id {
            type uint32 {
              tailf:info "<1-2147483644>;;Sequence number for this entry";
            }
          }

          // FIXME: create better data model for this, probably a choice along
          // the lines of
          // choice rule-choice {
          //   container permit {
          //   }
          //   container deny {
          //   }
          //   container remark {
          //   }
          // }

          leaf line {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info "deny;;Specify packets to reject\n"+
                "permit;;Specify packets to forward\n"+
                "remark;;Comment for access list";
              pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
            }
          }
        }
      }
    }

    // ipv6 multicast
    container multicast {
      tailf:info "Configure multicast related commands";
      container rpf {
        tailf:info "Configure multicast RPF related commands";
        container backoff {
          tailf:info "Backoff delay after unicast routing change";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf initial {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<200-65535>;;Initial RPF backoff"
                +" delay in milliseconds";
              range "200..65535";
            }
          }
          leaf max-backoff-delay {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<200-65535>;;Maximum RPF backoff"
                +" delay in milliseconds";
              range "200..65535";
            }
          }
        }
        leaf use-bgp {
          tailf:info "Use BGP routes for multicast RPF lookup";
          type empty;
        }
      }
    }

    // ipv6 conflict-policy
    // ipv6 prefix-list *
    uses ipv4-ipv6-common-grouping;

    // ipv6 mobile
    container mobile {
      tailf:info "MobileIP configuration";

      // ipv6 mobile pmipv6-domain *
      list pmipv6-domain {
        tailf:info "PMIPv6 domain configuration";
        tailf:cli-mode-name "config-pmipv6-domain";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Domain Name";
          }
        }

        // ipv6 mobile pmipv6-domain * / nai *
        list nai {
          tailf:info "Network access identifier or Realm";
          tailf:cli-mode-name "config-pmipv6-domain-nai";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;MN Identifier";
            }
          }

          // ipv6 mobile pmipv6-domain * / nai * / network
          leaf network {
            tailf:info "Network name (Address pool) for this MN";
            type string {
              tailf:info "WORD;;Network name";
            }
          }

          // ipv6 mobile pmipv6-domain * / nai * / service
          leaf service {
            tailf:info "Service type for this MN";
            type enumeration {
              enum dual {
                tailf:info "dual service type";
              }
              enum ipv4 {
                tailf:info "ipv4 service type";
              }
              enum ipv6 {
                tailf:info "ipv6 service type";
              }
            }
          }

          // ipv6 mobile pmipv6-domain * / nai * / customer
          leaf customer {
            tailf:info "Customer name for this MN";
            type string {
              tailf:info "WORD;;Customer name";
            }
          }
        }
      }

      // ipv6 mobile pmipv6-lma * domain *
      list pmipv6-lma {
        tailf:info "PMIPv6 LMA configuration";
        tailf:cli-mode-name "config-pmipv6-lma";
        key "name domain";
        leaf name {
          type string {
            tailf:info "WORD;;LMA name";
          }
        }
        leaf domain {
          tailf:cli-expose-key-name;
          tailf:info "PMIPv6 domain for this LMA";
          type string {
            tailf:info "WORD;;Domain name";
          }
        }

        // ipv6 mobile pmipv6-lma * domain * / aaa accounting
        container aaa {
          tailf:info "aaa config attributes for this LMA";
          container accounting {
            tailf:info "AAA accounting for this LMA";
            tailf:cli-delete-when-empty;
            presence true;
            // ipv6 mobile pmipv6-lma * domain * / aaa accounting interim
            leaf interim {
              tailf:info "Send interim accounting update messages";
              type uint32 {
                tailf:info "<1-86400>;;Interim acounting interval(in minutes)";
                range "1..86400";
              }
            }
          }
        }

        // ipv6 mobile pmipv6-lma * domain * / dynamic mag learning
        container dynamic {
          tailf:info "enable dynamic mag learning for LMA";
          container mag {
            tailf:info "learn mag dynamically for this LMA";
            leaf learning {
              tailf:info "learn mag dynamically for this LMA";
              type empty;
            }
          }
        }

        // ipv6 mobile pmipv6-lma * domain * / enforce heartbeat-to-mag
        container enforce {
          tailf:info "enforce heartbeat values to MAG";
          leaf heartbeat-to-mag {
            tailf:info "send heartbeat values to MAG";
            type empty;
          }
        }

        // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop
        container mobility-service {
          tailf:info "Service of this LMA";
          container mobile-local-loop {
            tailf:info "Wireless Private Routing service";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ipv6-lma-mll";
            presence true;


            // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf *
            list customer {
              tailf:info "customer configuration on this mobile local loop service";
              tailf:cli-mode-name "config-ipv6-pmipv6-mll-cust";
              key "name vrf";
              leaf name {
                type string {
                  tailf:info "WORD;;Customer name";
                }
              }
              leaf vrf {
                tailf:cli-expose-key-name;
                tailf:info "Vrf for this customer";
                type vrf-type;
              }

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / gre-key symmetric
              container gre-key {
                tailf:info "Customer specific GRE key";
                leaf symmetric {
                  tailf:info "Customer specific symmetric GRE key";
                  type uint32 {
                    tailf:info "<1-4294967295>;;GRE key value";
                  }
                }
              }

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / network
              container network {
                tailf:info "network parameters for the customer";
                choice network-choice {
                  leaf authorized {
                    tailf:info "not authorize the network prefixes";
                    type string {
                      tailf:info "WORD;;ASCII string";
                    }
                  }
                  leaf unauthorized {
                    tailf:info "not authorize the network prefixes";
                    type empty;
                  }
                }
              }

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / auth-option
              container auth-option {
                tailf:info "Authentication option between PMIPV6 entities";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf spi {
                  tailf:info "Security parameter index";
                  tailf:cli-incomplete-command;
                  type string {
                    tailf:info "<0-ffffffff>;;SPI in hex value";
                  }
                }
                container "key" {
                  tailf:info "Security Key";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  leaf ascii {
                    tailf:info "Key in ASCII string";
                    type string {
                      tailf:info "WORD;;ASCII string";
                    }
                  }
                }
              }

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / transport
              container transport {
                tailf:info "Customer transport attributes";

                // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / transport vrf *
                list vrf {
                  tailf:info "vrf for this transport";
                  tailf:cli-mode-name "config-ipv6-pmipv6-mll-cust-tpt";
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Name of VRF";
                    }
                  }

                  // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / transport vrf * / address *
                  container address {
                    tailf:info "Specify LMAs IPv4 and IPv6 address";
                    leaf ipv4 {
                      tailf:info "Configure IPv4 address for this LMA";
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;Transport IPv4 address";
                      }
                    }
                    leaf ipv6 {
                      tailf:info "Configure IPv6 address for this LMA";
                      type inet:ipv6-address {
                        tailf:info "X:X::X;;Transport IPv6 address";
                      }
                    }
                  }
                }
              }

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / heartbeat
              container heartbeat {
                tailf:info "heartbeat config for this Customer";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf interval {
                  tailf:info "interval value";
                  tailf:cli-incomplete-command;
                  type uint16 {
                    tailf:info "<10-3600>;;Specify the interval value in second";
                    range "10..3600";
                  }
                }
                leaf retries {
                  tailf:info "retry value";
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<1-10>;;Specify the retry value";
                    range "1..10";
                  }
                }
                leaf timeout {
                  tailf:info "timeout value";
                  type uint16 {
                    tailf:info "<1-3600>;;Specify the timeout value";
                    range "1..3600";
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// frequency
  /// ========================================================================

  container frequency {
    tailf:info "Frequency Synchronization configuration";
    tailf:cli-explicit-exit;

    container synchronization {
      tailf:info "Frequency Synchronization configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-freqsync";

      // frequency synchronization / quality
      container quality {
        tailf:info "Quality level option selection";
        container itu-t {
          tailf:info "ITU-T QL options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf option {
            tailf:info "ITU-T QL options";
            type enumeration {
              enum "1" {
                tailf:info "ITU-T QL option 1";
              }
              enum "2" {
                tailf:info "ITU-T QL option 2";
              }
            }
          }
          leaf generation {
            tailf:info "ITU-T QL option 2 generation";
            when "../option = '2'";
            type enumeration {
              enum "1" {
                tailf:info "ITU-T QL option 2, generation 1";
              }
              enum "2" {
                tailf:info "ITU-T QL option 2, generation 2";
              }
            }
          }
        }
      }

      // frequency synchronization /  clock-interface
      container clock-interface {
        tailf:info "Clock interface configuration";
        leaf timing-mode {
          tailf:info "Clock interface timing mode";
          type enumeration {
            enum independent {
              tailf:info "Use the line interfaces for clock-interface output,"+
                " which is not looped back to the clock-interface input";
            }
            enum system {
              tailf:info "Use the system's selected timing source for "+
                "clock-interface output";
            }
          }
        }
      }

      // frequency synchronization / system
      container system {
        tailf:info "System timing configuration";
        leaf timing-mode {
          tailf:info "System timing mod";
          type enumeration {
            enum clock-only {
              tailf:info "Use only clock-interfaces for system timing";
            }
            enum line-only {
              tailf:info "Use only line-interfaces for system timing";
            }
          }
        }
      }

      // frequency synchronization / log selection
      container log {
        tailf:info "Logging options";
        leaf selection {
          tailf:info "Selection logging options";
          type enumeration {
            enum changes {
              tailf:info "Log selection changes";
            }
            enum errors {
              tailf:info "Log selection errors";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// cem
  /// ========================================================================

  container cem {
    tailf:info "Configure CEM parameters";

    // cem class *
    list class {
      tailf:info "Configure a CEM class";
      tailf:cli-mode-name "config-cem-class";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;CEM class name";
        }
      }

      // cem class * / payload
      leaf payload {
        tailf:info "Configure payload size of CEM frames";
        type uint16 {
          tailf:info "<32-1312>;;Payload size in bytes";
          range "32..1312";
        }
      }

      // cem class * / dejitter
      leaf dejitter {
        tailf:info "Configure dejitter buffer";
        type uint16 {
          tailf:info "<1-500>;;buffer size in milliseconds";
          range "1..500";
        }
      }
    }
  }


  /// ========================================================================
  /// error-disable
  /// ========================================================================

  container error-disable {
    tailf:info "Configure error-disable";
    container recovery {
      tailf:info "Configure auto-recovery";
      container cause {
        tailf:info "Configure auto-recovery for a specific cause";
        // error-disable recovery cause udld-timeout
        container udld-timeout {
          tailf:info "Used when all UDLD neigbors on the link have timed out";
          tailf:cli-delete-when-empty;
          presence true;
          leaf interval {
            tailf:info "Configure an interval for the auto-recovery period";
            type uint32 {
              tailf:info "<30-1000000>;;Specify an interval for the "+
                "auto-recovery period in seconds";
              range "30..1000000";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vtp
  /// ========================================================================

  container vtp {
    tailf:info "Configure global VTP state";
    tailf:cli-explicit-exit;

    // vtp mode
    leaf mode {
      tailf:info "Configure VTP device mode";
      type enumeration {
        enum client {
          tailf:info "Set the device to client mode.";
        }
        enum off {
          tailf:info "Set the device to off mode.";
        }
        enum server {
          tailf:info "Set the device to server mode.";
        }
        enum transparent {
          tailf:info "Set the device to transparent mode.";
        }
      }
    }
  }


  /// ========================================================================
  /// arp
  /// ========================================================================

  container arp {
    tailf:info "Global ARP configuration for Static and Alias ARP entries";
    tailf:cli-explicit-exit;

    // arp *
    uses arp-grouping;

    // arp vrf *
    list vrf {
      tailf:info "vrf;;Specify a non-default VRF";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-incomplete-command;
      //tailf:cli-diff-dependency "/cisco-ios-xr:vrf";
      key name;
      leaf name {
        tailf:info "VRF name";
        type string {
          tailf:info "WORD;;VRF name";
        }
      }
      uses arp-grouping;
    }
  }


  /// ========================================================================
  /// cinetd
  /// ========================================================================

  container cinetd {
    tailf:info "Global Cisco inetd configuration commands";
    tailf:cli-explicit-exit;

    leaf rate-limit {
      tailf:info "Cisco inetd rate-limit of service requests";
      type uint8 {
        tailf:info "<1-100>;;Number of service requests accepted per "+
          "second (default 1)";
        range "1..100";
      }
    }
  }


  /// ========================================================================
  /// xml
  /// ========================================================================

  container xxml {
    tailf:info "Configuration for XML related services";
    tailf:alt-name xml;
    tailf:cli-explicit-exit;

    // xml agent tty
    container tty-agent {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-no;
      container agent {
        tailf:info "Enable default agent for XML requests";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        container tty {
          tailf:info "Enable tty agent for XML requests";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-xml-tty";
          presence true;

          // xml agent tty / iteration
          container iteration {
            tailf:info "Iterator of the xml response";
            leaf off {
              tailf:info "Turn off the xml response iterator";
              type empty;
            }
          }

          // xml agent tty / ipv4
          leaf ipv4 {
            tailf:info "IPv4 Transport";
            type enumeration {
              enum enable;
              enum disable;
            }
          }

          // xml agent tty / ipv6
          leaf ipv6 {
            tailf:info "IPv6 Transport";
            type enumeration {
              enum enable;
              enum disable;
            }
          }
        }
      }
    }

    // xml agent ssl
    container ssl-agent {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-no;
      container agent {
        tailf:info "Enable default agent for XML requests";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        container ssl {
          tailf:info "Enable ssl agent for XML requests";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-xml-ssl";
          presence true;

          // xml agent ssl / session timeout
          container session {
            tailf:info "session timeout for transport agents";
            leaf timeout {
              tailf:info "session timeout for agents";
              type uint16 {
                tailf:info "<1-1440>;;Timeout in minutes";
                range "1..1440";
              }
            }
          }
        }
      }
    }

    // xml agent
    container other-agent {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-no;
      container agent {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-xml-agent";
        presence true;

        // xml agent / ipv4
        leaf ipv4 {
          tailf:info "IPv4 Transport";
          type enumeration {
            enum enable;
            enum disable {
              tailf:info "Disable IPv4 Transport";
            }
          }
        }

        // xml agent / ipv6
        leaf ipv6 {
          tailf:info "IPv6 Transport";
          type enumeration {
            enum enable;
            enum disable;
          }
        }

        // xml agent / iteration
        container iteration {
          tailf:info "Iterator of the xml response";
          choice iteration-choice {
            container on {
              tailf:info "Turn on the xml response iterator";
              leaf size {
                tailf:info "Iterator size of the xml response";
                type uint32 {
                  tailf:info "<1-100000>;;Size of the Iteration in Kbytes"+
                    " (default 48 Kbytes)";
                  range "1..100000";
                }
              }
            }
            leaf off {
              tailf:info "Turn off the xml response iterator";
              type empty;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// switch
  /// ========================================================================

  container "switch" {
    tailf:info "Configure switch command";
    tailf:cli-explicit-exit;

    container virtual {
      tailf:info "Virtual switch configuration mode";
      list domain {
        tailf:info "Virtual switch domain";
        key id;

        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Virtual switch domain number";
            range "1..255";
          }
        }
        leaf mac-address {
          tailf:info "router mac address scheme";
          type union {
            type string {
              tailf:info "H.H.H;;Manually set router mac address";
            }
            type enumeration {
              enum use-virtual {
                tailf:info "Use mac-address range reserved for"
                  +" Virtual Switch System ";
              }
            }
          }
        }
        container switch {
          tailf:info "Configure switch command";
          leaf mode {
            type enumeration {
              enum virtual;
            }
          }
          list nr {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<1-2>;;Virtual switch number";
                range "1..2";
              }
            }
            leaf location {
              tailf:info "Virtual switch location";
              type string {
                tailf:info "WORD;;Virtual switch location string. If you "
                  +"include spaces, you must enclose your entry in "
                  +"quotes (\"\").";
              }
            }
            leaf priority {
              tailf:info "Virtual switch priority";
              type uint8 {
                tailf:info "<1-255>;;Virtual switch priority value";
                range "1..255";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// key
  /// ========================================================================

  container "key" {
    tailf:info "Key management";
    tailf:cli-explicit-exit;

    // key chain *
    list chain {
      tailf:info "Key-chain management";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Key-chain name";
        }
      }

      // key chain * / key *
      list "key" {
        tailf:info "Configure a key";
        tailf:cli-full-command;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<0-2147483647>;;Key identifier";
            range "0..2147483647";
          }
        }

        // key chain * / key * / accept-lifetime
        container accept-lifetime {
          tailf:info "Set accept lifetime of key";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf local {
            tailf:info "Specify time in local timezone";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf start-time {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "hh:mm:ss;;Time to start";
              pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
            }
          }
          leaf start-month {
            tailf:cli-drop-node-name;
            type month-type;
          }
          leaf start-day {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-31>;;Day of the month to start";
              range "1..31";
            }
          }
          leaf start-year {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1993-2035>;;Year to start";
              range "1993..2035";
            }
          }

          choice stop-choice {
            case duration {
              leaf duration {
                tailf:info "Set key lifetime duration";
                type uint32 {
                  tailf:info "<1-2147483646>;;Seconds";
                  range "1..2147483646";
                }
              }
            }
            case stop-time {
              leaf stop-time {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "hh:mm:ss;;Time to stop";
                  pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
                }
              }
              leaf stop-month {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum Jan;
                  enum Feb;
                  enum Mar;
                  enum Apr;
                  enum May;
                  enum Jun;
                  enum Jul;
                  enum Aug;
                  enum Sep;
                  enum Oct;
                  enum Nov;
                  enum Dec;
                }
              }
              leaf stop-day {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-31>;;Day of the month to stop";
                  range "1..31";
                }
              }
              leaf stop-year {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1993-2035>;;Year to stop";
                  range "1993..2035";
                }
              }
            }
            case infinite {
              leaf infinite {
                tailf:info "Never expires";
                type empty;
              }
            }
          }
        }

        // key chain * / key * / key-string
        container key-string {
          tailf:info "Configure a key value";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf "type" {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum clear {
                tailf:info "Enter key string in cleartext form";
              }
              enum password {
                tailf:info "Encrypted key string ";
              }
            }
          }
          leaf password {
            tailf:info "Encrypted key string ";
            tailf:cli-drop-node-name;
            tailf:cli-reset-container;
            tailf:cli-disallow-value "clear|password";
            tailf:meta-data "secret-password";
            type string {
              tailf:info "LINE;;Cleartext key";
            }
          }
        }

        // key chain * / key * / send-lifetime
        container send-lifetime {
          tailf:info "Set send lifetime of key";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf local {
            tailf:info "Specify time in local timezone";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf start-time {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "hh:mm:ss;;Time to start";
              pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
            }
          }
          leaf start-month {
            tailf:cli-drop-node-name;
            type month-type;
          }
          leaf start-day {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-31>;;Day of the month to start";
              range "1..31";
            }
          }
          leaf start-year {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1993-2035>;;Year to start";
              range "1993..2035";
            }
          }

          choice stop-choice {
            case duration {
              leaf duration {
                tailf:info "Set key lifetime duration";
                type uint32 {
                  tailf:info "<1-2147483646>;;Seconds";
                  range "1..2147483646";
                }
              }
            }
            case stop-time {
              leaf stop-time {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "hh:mm:ss;;Time to stop";
                  pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
                }
              }
              leaf stop-month {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum Jan;
                  enum Feb;
                  enum Mar;
                  enum Apr;
                  enum May;
                  enum Jun;
                  enum Jul;
                  enum Aug;
                  enum Sep;
                  enum Oct;
                  enum Nov;
                  enum Dec;
                }
              }
              leaf stop-day {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-31>;;Day of the month to stop";
                  range "1..31";
                }
              }
              leaf stop-year {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1993-2035>;;Year to stop";
                  range "1993..2035";
                }
              }
            }
            case infinite {
              leaf infinite {
                tailf:info "Never expires";
                type empty;
              }
            }
          }
        }

        // key chain * / key * / cryptographic-algorithm
        leaf cryptographic-algorithm {
          tailf:info "Choose cryptographic algorithm";
          type enumeration {
            enum HMAC-MD5 {
              tailf:info "Configure HMAC-MD5 as cryptographic algorithm";
            }
            enum HMAC-SHA1-12 {
              tailf:info "Configure HMAC-SHA1-12 as cryptographic algorithm";
            }
            enum HMAC-SHA1-20 {
              tailf:info "Configure HMAC-SHA1-20 as cryptographic algorithm";
            }
            enum MD5 {
              tailf:info "Configure MD5 as cryptographic algorithm";
            }
            enum SHA-1 {
              tailf:info "Configure SHA-1-20 as cryptographic algorithm";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dhcp
  /// ========================================================================

  container dhcp {
    tailf:info "Dynamic Host Configuration Protocol";
    tailf:cli-explicit-exit;

    // dhcp ipv4
    container ipv4 {
      tailf:info "Configure IPv4 DHCP";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-dhcpv4";

      // dhcp ipv4 / vrf *
      list vrf {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:info "VRF name";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        // dhcp ipv4 / vrf * relay
        leaf relay {
          tailf:info "Assign a relay profile to VRF";
          type empty;
        }
        // dhcp ipv4 / vrf * profile
        leaf profile {
          tailf:info "Enter profile name";
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
      }

      // dhcp ipv4 / profile *
      list profile {
        tailf:info "Create or enter a profile";
        tailf:cli-mode-name "config-dhcpv4-profile";
        key "name type";
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
        leaf "type" {
          type enumeration {
            enum relay {
              tailf:info "Create or enter relay profile";
            }
            enum proxy {
              tailf:info "Create or enter proxy profile";
            }
            enum server {
              tailf:info "Create or enter server profile";
            }
            enum snoop {
              tailf:info "Create or enter snoop profile";
            }
          }
        }

        // dhcp ipv4 / profile * / pool
        leaf pool {
          tailf:info "Specify the Pool name";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Dap's pool name";
          }
        }

        // dhcp ipv4 / profile * / default-router *
        leaf-list default-router {
          tailf:info "default routers";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Router's IP address";
          }
        }

        // dhcp ipv4 / profile * / giaddr policy
        container giaddr {
          tailf:info "Specify gateway address policy";
          leaf policy {
            tailf:info "Specify gateway address policy";
            type enumeration {
              enum drop {
                tailf:info "Drop client requests with non-zero gateway address";
              }
              enum replace {
                tailf:info "Replace existing gateway address in client request";
              }
            }
          }
        }

        // dhcp ipv4 / profile * / helper-address vrf * *
        list helper-address {
          tailf:info "Specify the server address to relay packets";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "vrf address";
          leaf vrf {
            tailf:cli-expose-key-name;
            tailf:info "Specify server VRF";
            type vrf-type;
          }
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Server address";
            }
          }
          // dhcp ipv4 / profile * / helper-address vrf * * giaddr
          leaf giaddr {
            tailf:info "Specify gateway address to use in packets relayed to server";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Gateway address";
            }
          }
        }

        // dhcp ipv4 / profile * / relay information
        container relay {
          tailf:info "Specify Relay Agent Information Option configuration";
          container information {
            tailf:info "Specify Relay Agent Information Option configuration";

            // dhcp ipv4 / profile * / relay information check
            leaf check {
              tailf:info "Check Relay Agent Information Option in server reply";
              type empty;
            }

            // dhcp ipv4 / profile * / relay information option
            container option {
              tailf:info "Insert Relay Agent Information circuit ID and remote ID suboptions in client request";
              tailf:cli-delete-when-empty;
              presence true;

              // dhcp ipv4 / profile * / relay information option vpn
              leaf vpn {
                tailf:info "Insert Relay Agent Information VPN suboptions in client request";
                type empty;
              }

              // dhcp ipv4 / profile * / relay information option vpn-mode
              leaf vpn-mode {
                tailf:info "Relay Agent Information VPN suboptions mode";
                type enumeration {
                  enum cisco {
                    tailf:info "Relay Agent Information VPN suboptions in CISCO proprietary";
                  }
                  enum rfc {
                    tailf:info "Relay Agent Information VPN suboptions in RFC compliance";
                  }
                }
              }

              // dhcp ipv4 / profile * / relay information option allow-untrusted
              leaf allow-untrusted {
                tailf:info "Forward untrusted packets";
                type empty;
              }
            }

            // dhcp ipv4 / profile * / relay information policy
            leaf policy {
              tailf:info "Specify Relay Agent Information Option policy";
              type enumeration {
                enum drop {
                  tailf:info "Drop client request packets with Relay Agent Information Option";
                }
                enum encapsulate {
                  tailf:info "Encapsulate existing Relay Agent Information Option in client request";
                }
                enum keep {
                  tailf:info "Keep existing Relay Agent Information Option in client request";
                }
              }
            }
          }
        }
      }

      // dhcp ipv4 / interface *
      list interface {
        tailf:info "Assign a profile to interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "name type";
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf "type" {
          type enumeration {
            enum proxy {
              tailf:info "Assign a proxy profile to interface";
            }
            enum relay {
              tailf:info "Assign a relay profile to interface";
            }
            enum server {
              tailf:info "Assign a server profile to interface";
            }
          }
        }
        leaf profile {
          tailf:info "Enter profile name";
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
      }

      // dhcp ipv4 / duplicate-mac-allowed
      container duplicate-mac-allowed {
        tailf:info "Clients with duplicate  mac allowed";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        // dhcp ipv4 / duplicate-mac-allowed exclude-vlan
        leaf exclude-vlan {
          tailf:info "Exclude-vlan";
          type empty;
        }
      }
    }

    // dhcp ipv6
    container ipv6 {
      tailf:info "Configure IPv6 DHCP";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-dhcpv6";

      // dhcp ipv6 / profile *
      list profile {
        tailf:info "Create or enter a profile";
        tailf:cli-mode-name "config-dhcpv6-profile";
        key "name type";
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
        leaf "type" {
          type enumeration {
            enum relay {
              tailf:info "Create or enter relay profile";
            }
            enum proxy {
              tailf:info "Create or enter proxy profile";
            }
            enum server {
              tailf:info "Create or enter server profile";
            }
            enum snoop {
              tailf:info "Create or enter snoop profile";
            }
          }
        }

        // dhcp ipv6 / profile * / interface *
        list interface {
          tailf:info "Specify physical interface for interface-id option";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type ifname;
          }
          leaf interface-id {
            tailf:info "Physical interface ID";
            type string {
              tailf:info "WORD;;Interface ID";
            }
          }
        }

        // dhcp ipv6 / profile * / helper-address vrf *
        list helper-address {
          tailf:info "Configure relay destination";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "vrf address";
          leaf vrf {
            tailf:cli-expose-key-name;
            tailf:info "Specify server VRF";
            type vrf-type;
          }
          leaf address {
            type inet:ipv6-address {
              tailf:info "X:X::X;;Server Global unicast address";
            }
          }
        }

        // dhcp ipv6 / profile * / link-address
        leaf link-address {
          tailf:info "Link Address";
          tailf:cli-full-command;
          type inet:ipv6-address {
            tailf:info "X:X::X;;IPv6 address to be filled in link-address";
          }
        }

        // dhcp ipv6 / profile * / source-interface
        container source-interface {
          tailf:info "Create or enter proxy profile Source Interface Name";
          uses interface-name-grouping;
        }

        // dhcp ipv6 / profile * / lease
        container lease {
          tailf:info "lease";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice lease-choice {
            leaf infinite {
              tailf:info "Infinite lease";
              type empty;
            }
            case duration {
              leaf days {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-365>;;Days";
                  range "0..365";
                }
              }
              leaf hours {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint8 {
                  tailf:info "<0-23>;;Hours";
                  range "0..23";
                }
              }
              leaf minutes {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-59>;;Minutes";
                  range "0..59";
                }
              }
            }
          }
        }

        // dhcp ipv6 / profile * / relay option
        container relay {
          tailf:info "Specify relay configuration";
          container option {
            tailf:info "Specify relay option configuration";

            // dhcp ipv6 / profile * / relay option remote-id
            leaf remote-id {
              tailf:info "Enter remote-id value";
              type string {
                tailf:info "WORD;;Remote ID";
              }
            }

            // relay option interface-id insert local
            container interface-id {
              tailf:info "Interface Id option";
              leaf insert {
                tailf:info "Insert options for Interface Id";
                type enumeration {
                  enum local {
                    tailf:info "Insert locally generated/configured Interface ID value";
                  }
                  enum pppoe {
                    tailf:info "Insert received Interface ID value from SADB";
                  }
                  enum received {
                    tailf:info "Insert received Interface ID value";
                  }
                }
              }
            }

            // relay option link-layer-addr set
            container link-layer-addr {
              tailf:info "Enter link-layer-addr value";
              leaf set {
                tailf:info "Insert Received LinkLayerAddr Value from SADB";
                type empty;
              }
            }
          }
        }

        // dhcp ipv6 / profile * / prefix-pool
        leaf prefix-pool {
          tailf:info "Prefix pool";
          type string {
            tailf:info "WORD;;Prefix pool name";
          }
        }

        // dhcp ipv6 / profile * / rapid-commit
        leaf rapid-commit {
          tailf:info "Allow RAPID Commi";
          type empty;
        }
      }

      // dhcp ipv6 / interface * proxy profile
      // dhcp ipv6 / interface * relay profile
      // dhcp ipv6 / interface * server profile
      list interface {
        tailf:info "Enable IPv6 DHCP on an interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-remove-before-change;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf "type" {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum proxy {
            }
            enum relay {
              tailf:info "Act as an IPv6 DHCP stateless relay agent";
            }
            enum server {
              tailf:info "Act as an IPv6 DHCP server";
            }
          }
        }
        leaf profile {
          tailf:info "Create or enter a profile";
          type string {
            tailf:info "WORD;;Enter profile Name";
          }
        }
      }

      // dhcp ipv6 / interface subscriber-pppoe profile
      container interface-ppoe {
        tailf:cli-drop-node-name;
        container interface {
          tailf:info "Enable IPv6 DHCP on an interface";
          container subscriber-pppoe {
            tailf:info "PPPoE subscriber interface";
            leaf profile {
              tailf:info "Enter profile name";
              type string {
                tailf:info "WORD;;Profile name";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// snmp-server
  /// ========================================================================

  container snmp-server {
    tailf:info "SNMP configuration subcommands";
    tailf:cli-explicit-exit;
    //tailf:cli-diff-dependency "/cisco-ios-xr:ipv4/access-list/named-acl";
    //tailf:cli-diff-dependency "/cisco-ios-xr:ipv6/access-list/named-acl";

    // snmp-server ifmib
    container ifmib {
      tailf:info "IF-MIB configuration commands";

      // snmp-server ifmib ifalias
      container ifalias {
        tailf:info "Modify parameters for ifAlias object";
        leaf long {
          tailf:info "Enable support for ifAlias values longer than "+
            "64 characters";
          type empty;
        }
      }

      // snmp-server ifmib stats
      container stats {
        tailf:info "Modify IF-MIB statistics parameters";
        leaf cache {
          tailf:info "Get cached interface statistics";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // snmp-server packetsize
    leaf packetsize {
      tailf:info "Message packet size";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<484-65500>;;Packet size (default 1500)";
        range "484..65500";
      }
    }

    // snmp-server ifindex
    leaf ifindex {
      tailf:info "Enable ifindex persistence";
      tailf:cli-full-command;
      type enumeration {
        enum persist {
          tailf:info "Persist interface indices";
        }
      }
    }

    // snmp-server engineID
    container engineID {
      tailf:info "Configure a local or remote SNMPv3 engineID";

      // snmp-server engineID local
      leaf local {
        tailf:info "engineID of the local agent";
        type string {
          tailf:info "WORD;;engine ID octet string";
        }
      }

      // snmp-server engineID remote *
      list remote {
        tailf:info "engineID of the remote agent";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key ip-address;
        leaf ip-address {
          type string {
            tailf:info "A.B.C.D or X:X::X;;IP address of remote SNMP notification host";
          }
        }
        leaf engine-id {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;engine ID octet string";
          }
        }
        leaf udp-port {
          tailf:info "The remote notification host's UDP port number";
          type uint16 {
            tailf:info "<1-65535>;;UDP port number";
            range "1..65535";
          }
        }
      }
    }

    // snmp-server host *
    uses snmp-server-host-grouping;

    // snmp-server entityindex
    container entityindex {
      tailf:info "Configuration pertaining to entity indices";
      leaf persist {
        tailf:info "Persist indices";
        type empty;
      }
    }

    // snmp-server vrf *
    list vrf {
      tailf:info "SNMP VRF configuration commands";
      tailf:cli-mode-name "config-snmp-vrf";
      key name;
      leaf name {
        tailf:info "VRF name";
        type string {
          tailf:info "WORD;;VRF name";
        }
      }

      // snmp-server vrf * / host *
      uses snmp-server-host-grouping;

      // snmp-server vrf * / context *
      list context {
        tailf:info "SNMP Context Name";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Context Name";
          }
        }
      }
    }

    // snmp-server ipv4
    container ipv4 {
      tailf:info "Mark the dscp/precedence bit for ipv4 packets";
      choice ipv4-choice {
        leaf dscp {
          tailf:info "Set IP DSCP (DiffServ CodePoint)";
          type dscp-type;
        }
        leaf precedence {
          tailf:info "Set precedence";
          type precedence-type;
        }
      }
    }

    // snmp-server context
    container context {
      tailf:info "Configure SNMP context";

      // snmp-server context *
      list context-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-disallow-value "mapping";
          type string {
            tailf:info "WORD;;Context Name";
          }
        }
      }
    }

    // snmp-server community *
    list community {
      tailf:info "Enable SNMP; set community string and access privs";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;The UNENCRYPTED (cleartext) community string";
        }
      }
      // snmp-server community * / view
      leaf view {
        tailf:info "Restrict this community to a named MIB view";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;MIB view to which this community has access";
        }
      }
      // snmp-server community * / RO
      // snmp-server community * / RW
      choice access-choice {
        leaf RO {
          tailf:info "Read-only access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf RW {
          tailf:info "Read-write access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }
      // snmp-server community * / SDROwner
      // snmp-server community * / SystemOwner
      choice owner-choice {
        leaf SDROwner {
          tailf:info "SDR Owner permissions for MIB Objects";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf SystemOwner {
          tailf:info "System Owner permissions for MIB objects";
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }
      // snmp-server community * / [IPv4|IPv6] <access-list>
      leaf access-list-type {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum IPv4 {
            tailf:info "Type of Access-list";
          }
          enum IPv6 {
            tailf:info "Type of Access-list";
          }
        }
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "IPv4|IPv6|SDROwner|SystemOwner|RO|RW|view";
        type string {
          tailf:info "WORD;;Access-list";
        }
      }
    }

    // snmp-server community-map
    container community-map {
      tailf:info "Community Mapping as per RFC-2576";

      // snmp-server community-map *
      list community-map-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;The UNENCRYPTED (cleartext) community string";
          }
        }
        // snmp-server community-map * context
        leaf context {
          tailf:info "Context Name for the community mapping";
          type string {
            tailf:info "WORD;;SNMP Context Name";
          }
        }
      }
    }

    // snmp-server queue-length
    leaf queue-length {
      tailf:info "Message queue length for each TRAP host";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-5000>;;Queue length (default 100)";
        range "1..5000";
      }
    }

    // snmp-server trap-timeout
    leaf trap-timeout {
      tailf:info "Set timeout for TRAP message retransmissions";
      type uint16 {
        tailf:info "<1-1000>;;Timeout (default 30 seconds)";
        range "1..1000";
      }
      default 30;
    }

    // snmp-server contact
    leaf "contact" {
      tailf:info "Text for mib Object sysContact";
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;identification of the contact person for this managed node";
      }
    }

    // snmp-server location
    leaf location {
      tailf:info "Text for mib Object sysLocation";
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;The physical location of this node";
      }
    }

    // snmp-server trap-source
    container trap-source {
      tailf:info "Assign an interface for the source address of all traps";
      uses interface-name-grouping;

      // snmp-server trap-source port
      leaf port {
        tailf:info "Change the source port of all traps (default 161).";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1024-65535>;;UDP port number";
          range "1024..65535";
        }
      }
    }

    // snmp-server overload-control
    container overload-control {
      tailf:info "Set overload-control params for handling incoming "+
        "messages in critical processing mode";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf drop-time {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-300>;;Overload drop time (in seconds) for incoming "+
            "queue (default 1 sec)";
          range "0..300";
        }
      }
      leaf throttle-rate {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-1000>;;Overload throttle rate for incoming "+
            "queue (default 500 msec)";
          range "0..1000";
        }
      }
    }

    // snmp-server mroutemib send-all-vrf
    container mroutemib {
      tailf:info "Configurations related to IPMROUTE-MIB";
      leaf send-all-vrf {
        tailf:info "enable sending all vrf interface info for cIpMRouteInterfaceTable";
        type empty;
      }
    }

    // snmp-server mibs cbqosmib cache
    container mibs {
      tailf:info "MIB for configurations";
      container cbqosmib {
        tailf:info "Configure CBQoSMIB parameters";

        // snmp-server mibs cbqosmib persist
        leaf persist {
          tailf:info "Persist CBQoSMIB config, service-policy and object indices";
          type empty;
        }

        // snmp-server mibs cbqosmib cache
        container cache {
          tailf:info "Enable CBQoSMIB stats data caching";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-cbqosmibcache";

          // snmp-server mibs cbqosmib cache / refresh
          container refresh {
            tailf:info "Cache refresh interval";
            leaf time {
              tailf:info "Cache refresh time in seconds ";
              type uint16 {
                tailf:info "<5-60>;;Refresh time in secs";
                range "5..60";
              }
            }
          }

          // snmp-server mibs cbqosmib cache / service-policy
          container service-policy {
            tailf:info "Maximum number of service policies to cache the statistics for";
            leaf count {
              tailf:info "Number of service-policy stats";
              type uint16 {
                tailf:info "<1-5000>;;Number of service-policys";
                range "1..5000";
              }
            }
          }
        }
      }
    }

    // snmp-server trap
    container trap {
      tailf:info "MIB trap configurations";
      leaf link {
        tailf:info "Link up/down trap configuration";
        tailf:cli-full-command;
        type enumeration {
          enum ietf {
            tailf:info "Set the varbind of linkupdown trap to the RFC "+
              "specified varbinds (default cisco)";
          }
        }
      }
    }

    // snmp-server user *
    list user {
      tailf:info "Define a user who can access the SNMP engine";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key username;
      leaf username {
        type string {
          tailf:info "WORD;;Name of the user";
        }
      }

      leaf groupname {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Group to which the user belongs";
        }
      }
      leaf version {
        tailf:cli-drop-node-name;
        type enumeration {
          enum v1 {
            tailf:info "user using the v1 security model";
          }
          enum v2c {
            tailf:info "user using the v2c security model";
          }
          enum v3 {
            tailf:info "user using the v3 security model";
          }
        }
      }
      container auth {
        when "../version = 'v3'";
        tailf:info "authentication parameters for the user";
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        // auth { md5 | sha } { clear | encrypted } auth-password
        leaf level {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum md5 {
              tailf:info "Use HMAC MD5 algorithm for authentication";
            }
            enum sha {
              tailf:info "Use HMAC SHA algorithm for authentication";
            }
          }
        }
        choice password-choice {
          leaf auth-password {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) "+
                "authentication password";
            }
          }
          leaf clear {
            tailf:info "Specifies an UNENCRYPTED password will follow";
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) "+
                "authentication password";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an ENCRYPTED password will follow";
            type string {
              tailf:info "LINE;;The ENCRYPTED authentication password";
            }
          }
        }
      }

      // [ priv { 3des | aes aes-bit-encryption | des56 }
      // { clear | encrypted } priv-password ]
      container priv {
        when "../auth";
        tailf:info "encryption parameters for the user";
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice priv-level {
          leaf "threedes" {
            tailf:alt-name "3des";
            tailf:info "Use 168 bit 3DES algorithm for encryption";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf aes {
            tailf:info "AES - Advanced Encryption Standard.";
            tailf:cli-incomplete-command;
            type enumeration {
              enum "128" {
                tailf:info "Use AES 128 bit encryption";
              }
              enum "192" {
                tailf:info "Use AES 192 bit encryption";
              }
              enum "256" {
                tailf:info "Use AES 256 bit encryption";
              }
            }
          }
          leaf des56 {
            tailf:info "Use 56 bit DES algorithm for encryption";
            tailf:cli-incomplete-command;
            type empty;
          }
        }
        choice password-choice {
          leaf priv-password {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) "+
                "privacy password";
            }
          }
          leaf clear {
            tailf:info "Specifies an UNENCRYPTED password will follow";
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) "+
                "privacy password";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an ENCRYPTED password will follow";
            type string {
              tailf:info "LINE;;The ENCRYPTED privacy password";
            }
          }
        }
      }

      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;Access-list name";
        }
      }

      choice owner-choice {
        leaf SDROwner {
          tailf:info "SDR Owner permissions for MIB Objects";
          type empty;
        }
        leaf SystemOwner {
          tailf:info "System Owner permissions for MIB objects";
          type empty;
        }
      }
    }

    // snmp-server view *
    list view {
      tailf:info "Define an SNMPv2 MIB view";
      tailf:cli-suppress-mode;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      key view-name;
      leaf view-name {
        type string {
          tailf:info "WORD;;Name of the view";
        }
      }
      list oid-list {
        tailf:cli-suppress-mode;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        key oid-tree;
        leaf oid-tree {
          type string {
            tailf:info "WORD;;MIB view family name";
          }
        }
        leaf viewmode {
          tailf:cli-drop-node-name;
          type enumeration {
            enum excluded {
              tailf:info "MIB family is excluded from the view";
            }
            enum included {
              tailf:info "MIB family is included in the view";
            }
          }
        }
      }
    }

    // snmp-server group *
    list group {
      tailf:info "Define a User Security Model group";
      tailf:cli-suppress-mode;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the group";
        }
      }
      choice version-choice {
        leaf v1 {
          tailf:info "group using the v1 security model";
          type empty;
        }
        leaf v2c {
          tailf:info "group using the v2c security model";
          type empty;
        }
        leaf v3 {
          tailf:info "group using the User Security Model (SNMPv3)";
          type enumeration {
            enum auth {
              tailf:info "group using the authNoPriv Security Level";
            }
            enum noauth {
              tailf:info "group using the noAuthNoPriv Security Level";
            }
            enum priv {
              tailf:info "group using authPriv Security Level";
            }
          }
        }
      }

      // snmp-server group * read
      leaf read {
        tailf:info "specify a notify view for the group";
        tailf:cli-break-sequence-commands;
        type string {
          tailf:info "WORD;;read view name";
          length "1..64";
        }
      }

      // snmp-server group * write
      leaf write {
        tailf:info "specify a write view for this group";
        type string {
          tailf:info "WORD;;write view name";
          length "1..64";
        }
      }

      // snmp-server group * notify
      leaf notify {
        tailf:info "specify a notify view for the group";
        type string {
          tailf:info "WORD;;notify view name";
          length "1..64";
        }
      }

      // snmp-server group * context
      leaf context {
        tailf:info "Attach a SNMP context";
        type string {
          tailf:info "WORD;;SNMP Context Name";
        }
      }

      // snmp-server group * [IPv4|IPv6] <access-list>
      leaf access-list-type {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum IPv4 {
            tailf:info "Type of Access-list";
          }
          enum IPv6 {
            tailf:info "Type of Access-list";
          }
        }
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "v1|v2c|v3|read|write|notify|context|IPv4|IPv6";
        type string {
          tailf:info "WORD;;Access-list name";
          length "1..64";
        }
      }
    }

    // snmp-server interface
    container interface {
      tailf:info "Enter the SNMP interface configuration commands";

      // snmp-server interface subset *
      list subset {
        tailf:info "Add configuration for an interface subset";
        tailf:cli-mode-name "config-snmp-if-subset";
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;The interface subset number";
            range "1..255";
          }
        }
        leaf regular-expression {
          tailf:info "Interfaces matching regular expression";
          tailf:cli-hide-in-submode;
          type string {
            tailf:info "WORD;;Regular expression to match ifName";
          }
        }

        // snmp-server interface subset */ notification linkupdown
        container "notification" {
          tailf:cli-break-sequence-commands;
          tailf:info "Allow an SNMP notification type";
          container linkupdown {
            tailf:info "SNMP linkUp and linkDown notifications";
            tailf:cli-delete-when-empty;
            presence true;

            // snmp-server interface subset * / notification linkupdown disable
            leaf disable {
              tailf:info "Disable linkUp and linkDown notification";
              type empty;
            }
          }
        }
      }

      // snmp-server interface *
      list interface-name {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-snmp-if";
        key ifname;
        leaf ifname {
          tailf:cli-disallow-value "subset";
          type ifname;
        }

        // snmp-server interface * / index persistence
        container index {
          tailf:info "Configure ifIndex attributes";
          leaf persistence {
            tailf:info "Persistency across system reloads";
            type empty;
          }
        }

        // snmp-server interface */ notification linkupdown
        container "notification" {
          tailf:info "Allow an SNMP notification type";
          container linkupdown {
            tailf:info "SNMP linkUp and linkDown notifications";
            tailf:cli-delete-when-empty;
            presence true;

            // snmp-server interface * / notification linkupdown disable
            leaf disable {
              tailf:info "Disable linkUp and linkDown notification";
              type empty;
            }
          }
        }

      }
    }

    // snmp-server chassis-id
    leaf chassis-id {
      tailf:info "String to uniquely identify this chassis";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Unique ID string";
      }
    }

    // snmp-server traps *
    container traps {
      tailf:info "Enable SNMP traps";
      list traps-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;snmp-server traps <entry>";
          }
        }
      }
    }

    // snmp-server timeouts
    container timeouts {
      tailf:info "SNMP timeouts";

      // snmp-server timeouts subagent
      leaf subagent {
        tailf:info "Sub-Agent Request timeout";
        type uint8 {
          tailf:info "<1-20>;;timeout in secs (default 10)";
          range "1..20";
        }
      }
    }
  }


  /// ========================================================================
  /// srlg
  /// ========================================================================

  container srlg {
    tailf:info "SRLG configuration commands";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;
    presence true;
  }


  /// ========================================================================
  /// monitor-session
  /// ========================================================================

  // monitor-session *
  list monitor-session {
    tailf:info "Monitor-session configuration commands";
    tailf:cli-mode-name "config-mon";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Session Name";
      }
    }
    // monitor-session * ethernet
    choice type-choice {
      leaf ethernet {
        tailf:info "Specify the destination that traffic should be replicated to";
        tailf:cli-hide-in-submode;
        type empty;
      }
      leaf ipv4 {
        tailf:info "Replicate IPv4 traffic";
        tailf:cli-hide-in-submode;
        type empty;
      }
      leaf ipv6 {
        tailf:info "Replicate IPv6 traffic";
        tailf:cli-hide-in-submode;
        type empty;
      }
    }

    // monitor-session * / destination
    container destination {
      tailf:info "Specify the destination that traffic should be replicated to";
      choice destination-choice {

        // monitor-session * / destination pseudowire
        leaf pseudowire {
          tailf:info "Specify a pseudowire";
          type empty;
        }

        // monitor-session * / destination interface
        container interface {
          tailf:info "Specify a destination interface";
          uses interface-name-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// spanning-tree
  /// ========================================================================

  container spanning-tree {
    tailf:info "Spanning Tree Subsystem";
    tailf:cli-explicit-exit;

    // spanning-tree extend
    container extend {
      tailf:info "Spanning Tree 802.1t extensions";
      leaf system-id {
        tailf:info "Extend system-id into priority portion "
          +"of the bridge id (PVST & Rapid PVST only)";
        type empty;
      }
    }

    // spanning-tree mode
    leaf mode {
      tailf:info "Spanning tree operating mode";
      type enumeration {
        enum mst {
          tailf:info "Multiple spanning tree mode";
        }
        enum rapid-pvst {
          tailf:info "Per-Vlan rapid spanning tree mode";
        }
      }
    }

    // spanning-tree mst
    container mst {
      tailf:info "Configure Multiple Spanning Tree Protocol.";

      // spanning-tree mst *
      list "range" {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-range-list-syntax;
        key id;
        leaf id {
          type uint8 {
            tailf:info "WORD;;MST instance range, example: 0-3,5,7-9";
          }
        }
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          type uint16 {
            tailf:info "<0-61440>;;bridge priority in increments of 4096";
            range "0..61440";
          }
        }
      }

      // spanning-tree mst *
      list protocol-instance {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-mstp";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Protocol Instance name.";
          }
        }

        // spanning-tree mst * / name
        leaf name {
          tailf:info "Configuration name";
          type string {
            tailf:info "WORD;;Configuration name";
          }
        }

        // spanning-tree mst * / maximum
        container maximum {
          tailf:info "Bridge maximums, such as max-age";
          // spanning-tree mst * / maximum age
          leaf age {
            tailf:info "Bridge maximum age time.";
            type uint8 {
              tailf:info "<6-40>;;Bridge Maximum Age time in seconds.";
              range "6..40";
            }
          }
          // spanning-tree mst * / maximum hops
          leaf hops {
            tailf:info "Bridge maximum number of hops.";
            type uint8 {
              tailf:info "<6-40>;;Bridge Maximum number of hops.";
            }
          }
        }

        // spanning-tree mst * / revision
        leaf "revision" {
          tailf:info "Bridge revision number.";
          type uint16 {
            tailf:info "<0-65535>;;Revision number.";
          }
        }

        // spanning-tree mst * / bringup delay for
        container bringup {
          tailf:info "Bringup options.";
          container delay {
            tailf:info "Bringup delay for newly created interfaces.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf "for" {
              tailf:info "Specify length of time to delay bringup for";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<0-3600>;;Length of time to delay for "+
                  "(hours, minutes, or seconds)";
              }
            }
            leaf unit {
              tailf:cli-drop-node-name;
              type enumeration {
                enum seconds {
                  tailf:info "Time is in seconds";
                }
                enum minutes {
                  tailf:info "Time is in minutes";
                }
                enum hours {
                  tailf:info "Time is in hours";
                }
              }
            }
          }
        }

        // spanning-tree mst * / forward-delay
        leaf forward-delay {
          tailf:info "Bridge forward delay time.";
          type uint8 {
            tailf:info "<4-30>;;Forward delay time in seconds.";
            range "4..30";
          }
        }

        // spanning-tree mst * / transmit hold-count
        container transmit {
          tailf:info "Bridge transmit options";
          leaf hold-count {
            tailf:info "Bridge Transmit Hold Count.";
            type uint8 {
              tailf:info "<1-10>;;Bridge Transmit Hold Count.";
            }
          }
        }

        // spanning-tree mst * / provider-bridge
        leaf provider-bridge {
          tailf:info "Provider Bridge mode.";
          type empty;
        }

        // spanning-tree mst * / instance *
        list instance {
          tailf:info "Configure an MSTP instance.";
          tailf:cli-mode-name "config-mstp-inst";
          key id;
          leaf id {
            type uint16 {
              tailf:info "<0-4094>;;MSTI ID";
              range "0..4094";
            }
          }

          // spanning-tree mst * / instance * / priority
          leaf priority {
            tailf:info "MSTI Priority.";
            type uint16 {
              tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
              range "0..61440" {
                tailf:step 4096;
              }
            }
          }

          // spanning-tree mst * / instance * / vlan-ids
          leaf-list vlan-ids {
            tailf:info "Assign ranges of VLANs to the specified MSTI.";
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type uint16 {
              tailf:info "WORD;;List of VLAN Ranges in the form a-b,c,d,e-f,g";
            }
          }
        }

        // spanning-tree mst * / interface *
        list interface {
          tailf:info "Enable and Configure MSTP on an interface.";
          tailf:cli-mode-name "config-mstp-if";
          key ifname;
          leaf ifname {
            type ifname;
          }

          // spanning-tree mst * / interface * / portfast
          container portfast {
            tailf:info "Set PortFast on Interface.";
            presence true;
          }

          // spanning-tree mst * / interface * / instance * cost
          list instance {
            tailf:info "MSTI Specific configuration for this interface.";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<0-4094>;;MSTI ID";
                range "0..4094";
              }
            }
            leaf cost {
              tailf:info "Cost of this port on this MSTI.";
              type uint32 {
                tailf:info "<1-200000000>;;Port Cost";
                range "1..200000000";
              }
            }
          }

          // spanning-tree mst * / interface * / link-type
          leaf link-type {
            tailf:info "Configure the Link Type of an Interface.";
            tailf:cli-full-command;
            type enumeration {
              enum multipoint {
                tailf:info "Multipoint link.";
              }
              enum point-to-point {
                tailf:info "Point to Point link.";
              }
            }
          }

          // spanning-tree mst * / interface * / external-cost
          leaf external-cost {
            tailf:info "Interface External Cost.";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<1-200000000>;;Interface External Cost.";
              range "1..200000000";
            }
          }
        }
      }
    }

    // spanning-tree portfast
    leaf portfast {
      tailf:info "Spanning tree portfast options";
      type enumeration {
        enum disable {
          tailf:info "Disable portfast for this interface";
        }
        enum edge {
          tailf:info "Enable portfast edge on the interface";
        }
        enum network {
          tailf:info "Enable portfast network on the interface";
        }
      }
    }

    // spanning-tree mstag *
    list mstag {
      tailf:info "Configure MST Access Gateway";
      tailf:cli-mode-name "config-mstag";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Protocol Instance name.";
        }
      }
      // spanning-tree mstag * / interface *
      list interface {
        tailf:cli-mode-name "config-mstag-if";
        key ifname;
        leaf ifname {
          type ifname;
        }
        leaf name {
          tailf:info "Configuration name";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Configuration name";
          }
        }
        leaf port-id {
          tailf:info "Interface Port ID.";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-4095>;;Interface Port ID.";
            range "1..4095";
          }
        }
        leaf bridge-id {
          tailf:info "Set the Bridge ID this port should use";
          tailf:cli-full-command;
          type string {
            tailf:info "H.H.H;;MAC address";
            pattern '[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+';
          }
        }
        list instance {
          tailf:info "Enable and Configure an instance on this interface.";
          tailf:cli-mode-name "config-mstag-if-inst";
          key id;
          leaf id {
            type uint16 {
              tailf:info "<0-4094>;;MSTI ID";
              range "0..4094";
            }
          }
          container cost {
            tailf:info "Cost of this port on this MSTI.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf cost-value {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-200000000>;;Port Cost";
                range "1..200000000";
              }
            }
            leaf startup-value {
              tailf:info "Set the cost of this port on this MSTI to be used "+
                "during pre-empt delay";
              type uint32 {
                tailf:info "<1-200000000>;;Port Cost";
                range "1..200000000";
              }
            }
          }
          leaf-list vlan-ids {
            tailf:info "Assign ranges of VLANs to the specified MSTI.";
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "WORD;;List of VLAN Ranges in the form a-b,c,d,e-f,g";
            }
          }
          container root-id {
            tailf:info "Set the Bridge ID of the root for this instance";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf root-id-value {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "H.H.H;;MAC address";
                pattern '[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+';
              }
            }
            leaf startup-value {
              tailf:info "Set the Bridge ID to be used during pre-empt delay";
              type string {
                tailf:info "H.H.H;;MAC address";
                pattern '[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+';
              }
            }
          }
          container priority {
            tailf:info "MSTI Priority.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf priority-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of "+
                  "4096.";
                range "0..61440" {
                  tailf:step 4096;
                }
              }
            }
            leaf startup-value {
              tailf:info "Set the MSTI Priority to be used during "+
                "pre-empt delay";
              type uint16 {
                tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of "+
                  "4096.";
                range "0..61440" {
                  tailf:step 4096;
                }
              }
            }
          }
          container root-priority {
            tailf:info "Priority of the root for this instance.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf priority-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of "+
                  "4096.";
                range "0..61440" {
                  tailf:step 4096;
                }
              }
            }
            leaf startup-value {
              tailf:info "Set the priority of the root for this instance "+
                "to be used during pre-empt delay";
              type uint16 {
                tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of "+
                  "4096.";
                range "0..61440" {
                  tailf:step 4096;
                }
              }
            }
          }
        }
      }
    }

    // spanning-tree repag *
    list repag {
      tailf:info "Configure REP Access Gateway";
      tailf:cli-mode-name "config-repag";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Protocol Instance name.";
        }
      }
      // spanning-tree repag * / interface *
      list interface {
        tailf:cli-mode-name "config-repag-if";
        key ifname;
        leaf ifname {
          type ifname;
        }
      }
    }
  }


  /// ========================================================================
  /// redundancy
  /// ========================================================================

  container redundancy {
    tailf:info "Interchassis redundancy configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-redundancy";
    tailf:cli-explicit-exit;

    // redundancy iccp
    container iccp {
      tailf:info "configure iccp parameter";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-redundancy-iccp";

      // redundancy / iccp / group *
      list group {
        tailf:info "group configuration";
        tailf:cli-mode-name "config-redundancy-iccp-group";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-4294967295>;;Enter group number";
            range "1..4294967295";
          }
        }

        // redundancy / iccp / group * / mlacp
        container mlacp {
          tailf:info "Multi-chassis Link Aggregation Control Protocol commands";

          // redundancy / iccp / group * / mlacp node
          leaf node {
            tailf:info "Set mLACP node ID to use in this ICCP Group";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-7>;;Unique node ID in the ICCP Group for this system.";
              range "0..7";
            }
          }

          // redundancy / iccp / group * / mlacp system
          container system {
            tailf:info "Set the default system parameters for LACP bundles";
            leaf mac {
              tailf:info "The LACP System ID to be used in this ICCP Group.";
              tailf:cli-full-command;
              type string {
                tailf:info "H.H.H;;Unique ID for this system. "+
                  "Any non-zero value is permitted.";
              }
            }
            leaf priority {
              tailf:info "Set the LACP system priority to be used in "+
                "this ICCP Group.";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Priority for this system. "+
                  "Lower value is higher priority.";
                range "1..65535";
              }
            }
          }

          // redundancy / iccp / group * / mlacp connect timeout
          container connect {
            tailf:info "Specify configuration options for connecting to mLACP peers.";
            leaf timeout {
              tailf:info "Specify time to wait before assuming mLACP peer is down.";
              type uint16 {
                tailf:info "<0-65534>;;Number of seconds to wait before assuming mLACP peer is down.";
                range "0..65534";
              }
            }
          }
        }

        // redundancy / iccp / group * / member
        container member {
          tailf:info "configure ICCP members";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-redundancy-group-iccp-member";
          // redundancy / iccp / group * / member / neighbor *
          leaf neighbor {
            tailf:info "configure interchassis group ICCP members";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;neighbor ip address";
            }
          }
        }

        // redundancy / iccp / group * / mode singleton
        container mode {
          tailf:info "Set the group mode";
          leaf singleton {
            tailf:info "Run the group in singleton mode";
            type empty;
          }
        }

        // redundancy / iccp / group * / backbone
        container backbone {
          tailf:info "configure ICCP backbone interfaces";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-redundancy-group-iccp-backbone";
          // redundancy / iccp / group * / backbone / interface *
          list interface {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
          }
        }

        // redundancy / iccp / group * / isolation
        container isolation {
          tailf:info "Set the isolation parameters";
          leaf recovery-delay {
            tailf:info "Specify delay before clearing isolation "+
              "condition after recovery from failure";
            type uint16 {
              tailf:info "<30-600>;;Recovery delay in seconds.";
              range "30..600";
            }
          }
        }

        // redundancy / iccp / group * / nv satellite
        container nv {
          tailf:info "Network Virtualization configuration";
          container satellite {
            tailf:info "Satellite configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-nV";
            // redundancy / iccp / group * / nv satellite / system-mac
            leaf system-mac {
              tailf:info "System MAC for this redundancy-group";
              type string {
                tailf:info "H.H.H;;Optional system MAC address.";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ssh
  /// ========================================================================

  container ssh {
    tailf:info "Secure Shell configuration";
    tailf:cli-explicit-exit;

    // ssh client
    container client {
      tailf:info "Provide SSH client service";

      // ssh client vrf
      leaf vrf {
        tailf:info "Source interface VRF for ssh client sessions";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;VRF name (max:32 chars)";
        }
      }

      // ssh client source-interface
      container source-interface {
        tailf:info "Source interface for ssh client sessions";
        uses interface-name-grouping;
      }

      // ssh client dscp
      leaf dscp {
        tailf:info "DSCP value for ssh client sessions";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;DSCP value range";
          range "0..63";
        }
      }
    }

    // ssh server
    container server {
      tailf:info "Provide SSH server service";

      // ssh server dscp
      leaf dscp {
        tailf:info "Cisco ssh server DSCP";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;DSCP value range";
          range "0..63";
        }
      }

      // ssh server logging
      leaf logging {
        tailf:info "Enable ssh server logging";
        tailf:cli-full-command;
        type empty;
      }

      // ssh server netconf
      container netconf {
        tailf:info "start ssh service for netcon";
        tailf:cli-delete-when-empty;
        presence true;
        leaf port {
          tailf:info "start ssh service on port";
          type uint16 {
            tailf:info "<1-65535>;;port number on which ssh service to be "+
              "started for netconf";
          }
        }
      }

      // ssh server rate-limit
      leaf rate-limit {
        tailf:info "Cisco sshd rate-limit of service requests";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-600>;;Limit in term of number of request per minute"+
            "(default 60)";
          range "1..600";
        }
      }

      // ssh server session-limit
      leaf session-limit {
        tailf:info "Cisco sshd session-limit of service requests";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-1024>;;Number of allowable concurrent incoming "+
            "ssh sessions";
          range "1..1024";
        }
      }

      // ssh server v2
      leaf v2 {
        tailf:info "Cisco sshd force protocol version 2 only";
        tailf:cli-full-command;
        type empty;
      }

      // ssh server vrf *
      list vrf {
        tailf:info "Cisco sshd VRF name";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter vrf name";
          }
        }
        container ipv4 {
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          tailf:info "IPv4 access list for ssh server";
          leaf access-list {
            tailf:info "Configure IPv4 access-list";
            type string {
              tailf:info "WORD;;Name of IPv4 access list - Max 32 characters";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
            }
          }
        }
        container ipv6 {
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          tailf:info "IPv6 access list for ssh server";
          leaf access-list {
            tailf:info "Configure IPv6 access-list";
            type string {
              tailf:info "WORD;;Name of IPv6 access list - Max 32 characters";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:ipv6/access-list/named-acl/name";
            }
          }
        }
      }
    }

    // ssh timeout
    leaf timeout {
      tailf:info "Set timeout value for SSH";
      type uint8 {
        tailf:info "<5-120>;;Timeout value between 5-120 seconds";
        range "5..120";
      }
    }
  }


  /// ========================================================================
  /// track
  /// ========================================================================

  // track *
  list track {
    tailf:info "Configure Track";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;track name";
      }
    }

    // track * / type
    container "type" {
      tailf:info "Set track type";

      // track * / type rtr ? reachability
      container rtr {
        tailf:info "track type ipsla";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf ipsla-no {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-2048>;;ipsla operation number";
            range "1..2048";
          }
        }
        leaf reachability {
          tailf:info "Tracks whether the route is reachable";
          type empty;
        }
      }

      // track * / type line-protocol state
      container line-protocol {
        tailf:info "track type line-protocol";
        container state {
          tailf:info "track type line-protocol state";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-track-line-prot";

          // track * / type line-protocol state / interface
          container interface {
            tailf:info "Set track interface";
            uses interface-name-grouping;
          }
        }
      }

      // track * / type route reachability
      container route {
        tailf:info "track type ipv4 route";
        container reachability {
          tailf:info "track type ipv4 route reachability";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-track-route";

          // track * / type route reachability / route ipv4
          container route {
            tailf:info "Set track route";
            leaf ipv4 {
              tailf:info "IP Address ";
              type inet:ipv4-prefix {
                tailf:info "A.B.C.D/prefix;;IP prefix <network/length>,e.g. 10.56.8.10/16";
              }
            }
          }
        }
      }
    }

    // track * / delay
    container delay {
      tailf:info "Set track notification delay";

      // track * / delay up
      leaf up {
        tailf:info "Up time";
        type uint8 {
          tailf:info "<1-180>;;Up time delay";
        }
      }

      // track * / delay down
      leaf down {
        tailf:info "Down time";
        type uint8 {
          tailf:info "<1-180>;;Down time delay";
        }
      }
    }
  }


  /// ========================================================================
  /// ipsla
  /// ========================================================================

  container ipsla {
    tailf:info "IPSLA configuration commands";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;
    //tailf:cli-diff-dependency "/cisco-ios-xr:key/chain";

    // ipsla / operation *
    list operation {
      tailf:info "IPSLA operation configuration";
      tailf:cli-mode-name "config-ipsla-op";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-2048>;;Operation number";
          range "1..2048";
        }
      }

      // ipsla / operation * / type
      container "type" {
        tailf:info "Type of operation";

        // ipsla / operation * / type udp *
        list udp {
          tailf:info "UDP operation types";
          tailf:cli-mode-name "config-ipsla-udp";
          key name;
          leaf name {
            type enumeration {
              enum echo {
                tailf:info "UDP echo operation type";
              }
              enum jitter {
                tailf:info "UDP jitter operation type";
              }
            }
          }
          uses ipsla-operation-type-grouping;
        }

        // ipsla / operation * / type icmp *
        list icmp {
          tailf:info "ICMP operation types";
          tailf:cli-mode-name "config-ipsla-icmp";
          key name;
          leaf name {
            type enumeration {
              enum echo {
                tailf:info "ICMP echo operation type";
              }
              enum path-echo {
                tailf:info "ICMP path-echo operation type";
              }
              enum path-jitter {
                tailf:info "ICMP path-jitter operation type";
              }
            }
          }
          uses ipsla-operation-type-grouping;
        }

        // ipsla / operation * / type mpls lsp *
        container mpls {
          tailf:info "MPLS operation types";
          list lsp  {
            tailf:info "MPLS LSP operation types";
            tailf:cli-mode-name "config-ipsla-mpls-lsp";
            key name;
            leaf name {
              type enumeration {
                enum ping {
                  tailf:info "MPLS Echo operation type";
                }
                enum trace {
                  tailf:info "MPLS Trace operation type";
                }
              }
            }
            uses ipsla-operation-type-grouping;
          }
        }
      }
    }

    // ipsla / reaction
    container reaction {
      tailf:info "IPSLA reaction configuration";

      // ipsla / reaction operation *
      list operation {
        tailf:info "Reaction configuration for operation";
        tailf:cli-mode-name "config-ipsla-react";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-2048>;;Operation number";
            range "1..2048";
          }
        }

        // ipsla / reaction operation * / react
        container react {
          tailf:info "Specify an element to be monitored for reaction";

          // ipsla / reaction operation * / react connection-loss
          container connection-loss {
            tailf:info "Reaction on connection loss of monitored operation";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ipsla-react-cond";
            uses ipsla-reaction-operation-react-grouping;
          }

          // ipsla / reaction operation * / react packet-loss
          container packet-loss {
            tailf:info "Reaction on packet loss value violation";

            // ipsla / reaction operation * / react packet-loss dest-to-source
            container dest-to-source {
              tailf:info "Packet loss  destination to source(DS) violation";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-ipsla-react-cond";
              uses ipsla-reaction-operation-react-grouping;
            }

            // ipsla / reaction operation * / react packet-loss source-to-dest
            container source-to-dest {
              tailf:info "Packet loss source to destination (SD) violation";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-ipsla-react-cond";
              uses ipsla-reaction-operation-react-grouping;
            }
          }

          // ipsla / reaction operation * / react timeout
          container timeout {
            tailf:info "Reaction on timeout of monitored operation";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ipsla-react-cond";

            // ipsla / reaction operation * / react timeout / action
            container action {
              tailf:info "Type of action to be taken on threshold violation(s)";
              // ipsla / reaction operation * / react timeout / action logging
              leaf logging {
                tailf:info "Generate a syslog alarm on threshold violation";
                type empty;
              }
              // ipsla / reaction operation * / react timeout / action trigger
              leaf trigger {
                tailf:info "Generate trigger to active reaction triggered operation(s)";
                type empty;
              }
            }

            // ipsla / reaction operation * / react timeout / threshold type
            container threshold {
              tailf:info "Configure threshold parameters on monitored element";
              container "type" {
                tailf:info "Threshold type";

                // ipsla / reaction operation * / react timeout / threshold type
                choice type-choice {
                  leaf consecutive {
                    tailf:info "Take action after a number of consecutive violations";
                    type uint8 {
                      tailf:info "<1-16>;;Number of consecutive violations";
                      range "1..16";
                    }
                  }
                  leaf immediate {
                    tailf:info "Take action immediately upon threshold violation";
                    type empty;
                  }
                  container xofy {
                    tailf:info "Take action upon X violations in Y probe operations";
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf x-value {
                      tailf:cli-drop-node-name;
                      type uint8 {
                        tailf:info "<1-16>;;Number of threshold violations (X value)";
                        range "1..16";
                      }
                    }
                    leaf y-value {
                      tailf:cli-drop-node-name;
                      type uint8 {
                        tailf:info "<1-16>;;Number of probes observing the violations (Y value)";
                        range "1..16";
                      }
                    }
                  }
                }
              }
            }
          }

          // ipsla / reaction operation * / react rtt
          container rtt {
            tailf:info "Reaction on round trip time violation";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ipsla-react-cond";
            uses ipsla-reaction-operation-react-grouping;
          }
        }
      }
    }

    // ipsla / schedule operation *
    container schedule {
      tailf:info "Schedule an operation";
      list operation {
        tailf:info " Specify an operation";
        tailf:cli-mode-name "config-ipsla-sched";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-2048>;;Operation number";
            range "1..2048";
          }
        }

        // ipsla / schedule operation * / start-time
        container start-time {
          tailf:info "Start time of the operation";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice start-time-choice {
            leaf after {
              tailf:info "Schedule operation after specified time";
              type string {
                tailf:info "hh:mm:ss;;Start after (hh:mm:ss) has elapsed";
              }
            }
            leaf now {
              tailf:info "Schedule operation now";
              type empty;
            }
            leaf pending {
              tailf:info "Keep operation in the pending state";
              type empty;
            }
            leaf time {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "hh:mm[:ss];;Start time (hh:mm:[ss])";
              }
            }
          }
        }

        // ipsla / schedule operation * / life
        leaf life {
          tailf:info "Length of the time to execute (default 3600 seconds)";
          type union {
            type enumeration {
              enum forever {
                tailf:info "Schedule operation to run indefinitely";
              }
            }
            type uint32 {
              tailf:info "<1-2147483647>;;Life in seconds. (default 3600 seconds)";
              range "1..2147483647";
            }
          }
        }

        // ipsla / schedule operation * / ageout
        leaf ageout {
          tailf:info "How long to keep this entry after it becomes inactive";
          type uint32 {
            tailf:info "<0-2073600>;;Ageout interval in seconds (default 0, never ageout)";
            range "0..2073600";
          }
        }
      }
    }

    // ipsla / key-chain
    leaf key-chain {
      tailf:info "Use MD5 authentication for IPSLA control message";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of key-chain";
      }
    }

    // ipsla / responder
    container responder {
      tailf:info "IPSLA responder configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ipsla-resp";
      presence true;

      // ipsla / responder / type udp ipv4 address * port *
      container "type" {
        tailf:info "Operation type";
        container udp {
          tailf:info "Udp operation";
          list ipv4 {
            tailf:info "IPv4 address configuration";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "address port";
            leaf address {
              tailf:cli-expose-key-name;
              tailf:info "Permanent address on responder";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Enter IPv4 address";
              }
            }
            leaf port {
              tailf:cli-expose-key-name;
              tailf:info "Permanent port on responder";
              type uint16 {
                tailf:info "<1-65535>;;Enter port number";
              }
            }
          }
        }
      }

      // ipsla / responder / twamp
      container twamp {
        tailf:info "Setup TWAMP responder";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-twamp-ref";
        presence true;
      }
    }
  }


  /// ========================================================================
  /// performance-mgmt
  /// ========================================================================

  container performance-mgmt {
    tailf:info "Performance Management configuration & operation subcommands";
    tailf:cli-explicit-exit;

    // performance-mgmt statistics interface basic-counter
    container statistics {
      tailf:info "Configure statistics for data collection";
      container interface {
        tailf:info "Configure statistics collection for interfaces";

        // performance-mgmt statistics interface basic-counter
        container basic-counters {
          tailf:info "Configure data collection for basic counters";

          // performance-mgmt statistics interface basic-counter template *
          list template {
            tailf:info "Specify template";
            tailf:cli-mode-name "config-stats-cntr";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Template name";
              }
            }
            uses performance-mgmt-grouping;
          }
        }

        // performance-mgmt statistics interface data-rates
        container data-rates {
          tailf:info "Configure data collection for data rates";

          // performance-mgmt statistics interface data-rates template *
          list template {
            tailf:info "Specify template";
            tailf:cli-mode-name "config-stats-cntr";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Template name";
              }
            }
            uses performance-mgmt-grouping;
          }
        }
      }
    }

    // performance-mgmt thresholds
    container thresholds {
      tailf:info "Configure thresholds for collected data";
      container node {
        tailf:info "Configure thresholds for node";
        container cpu {
          tailf:info "Configure thresholds for cpu";
          list template {
            tailf:info "Specify template";
            tailf:cli-mode-name "config-threshold-cpu";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Template name";
              }
            }
            uses performance-mgmt-grouping;
          }
        }
        container process {
          tailf:info "Configure thresholds for process";
          list template {
            tailf:info "Specify template";
            tailf:cli-mode-name "config-threshold-proc";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Template name";
              }
            }
            uses performance-mgmt-grouping;
          }
        }
      }
    }

    // performance-mgmt apply *
    list apply {
      tailf:info "Start data collection and/or threshold monitoring";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;performance-mgmt object";
        }
      }
    }
  }


  /// ========================================================================
  /// vlan
  /// ========================================================================

  container vlan {
    tailf:info "Vlan commands";
    tailf:cli-explicit-exit;

    // vlan internal
    container internal {
      tailf:info "internal VLAN";
      container allocation {
        tailf:info "internal VLAN allocation";
        leaf policy {
          tailf:info "internal VLAN allocation policy";
          type enumeration {
            enum ascending {
              tailf:info "Allocate internal VLAN in ascending order";
            }
            enum descending {
              tailf:info "Allocate internal VLAN in descending order";
            }
          }
        }
      }
    }

    // vlan access-log
    container access-log {
      tailf:info "Configure VACL logging";
      leaf maxflow {
        tailf:info "Set vacl logging maximum flow number";
        type uint16 {
          tailf:info "<0-2048>;;Maximum flow number";
          range "0..2048";
        }
      }
      leaf ratelimit {
        tailf:info "Set vacl logging rate limiter ";
        type uint16 {
          tailf:info "<0-5000>;;Maximum number of packets logged per second";
          range "0..5000";
        }
      }
      leaf threshold {
        tailf:info "Set vacl log-update threshold";
        type uint32 {
          tailf:info "<0-2147483647>;;log-update threshold (number of hits)";
          range "0..2147483647";
        }
      }
    }

    // vlan *
    list vlan-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-vlan";
      tailf:cli-range-list-syntax;
      key id;
      leaf id {
        type uint16 {
          tailf:info "WORD;;ISL VLAN IDs 1-4094";
          range "1..4094";
        }
      }
      leaf name {
        tailf:info "Ascii name of the VLAN";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "WORD;;The ascii name for the VLAN";
        }
      }
      leaf uni-vlan {
        tailf:info "Configure a UNI VLAN";
        tailf:cli-full-command;
        type enumeration {
          enum community {
            tailf:info "UNI/ENI community VLAN";
          }
          enum isolated {
            tailf:info "UNI/ENI isolated VLAN";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// lldp
  /// ========================================================================

  container lldp {
    tailf:info "Global LLDP configuration subcommands";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;
    presence true;

    // lldp / holdtime
    leaf holdtime {
      tailf:info "Specify the holdtime (in sec) to be sent in packets";
      type uint16 {
        tailf:info "<0-65535>;;Length  of time  (in sec) that receiver"
          +" must keep this packet ";
      }
    }

    // lldp / reinit
    leaf reinit {
      tailf:info "Delay (in sec) for LLDP initialization on any interface";
      type uint8 {
        tailf:info "<2-5>;;Specify the delay (in secs) for LLDP to initialize";
        range "2..5";
      }
    }

    // lldp / run
    leaf run {
      tailf:info "Enable LLDP";
      type empty;
    }

    // lldp / timer
    leaf timer {
      tailf:info "Specify the rate at which LLDP packets are sent (in sec)";
      type uint16 {
        tailf:info "<5-65534>;;Rate at which LLDP packets are sent (in sec)";
        range "5..65534";
      }
    }
  }


  /// ========================================================================
  /// igmp
  /// ========================================================================

  container igmp {
    tailf:info "IPv4 Address Family";
    container snooping {
      tailf:info "Enter IGMP snooping subcommands";

      // igmp snooping profile *
      list profile {
        tailf:info "Enter IGMP snooping profile name";
        tailf:cli-mode-name "config-igmp-snooping-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Profile name - maximum 32 characters";
          }
        }

        // igmp snooping profile * / system-ip-address
        leaf system-ip-address {
          tailf:info "Source address for generated IGMP messages";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Enter a valid ip address";
          }
        }

        // igmp snooping profile * / internal-querier
        container internal-querier {
          tailf:info "Configure the IGMP internal-querier";
          presence true;
        }
      }
    }
  }


  /// ========================================================================
  /// switch-fabric
  /// ========================================================================

  container switch-fabric {
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;

    list service-policy {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the service policy";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:policy-map/name";
        }
      }
    }
  }


  /// ========================================================================
  /// lpts
  /// ========================================================================

  container lpts {
    tailf:info "lpts configuration commands";
    tailf:cli-explicit-exit;

    // lpts pifib hardware police
    container pifib {
      tailf:info "pre-ifib configuration commands";
      container hardware {
        tailf:info "hardware configuration commands";
        container police {
          tailf:info "ingress policers configuration command";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-pifib-policer-global";
          uses lpts-grouping;
          list location {
            tailf:info "Location Specification";
            tailf:cli-mode-name "config-pifib-policer-per-node";
            key node-id;
            leaf node-id {
              type string {
                tailf:info "WORD;;Enter Location";
              }
            }
            uses lpts-grouping;
          }
        }
      }
    }

    // lpts punt police location *
    container punt {
      tailf:info "punt configuration commands";
      container police {
        tailf:info "ingress policers configuration command";
        list location {
          tailf:info "Configure line card location";
          tailf:cli-mode-name "config-punt-policer-per-node";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Fully qualified line card specification";
            }
          }

          // lpts punt police location * / protocol
          container protocol {
            tailf:info "Protocol packets";

            // lpts punt police location * / protocol arp rate
            container arp {
              tailf:info "ARP packets";
              leaf rate {
                tailf:info "Rate in PPS";
                type uint32 {
                  tailf:info "<0-4294967295>;;Packets Per Second";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// hw-module
  /// ========================================================================

  container hw-module {
    tailf:info "Configure h/w module";
    tailf:cli-explicit-exit;

    // hw-module qos
    container qos {
      tailf:info "Quality of Service";

      // hw-module qos pol-gran
      container pol-gran {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf granularity {
          tailf:cli-drop-node-name;
          type uint8 {
            range "8..64";
          }
        }
        leaf location {
          type string;
        }
      }

      // hw-module qos queue-auto-defrag
      container queue-auto-defrag {
        container disable {
          list location {
            key id;
            leaf id {
              type string {
                // node-id
              }
            }
          }
        }
      }

      // hw-module qos account
      container account {
        container layer2 {
          container encapsulation {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice encapsulation-choice {
              leaf arpa {
                type empty;
              }
              leaf dot1q {
                type empty;
              }
              leaf "length" {
                type uint8 {
                  range "1..50";
                }
              }
            }
            leaf location {
              type string {
                // node-idx
              }
            }
          }
        }
      }

      // hw-module qos multicast
      container multicast {
        tailf:cli-compact-syntax;

        // hw-module qos multicast location
        leaf location {
          type string {
          }
        }

        // hw-module qos multicast priorityq disable location
        container priorityq {
          container disable {
            leaf location {
              type string;
            }
          }
        }
      }
    }

    // hw-module pse
    container pse {
      container allocate {
        container tcam {
          list location {
            key id;
            leaf id {
              type string {
                // node-id
              }
            }
            list region {
              key "name num";
              leaf name {
                type string;
              }
              leaf num {
                type uint32;
              }
            }
          }
        }
      }
    }

    // hw-module mac-move police-mode
    container mac-move {
      tailf:info "Configure mac-move behavior.";
      leaf "police-mode" {
        tailf:info "Control the mode for mac-move.";
        type enumeration {
          enum on {
            tailf:info "Switch on mac-move policing.";
          }
          enum off {
            tailf:info "Switch off mac-move policing.";
          }
        }
      }
    }

    // hw-module linecard throughput *
    container linecard {
      tailf:info "Configure linecard";
      list throughput {
        tailf:info "Configure linecard throughput";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Fully qualified location specification";
          }
        }
        leaf throughput {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum 20G {
              tailf:info "20Gps throughput";
            }
            enum 40G {
              tailf:info "40Gps throughput";
            }
          }
        }
      }
    }

    // hw-module location
    container location  {
      tailf:info "Fully qualified location specification";

      // hw-module location * port * breakout
      list location-breakout-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key "id port";
        leaf id {
          type string {
            tailf:info "WORD;;Fully qualified line card specification";
          }
        }
        leaf port {
          tailf:info "CPAK port configuration";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<0-7>;;CPAK port number";
            range "0..7";
          }
        }
        leaf breakout {
          tailf:info "breakout interface types";
          type string {
            tailf:info "WORD;;Interface mode";
          }
        }
      }

      // hw-module location * slice *
      list location-slice-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key "name slice";
        leaf name {
          type string {
            tailf:info "WORD;;Fully qualified location specification";
          }
        }
        leaf slice {
          tailf:cli-expose-key-name;
          tailf:info "Target slice";
          type uint8 {
            tailf:info "WORD;;Slice number 0 to 3";
            range "0..3";
          }
        }
        // hw-module location * slice * client bitrate
        container client {
          tailf:info "client side parameters";
          tailf:cli-flatten-container;
          leaf bitrate {
            tailf:info "bit rate ";
            tailf:cli-incomplete-command;
            type enumeration {
              enum 100G {
                tailf:info "client bitrate 100G";
              }
              enum 10G {
                tailf:info "client bitrate 10G";
              }
              enum 40G {
                tailf:info "client bitrate 40G";
              }
            }
          }
        }
        // hw-module location * slice * trunk bitrate
        container trunk {
          tailf:info "trunk side parameters";
          tailf:cli-flatten-container;
          leaf bitrate {
            tailf:info "bit rate ";
            type enumeration {
              enum 100G {
                tailf:info "trunk bitrate 100G";
              }
              enum 200G {
                tailf:info "trunk bitrate 200G";
              }
              enum 250G {
                tailf:info "trunk bitrate 250G";
              }
            }
          }
        }
        leaf fec {
          tailf:info "Forward Error Correction mode";
          type enumeration {
            enum SoftDecision7 {
              tailf:info "Forward Error Correction SoftDecision7";
            }
            enum SoftDecision20 {
              tailf:info "Forward Error Correction SoftDecision20";
            }
          }
        }
        leaf encrypted {
          tailf:info "Enable MACSec mode of operation";
          type empty;
        }
      }
    }

    // hw-module subslot *
    list subslot {
      tailf:info "Configure subslot h/w module";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Fully qualified location specification";
        }
      }
      leaf cardtype {
        tailf:info "Configure the SPA physical interface type";
        tailf:cli-full-command;
        type enumeration {
          enum e1 {
            tailf:info "E1 interface type";
          }
          enum e3 {
            tailf:info "E3 interface type";
          }
          enum sdh {
            tailf:info "SDH interface type";
          }
          enum sonet {
            tailf:info "Sonet interface type";
          }
          enum t1 {
            tailf:info "T1 interface type";
          }
          enum t3 {
            tailf:info "T3 interface type(default)";
          }
        }
      }
      // hw-module subslot * shutdown
      container shutdown {
        tailf:info "Shutdown a subslot h/w module";
        tailf:cli-delete-when-empty;
        presence true;
        leaf option {
          tailf:cli-drop-node-name;
          type enumeration {
            // hw-module subslot * shutdown powered
            enum powered {
              tailf:info "Keep the shutdown module powered (default)";
            }
            // hw-module subslot * shutdown unpowered
            enum unpowered {
              tailf:info "Keep the shutdown module unpowered";
            }
          }
        }
      }
    }

    // hw-module port * srp location *
    list port {
      tailf:info "The port";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<0-15>;;Port number on the specified Linecard";
          range "0..15";
        }
      }
      list srp {
        tailf:info "set port in SRP mode";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key location;
        leaf location {
          tailf:info "Fully qualified location";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;fully qualified port location";
          }
        }
        leaf spa-bay {
          tailf:info "Execute subslot h/w module operations";
          type uint8 {
            tailf:info "<0-5>;;spa_to_configure";
            range "0..5";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// class-map
  /// ========================================================================

  list class-map {
    tailf:info "Configure QoS Class Map";
    tailf:cli-mode-name "config-cmap";
    tailf:cli-exit-command "end-class-map";
    key name;
    leaf name {
      tailf:cli-disallow-value "end-class-map";
      type string {
        tailf:info "WORD;;class-map name";
      }
    }

    // class-map type traffic *
    leaf "type" {
      tailf:info "The type of class-map";
      tailf:cli-prefix-key;
      type enumeration {
        enum traffic {
          tailf:info "Traffic class-map";
        }
      }
    }

    // class-map * / prematch
    leaf prematch {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      type enumeration {
        enum match-all {
          tailf:info "Logical-AND all matching statements under "+
            "this classmap";
        }
        enum match-any {
          tailf:info "Logical-OR all matching statements under this "+
            "classmap";
        }
      }
      default match-all;
    }

    // class-map * / description
    leaf "description" {
      tailf:info "Class-Map description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description of this class-map (up to 200 "+
          "characters)";
      }
    }

    // class-map * / match
    container match {
      tailf:info "classification criteria";
      uses class-map-match-grouping;
      container not {
        tailf:info "Negate match criteria";
        uses class-map-match-grouping;
      }
    }

    // Note: rename is action and not needed
  }


  /// ========================================================================
  /// class-map type control subscriber
  /// ========================================================================

  // class-map type control subscriber *
  container class-map-filter-control {
    tailf:cli-drop-node-name;
    list class-map {
      tailf:info "Configure QoS Class Map";
      tailf:cli-mode-name "config-cmap";
      tailf:cli-suppress-list-no;
      tailf:cli-no-key-completion;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-full-command;
      tailf:cli-exit-command "end-class-map" {
        tailf:info "End class map configuration";
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;class-map name";
        }
      }
      leaf "type" {
        tailf:info "The type of class-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum control {
            tailf:info "Control class-map";
          }
        }
      }
      leaf domain {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum subscriber {
            tailf:info "Subscriber control class-map";
          }
        }
      }
      leaf prematch {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum match-all {
            tailf:info "Match all match criteria";
          }
          enum match-any {
            tailf:info "Match any match criteria (default)";
          }
        }
      }

      // class-map type control subscriber * / match
      container match {
        tailf:info "Configure match criteria for this class.";

        // class-map type control subscriber * / match protocol *
        leaf-list protocol {
          tailf:info "protocol";
          tailf:cli-flat-list-syntax;
          type enumeration {
            enum ppp {
              tailf:info "ppp";
            }
            enum dhcpv4 {
              tailf:info "dhcpv4";
            }
            enum dhcpv6 {
              tailf:info "dhcpv6";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// policy-map
  /// ========================================================================

  list policy-map {
    tailf:info "Configure a policymap";
    tailf:cli-mode-name "config-pmap";
    tailf:cli-exit-command "end-policy-map" {
      tailf:info "End policy map configuration";
    }
    //tailf:cli-diff-dependency "/cisco-ios-xr:class-map";
    key name;
    leaf name {
      tailf:cli-disallow-value "end-policy-map";
      type string {
        tailf:info "WORD;;Name of the policymap";
      }
    }

    // policy-map type *
    leaf "type" {
      tailf:info "The type of policymap";
      tailf:cli-prefix-key;
      type enumeration {
        enum pbr {
          tailf:info "PBR policy-map";
        }
        enum performance-traffic {
          tailf:info "Performance traffic policy-map";
        }
        enum redirect {
          tailf:info "Redirect policy-map";
        }
        enum traffic {
          tailf:info "Traffic policy-map";
        }
      }
    }

    // policy-map * / description
    leaf "description" {
      tailf:info "Set description for this policy-map";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description for this policy-map";
      }
    }

    // policy-map * / class
    container class {
      tailf:info "Class map";

      // policy-map * / class *
      list class-ref {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-pmap-c";
        tailf:cli-full-command;
        ordered-by user;
        key map;
        leaf map {
          tailf:cli-disallow-value "class-default";
          type string {
            tailf:info "WORD;;Name of class";
          }
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:class-map/name";
          }
        }
        uses policy-map-class-grouping;
      }

      // policy-map * / class class-default
      list class-default {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-pmap-c";
        tailf:cli-full-command;
        key map;
        leaf map {
          type enumeration {
            enum class-default {
              tailf:info "The default class";
            }
          }
        }
        uses policy-map-class-grouping;
      }
    }
  }


  /// ========================================================================
  /// policy-map type control subscriber
  /// ========================================================================

  container policy-map-event-control {
    tailf:cli-drop-node-name;
    list policy-map {
      tailf:info "Configure a policymap";
      tailf:cli-mode-name "config-pmap";
      tailf:cli-sequence-commands;
      tailf:cli-exit-command "end-policy-map" {
        tailf:info "End policy map configuration";
      }
      key name;
      leaf name {
        tailf:cli-disallow-value "type";
        type string {
          tailf:info "WORD;;policy-map name";
        }
      }
      /// policy-map type control subscriber *
      leaf "type" {
        tailf:info "The type of policymap";
        tailf:cli-prefix-key;
        type enumeration {
          enum control {
            tailf:info "Control policy-map";
          }
        }
      }
      leaf domain {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum subscriber {
            tailf:info "Subscriber control policy-map";
          }
        }
      }

      // policy-map * / event *
      list event {
        tailf:info "Policy event";
        tailf:cli-mode-name "config-pmap-e";
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key "name match";
        leaf name {
          tailf:cli-suppress-range;
          type enumeration {
            enum account-logoff {
              tailf:info "Account logoff event";
            }
            enum account-logon {
              tailf:info "Account logon event";
            }
            enum authentication-failure {
              tailf:info "Authentication failure event";
            }
            enum authentication-no-response {
              tailf:info "Authentication no response event";
            }
            enum authorization-failure {
              tailf:info "Authorization failure event";
            }
            enum authorization-no-response {
              tailf:info "Authorization no response event";
            }
            enum credit-exhausted {
              tailf:info "Credit exhaustion event";
            }
            enum exception {
              tailf:info "Exception event";
            }
            enum idle-timeout {
              tailf:info "Idle timeout event";
            }
            enum quota-depleted {
              tailf:info "Quota depletion event";
            }
            enum service-start {
              tailf:info "Service start event";
            }
            enum service-stop {
              tailf:info "Service stop event";
            }
            enum session-activate {
              tailf:info "Session activate event";
            }
            enum session-identity-change {
              tailf:info "session identity change event";
            }
            enum session-start {
              tailf:info "Session start event";
            }
            enum session-stop {
              tailf:info "Session stop event";
            }
            enum timer-expiry {
              tailf:info "Timer expiry event";
            }
          }
        }
        leaf match {
          tailf:key-default "match-all";
          type enumeration {
            enum match-all {
              tailf:info "Execute all the matched classes";
            }
            enum match-first {
              tailf:info "Execute only the first matched class";
            }
          }
        }

        // policy-map * / event * / class *
        list class {
          tailf:info "Class map";
          tailf:cli-mode-name "config-pmap-c";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of class";
            }
          }
          leaf "type" {
            tailf:info "The type of policymap";
            tailf:cli-prefix-key;
            type enumeration {
              enum control {
                tailf:info "Class of type control";
              }
            }
          }
          leaf domain {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type enumeration {
              enum subscriber {
                tailf:info "Class of sub-type subscriber";
              }
            }
          }
          leaf execute {
            tailf:cli-drop-node-name;
            tailf:cli-hide-in-submode;
            type enumeration {
              enum do-all {
                tailf:info "Do all actions";
              }
              enum do-until-failure {
                tailf:info "Do all actions until failure";
              }
              enum do-until-success {
                tailf:info "Do all actions until success";
              }
            }
          }

          // policy-map * / event * / class * / *
          list action-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65535>;;Sequence number for this action";
                range "1..65535";
              }
            }
            leaf action {
              tailf:cli-drop-node-name;
              type enumeration {
                enum activate {
                  tailf:info "Activate";
                }
                enum authenticate {
                  tailf:info "Authentication related configuration";
                }
                enum authorize {
                  tailf:info "Authorize";
                }
                enum deactivate {
                  tailf:info "Deactivate";
                }
                enum disconnect {
                  tailf:info "Disconnect session";
                }
                enum monitor {
                  tailf:info "Monitor session";
                }
                enum set-timer {
                  tailf:info "Set a timer to execute a rule on its expiry";
                }
                enum stop-timer {
                  tailf:info "Disable timer before it expires";
                }
              }
            }
            leaf action-string {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info "WORD;;action string";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// crypto
  /// ========================================================================

  container crypto {
    tailf:info "Global Crypto configuration command";
  }


  /// ========================================================================
  /// flow
  /// ========================================================================

  container flow {
    tailf:info "Configure a flexible flow object";
    tailf:cli-explicit-exit;

    // flow exporter-map *
    list exporter-map {
      tailf:info "Configure a flow exporter map";
      tailf:cli-mode-name "config-fem";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Exporter map name - maximum 32 characters";
        }
      }

      // flow exporter-map * / version v9
      container version {
        tailf:info "Specify export version parameters";
        container v9 {
          tailf:info "Use version 9 export format";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-fem-ver";

          // flow exporter-map * / version v9 / options
          container options {
            tailf:info "Specify export of options template";

            // flow exporter-map * / version v9 / options interface-table
            container interface-table {
              tailf:info "Export interface table";
              tailf:cli-delete-when-empty;
              presence true;
              // flow exporter-map * / version v9 / options interface-table timeout
              leaf timeout {
                tailf:info "Specify export timeout";
                type uint32 {
                  tailf:info "<1-604800>;;1Timeout value in seconds";
                  range "1..604800";
                }
              }
            }

            // flow exporter-map * / version v9 / options sampler-table
            container sampler-table {
              tailf:info "Export sampler table";
              tailf:cli-delete-when-empty;
              presence true;
              // flow exporter-map * / version v9 / options sampler-table timeout
              leaf timeout {
                tailf:info "Specify export timeout";
                type uint32 {
                  tailf:info "<1-604800>;Timeout value in seconds";
                  range "1..604800";
                }
              }
            }
          }

          // flow exporter-map * / version v9 / template
          container template {
            tailf:info "Specify template export parameters";

            // flow exporter-map * / version v9 / template timeout
            leaf timeout {
              tailf:info "Specify custom timeout for the template";
              type uint32 {
                tailf:info "<1-604800>;Timeout value in seconds";
                range "1..604800";
              }
            }

            // flow exporter-map * / version v9 / template data timeout
            container data {
              tailf:info "Data template configuration options";
              leaf timeout {
                tailf:info "Specify custom timeout for the template";
                type uint32 {
                  tailf:info "<1-604800>;;Timeout value in seconds";
                  range "1..604800";
                }
              }
            }

            // flow exporter-map * / version v9 / template options timeout
            container options {
              tailf:info "Options template configuration options";
              leaf timeout {
                tailf:info "Specify custom timeout for the template";
                type uint32 {
                  tailf:info "<1-604800>;;Timeout value in seconds";
                  range "1..604800";
                }
              }
            }
          }
        }
      }

      // flow exporter-map * / dscp
      leaf dscp {
        tailf:info "Specify DSCP value for export packets";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;Differentiated services codepoint value";
          range "0..63";
        }
      }

      // flow exporter-map * / transport udp
      container transport {
        tailf:info "Specify the transport protocol for export packets";
        leaf udp {
          tailf:info "Use UDP as transport protocol";
          type uint16 {
            tailf:info "<1024-65535>;;Destination UDP port value";
            range "1024..65535";
          }
        }
      }

      // flow exporter-map * / source
      container source {
        tailf:info "Source interface";
        uses interface-name-grouping;
      }

      // flow exporter-map * / destination
      container destination {
        tailf:info "Export destination configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf address {
          tailf:cli-drop-node-name;
          type inet:host {
            tailf:info "Hostname or A.B.C.D  Destination IP address";
          }
        }
        leaf vrf {
          tailf:info "Configure VRF to be used for reaching export "+
            "destination";
          type vrf-type;
        }
      }
    }

    // flow monitor-map *
    list monitor-map {
      tailf:info "Configure a flow monitor map";
      tailf:cli-mode-name "config-fmm";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Monitor map name - maximum 32 characters";
        }
      }

      // flow monitor-map * / record
      container record {
        tailf:info "Specify a flow record map name";
        choice record-choice {
          // flow monitor-map * / record ipv4
          container ipv4 {
            tailf:info "IPv4 raw record format";
            presence true;
            choice record-ipv4-choice {
              leaf peer-as {
                tailf:info "Record peer AS";
                type empty;
              }
              leaf destination-tos {
                tailf:info "IPv4 Destination Based NetFlow Accounting TOS";
                type empty;
              }
            }
          }

          // flow monitor-map * / record ipv6
          container ipv6 {
            tailf:info "IPv6 raw record format";
            presence true;
            leaf peer-as {
              tailf:info "Record peer AS";
              type empty;
            }
          }

          // flow monitor-map * / record mpls
          container mpls {
            tailf:info "MPLS record format";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            presence true;
            leaf fields-fmt {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type enumeration {
                enum ipv4-fields {
                  tailf:info "MPLS with IPv4 fields format";
                }
                enum ipv4-ipv6-fields {
                  tailf:info "MPLS with IPv4 and IPv6 fields format";
                }
                enum ipv6-fields {
                  tailf:info "MPLS with IPv6 fields format";
                }
              }
            }
            leaf labels {
              tailf:info "Labels to be used for Hashing";
              type uint8 {
                tailf:info "<1-6>;;Number of Labels to be used for Hashing";
                range "1..6";
              }
            }
          }
        }
      }

      // flow monitor-map * / exporter
      leaf exporter {
        tailf:info "Specify flow exporter map name";
        type string {
          tailf:info "WORD;;Exporter map name - maximum 32 characters";
        }
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:flow/exporter-map/name";
        }
      }

      // flow monitor-map * / cache
      container cache {
        tailf:info "Specify flow cache attributes";

        // flow monitor-map * / cache entries
        leaf entries {
          tailf:info "Specify the number of entries in the flow cache";
          type uint32 {
            tailf:info "<4096-1000000>;;Number of flow cache entries";
            range "4096..1000000";
          }
        }

        // flow monitor-map * / cache timeout
        container timeout {
          tailf:info "Specify the flow cache timeouts";

          // flow monitor-map * / cache timeout active
          leaf active {
            tailf:info "Specify the active flow timeout";
            type uint32 {
              tailf:info "<1-604800>;;Timeout value in seconds";
              range "1..604800";
            }
          }

          // flow monitor-map * / cache timeout inactive
          leaf inactive {
            tailf:info "Specify the inactive flow timeout";
            type uint32 {
              tailf:info "<1-604800>;;Timeout value in seconds";
              range "1..604800";
            }
          }

          // flow monitor-map * / cache timeout rate-limit
          leaf rate-limit {
            tailf:info "Maximum number of entries to age each second";
            type uint32 {
              tailf:info "<1-1000000>;;Entries per second";
              range "1..1000000";
            }
          }

          // flow monitor-map * / cache timeout update
          leaf update {
            tailf:info "Specify the update timeout";
            type uint32 {
              tailf:info "<1-604800>;;Timeout value in seconds";
              range "1..604800";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// sampler-map
  /// ========================================================================

  list sampler-map {
    tailf:info "Configure a sampler map";
    tailf:cli-mode-name "config-sm";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Sampler map name - maximum 32 characters";
      }
    }

    // sampler-map * / random
    container random {
      tailf:info "Use random mode for sampling packets";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number-of-packets {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "1" {
            tailf:info "<1-1>;;Number of packets to be sampled "+
              "in the sampling interval";
          }
        }
      }
      leaf out-of {
        tailf:info "Sample one packet out of";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf sampling-interval {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-65535>;;Sampling interval in units of packets";
          range "1..65535";
        }
      }
    }
  }


  /// ========================================================================
  /// clock-interface
  /// ========================================================================

  container clock-interface {
    tailf:info "Clock interface configuration commands";
    tailf:cli-explicit-exit;

    // clock-interface sync *
    list sync {
      tailf:info "Synchronization clock interface";
      tailf:cli-mode-name "config-clock-if";
      key "id location";
      leaf id {
        type uint32 {
          tailf:info "<0-4294967295>;;Clock interface port number";
        }
      }

      // clock-interface sync * / shutdown
      leaf shutdown {
        tailf:info "Disable the SyncE Port";
        type empty;
      }

      // clock-interface sync * / location
      leaf location {
        tailf:info "Specify the clock interface location";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Fully qualified location specification";
        }
      }

      // clock-interface sync * / port-parameters
      container port-parameters {
        tailf:info "clock port parameter setting";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-clk-parms";

        // clock-interface sync * / port-parameters / bits-input
        container bits-input {
          tailf:info "BITS RX interface";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "2m" {
                tailf:info "2m mode";
              }
              enum "64k-input-only" {
                tailf:info "64k-input-only mode";
              }
              enum "e1" {
                tailf:info "e1 mode";
              }
              enum "t1" {
                tailf:info "t1 mode";
              }
            }
          }
          leaf mode1 {
            tailf:cli-drop-node-name;
            type enumeration {
              enum d4 {
                tailf:info "d4 mode";
              }
              enum esf {
                tailf:info "esf mode";
              }
              enum crc-4 {
                tailf:info "crc4 mode";
              }
              enum non-crc-4 {
                tailf:info "non-crc-4 mode";
              }
            }
          }
          leaf sa {
            when "../mode1 = 'crc-4'";
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum sa4 {
                tailf:info "SSM on Sa4 bit channel";
              }
              enum sa5 {
                tailf:info "SSM on Sa5 bit channel";
              }
              enum sa6 {
                tailf:info "SSM on Sa6 bit channel";
              }
              enum sa7 {
                tailf:info "SSM on Sa7 bit channel";
              }
              enum sa8 {
                tailf:info "SSM on Sa8 bit channel";
              }
            }
          }
          leaf mode2 {
            tailf:cli-drop-node-name;
            type union {
              type enumeration {
                enum ami {
                  tailf:info "ami mode";
                }
                enum b8zs {
                  tailf:info "b8zs mode";
                }
                enum hdb3 {
                  tailf:info "hdb3 mode";
                }
              }
              type string {
              }
            }
          }
        }
      }

      // clock-interface sync * / frequency
      container frequency {
        tailf:info "Frequency Synchronization configuration";

        // clock-interface / frequency synchronization
        container synchronization {
          tailf:info "Frequency Synchronization configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-clk-freqsync";

          // clock-interface / frequency synchronization / selection
          container selection {
            tailf:info "Selection configuration commands";
            leaf "input" {
              tailf:info "Enable this source for selection";
              type empty;
            }
          }

          // clock-interface / frequency synchronization / priority
          leaf priority {
            tailf:info "Source priority";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1-254>;;Source priority";
              range "1..254";
            }
          }

          // clock-interface / frequency synchronization / wait-to-restore
          leaf wait-to-restore {
            tailf:info "Set the wait-to-restore time";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-12>;;Wait-to-restore time, in minutes";
              range "0..12";
            }
          }

          // clock-interface / frequency synchronization / ssm
          container ssm {
            tailf:info "SSM configuration commands";
            leaf disable {
              tailf:info "Disable sending of SSMs";
              type empty;
            }
          }

          // clock-interface / frequency synchronization / quality
          container quality {
            tailf:info "Quality level configuration";
            container receive {
              tailf:info "Adjust the received quality level";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              uses freqsync-quality-grouping;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// l2
  /// ========================================================================

  container l2 {
    tailf:info "Layer 2 configuration";
    tailf:cli-explicit-exit;

    // l2 vfi *
    list vfi {
      tailf:info "Configure a virtual forwarding instance";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VFI name";
        }
      }

      leaf mode {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum manual {
          }
          enum autodiscovery {
            tailf:info "Multipoint autodiscovery configuration mode";
          }
        }
      }

      // l2 vfi * / vpn
      container vpn {
        tailf:info "VPN configuration";
        leaf id {
          tailf:info "VPN id";
          type uint32 {
            tailf:info "<1-4294967295>;;VPN id value";
            range "1..4294967295";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// auto
  /// ========================================================================

  container auto {
    tailf:info "Configure Automation";
    tailf:cli-explicit-exit;

    // auto qos
    leaf qos {
      tailf:info "Configure AutoQoS";
      type enumeration {
        enum default {
          tailf:info "Configure AutoQoS Default";
        }
      }
    }
  }


  /// =================================1======================================
  /// ethernet-services
  /// ========================================================================

  container ethernet-services {
    tailf:info "Ethernet related services";
    tailf:cli-explicit-exit;

    // ethernet-services access-list *
    list access-list {
      tailf:cli-mode-name "config-es-acl";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
          length "1..32";
        }
      }
      list rule {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-2147483646>;;Sequence number for this entry";
            range "1..2147483646";
          }
        }
        leaf line {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "deny;;Specify packets to reject\n"+
              "permit;;Specify packets to forward\n"+
              "remark;;Comment for access list";
            pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// interface
  /// ========================================================================

  container interface {
    tailf:info "Select an interface to configure";
    tailf:cli-explicit-exit;

    uses interface-grouping;

    container preconfigure {
      tailf:info "Specify a preconfig";
      uses interface-grouping;
    }
  }


  /// ========================================================================
  /// controller
  /// ========================================================================

  container controller {
    tailf:info "Controller configuration subcommands";
    tailf:cli-explicit-exit;

    // controller *
    uses controller-grouping;

    // controller preconfigure *
    container preconfigure {
      tailf:info "Specify a preconfig";
      uses controller-grouping;
    }
  }


  /// ========================================================================
  /// dynamic-template
  /// ========================================================================

  container dynamic-template {
    tailf:info "Dynamically Applied Configuration Template Definition";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;

    // dynamic-template / type
    container "type" {
      tailf:info "'type' keyword";

      // dynamic-template / type ppp *
      list ppp {
        tailf:info "PPP dynamic template type";
        tailf:cli-mode-name "config-dynamic-template-type";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Dynamic Template Name";
          }
        }

        // dynamic-template / type ppp * / ppp
        container ppp {
          tailf:info "Point-to-Point Protocol";

          // dynamic-template / type ppp * / ppp authentication *
          leaf-list authentication {
            tailf:info "Set PPP link authentication method";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            ordered-by user;
            type enumeration {
              enum chap {
                tailf:info "Authenticate using CHAP";
              }
              enum ms-chap {
                tailf:info "Authenticate using Microsoft-CHAP";
              }
              enum pap {
                tailf:info "Authenticate using PAP";
              }
            }
          }
        }

        // dynamic-template / type ppp * / keepalive
        container keepalive {
          tailf:info "Set the keepalive interval, or disable keepalives";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice keepalive-choice {
            case values-case {
              leaf interval {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<10-180>;;Enable keepalives with this interval"
                    +" (default is 60 seconds for RP Subscriber, 120 seconds for LC Subscriber)";
                  range "10..180";
                }
              }
              leaf retry {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-255>;;Set the keepalive retry count (default is 5)";
                  range "1..255";
                }
              }
            }
            leaf disable {
              tailf:info "Disable keepalives";
              type empty;
            }
          }
        }

        // dynamic-template / type ppp * / accounting aaa list *
        container accounting {
          tailf:info "Accounting Feature Config";
          container aaa {
            tailf:info "Accounting Feature AAA Config";
            list "list" {
              tailf:info "Accounting Method-list";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Preconfigured method-list name";
                }
              }
              leaf "type" {
                tailf:info "Type of accounting performed";
                type enumeration {
                  enum session {
                    tailf:info "Apply accounting to a session";
                  }
                }
              }
              leaf periodic-interval {
                tailf:info "Periodic accounting interval in minutes";
                tailf:cli-optional-in-sequence;
                type uint16 {
                  tailf:info "<1-65535>;;Enter value in minutes";
                  range "1..65535";
                }
              }
              leaf dual-stack-delay {
                tailf:info "Dual stack set delay wait";
                type uint8 {
                  tailf:info "<1-30>;;Enter value in seconds";
                  range "1..30";
                }
              }
            }
          }
        }

        // dynamic-template / type ppp * / ipv4
        container ipv4 {
          tailf:info "ipv4 subcommands";

          // dynamic-template / type ppp * / ipv4 mtu
          leaf mtu {
            tailf:info "Set IPv4 Maximum Transmission Unit";
            type uint16 {
              tailf:info "<68-65535>;;MTU (bytes)";
              range "68..65535";
            }
          }

          // dynamic-template / type ppp * / ipv4 verify unicast source reachable-via rx
          container verify {
            tailf:info "Enable per packet validation";
            container unicast {
              tailf:info "Enable per packet validation for unicast";
              container source {
                tailf:info "Validation of source address";
                leaf reachable-via {
                  tailf:info "Specify reachability check to apply to the source address";
                  type enumeration {
                    enum rx {
                      tailf:info "Source is reachable via interface on which packet was received";
                    }
                  }
                }
              }
            }
          }

          // dynamic-template / type ppp * / ipv4 unreachables disable
          container unreachables {
            tailf:info "Enable sending ICMP Unreachable messages";
            leaf disable {
              tailf:info "Suppress ICMPv4 Unreachable messages on subscriber interfaces";
              type empty;
            }
          }
        }

        // dynamic-template / type ppp * / ipv6
        container ipv6 {
          tailf:info "ipv6 subcommands";

          // dynamic-template / type ppp * / ipv6 nd
          container nd {
            tailf:info "ipv6 Neighbor Discovery subcommands";

            // dynamic-template / type ppp * / ipv6 nd ra-interval
            container ra-interval {
              tailf:info "Set IPv6 Router Advertisement(RA) Interval";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf maximum {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<4-1800>;;Maximum RA Interval (sec)";
                  range "4..1800";
                }
              }
              leaf minimum {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<3-1800>;;Minimum RA Interval (sec)";
                  range "3..1800";
                }
              }
            }

            // dynamic-template / type ppp * / ipv6 nd ra-lifetime
            leaf ra-lifetime {
              tailf:info "Set IPv6 Router Advertisement(RA) Lifetime";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<0-9000>;;RA Lifetime (seconds)";
                range "0..9000";
              }
            }

            // dynamic-template / type ppp * / ipv6 nd reachable-time
            leaf reachable-time {
              tailf:info "Set advertised reachability time";
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<0-3600000>;;Reachability time in milliseconds";
                range "0..3600000";
              }
            }

            // dynamic-template / type ppp * / ipv6 nd other-config-flag
            leaf other-config-flag {
              tailf:info "Hosts should use stateful protocol for non-address config";
              tailf:cli-full-command;
              type empty;
            }

            // dynamic-template / type ppp * / ipv6 nd managed-config-flag
            leaf managed-config-flag {
              tailf:info "Hosts should use stateful protocol for address config";
              tailf:cli-full-command;
              type empty;
            }
          }
        }

      }

      // dynamic-template / type service *
      list service {
        tailf:info "Service dynamic template type";
        tailf:cli-mode-name "config-dynamic-template-type";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Dynamic Template Name";
          }
        }

        // dynamic-template / type service * / service-policy
        container service-policy {
          tailf:info "Configure QoS Service Policy";

          // interface * / service-policy input
          container "input" {
            tailf:info "Configure a policy in the input direction";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf name {
              tailf:info "Name of the service policy";
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              type string {
                tailf:info "WORD;;Name of the service policy";
              }
            }
            uses interface-service-policy-content-grouping;
          }

          // interface * / service-policy output
          container "output" {
            tailf:info "direction of service policy application";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf name {
              tailf:info "Name of the service policy";
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              type string {
                tailf:info "WORD;;Name of the service policy";
              }
            }
            uses interface-service-policy-content-grouping;
          }

          // interface * / service-policy type pbr
          container "type" {
            tailf:info "Configure PBR Service policy";
            container pbr {
              tailf:info "PBR Service policy";
              leaf "input" {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;Name of the service policy";
                }
              }
            }
          }
        }

        // dynamic-template / type service * / ipv4
        container ipv4 {
          tailf:info "ipv4 subcommands";

          // dynamic-template / type service * / ipv4 access-group * ingress
          // dynamic-template / type service * / ipv4 access-group * egress
          list access-group {
            tailf:info "Specify access control for packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key direction;
            leaf direction {
              type enumeration {
                enum egress {
                  tailf:info "Filter outgoing packets";
                }
                enum ingress {
                  tailf:info "Filter incoming packets";
                }
              }
            }
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type string {
                tailf:info "WORD;;access-list name";
              }
            }
          }
        }

        // dynamic-template / type service * / ipv6
        container ipv6 {
          tailf:info "ipv6 subcommands";

          // dynamic-template / type service * / ipv6 access-group * ingress
          // dynamic-template / type service * / ipv6 access-group * egress
          list access-group {
            tailf:info "Specify access control for packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key direction;
            leaf direction {
              type enumeration {
                enum egress {
                  tailf:info "Filter outgoing packets";
                }
                enum ingress {
                  tailf:info "Filter incoming packets";
                }
              }
            }
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type string {
                tailf:info "WORD;;access-list name";
              }
            }
          }
        }
      }

      // dynamic-template / type ipsubscriber *
      list ipsubscriber {
        tailf:info "IP Subscriber dynamic template type";
        tailf:cli-mode-name "config-dynamic-template-type";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Dynamic Template Name";
          }
        }

        // dynamic-template / type ipsubscriber * / vrf
        leaf vrf {
          tailf:info "Set VRF in which the interface operate";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }

        // dynamic-template / type ipsubscriber * / ipv4
        container ipv4 {
          tailf:info "ipv4 subcommands";

          // dynamic-template / type ipsubscriber * / ipv4 unnumbered
          container unnumbered {
            tailf:info "Enable IPv4 processing without an explicit address";
            uses interface-name-grouping;
          }
        }

        // dynamic-template / type ipsubscriber * / ipv6
        container ipv6 {
          tailf:info "ipv6 subcommands";

          // dynamic-template / type ipsubscriber * / ipv6 enable
          leaf enable {
            tailf:info "Enable IPv6 on interface";
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// evpn
  /// ========================================================================

  container evpn {
    tailf:info "Configure E-VPN commands";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-evpn";
    tailf:cli-explicit-exit;

    // evpn / evi *
    list evi {
      tailf:info "Configure Ethernet VPN ID(EVI)";
      tailf:cli-mode-name "config-evpn-evi";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-65534>;;Ethernet VPN ID to set";
          range "1..65534";
        }
      }

      // evpn / evi * / bgp
      container bgp {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-evpn-evi-bgp";
        presence true;

        // evpn / evi * / bgp / rd
        leaf rd {
          tailf:info "Set the Route Distinguisher";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;AS-number or IPv4 address:index";
          }
        }

        // evpn / evi * / bgp / route-target
        container route-target {
          tailf:info "Set the Route Target";

          // evpn / evi * / bgp / route-target import *
          list "import" {
            tailf:info "Import Route Target";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;AS-number or IPv4 address:index";
              }
            }
            leaf stitching {
              tailf:info " Route Target for Fabric side";
              type empty;
            }
          }

          // evpn / evi * / bgp / route-target export *
          list "export" {
            tailf:info "Export Route Target";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;AS-number or IPv4 address:index";
              }
            }
            leaf stitching {
              tailf:info " Route Target for Fabric side";
              type empty;
            }
          }
        }
      }

      // evpn / evi * / advertise-mac
      leaf advertise-mac {
        tailf:info "Advertise locally-learned MACs";
        type empty;
      }

      // evpn / evi * / network-controller
      container network-controller {
        tailf:info "Configure EVPN Network Controller Settings";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-evpn-evi-nc";

        // evpn / evi * / network-controller / vni
        leaf vni {
          tailf:info "Layer 3 VXLAN VNI";
          type uint16 {
            tailf:info "<0-65535>;;Layer 3 VXLAN VNI";
            range "0..65535";
          }
        }

        // evpn / evi * / network-controller / host *
        list host {
          tailf:info "Host Configuration";
          tailf:cli-mode-name "config-evpn-evi-nc-host";
          key mac;
          leaf mac {
            tailf:info "Host MAC address";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "H.H.H;;Host MAC address";
            }
          }
          leaf ip-address {
            tailf:info "Host IP Address";
            tailf:cli-hide-in-submode;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Host IP Address";
            }
          }

          // evpn / evi * / network-controller / host * / ipv4 address
          container ipv4 {
            tailf:info "IPv4 Address Family";
            leaf address {
              tailf:info "IPv4 Address of a host";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP Address for the host";
              }
            }
          }

          // evpn / evi * / network-controller / host * / switch
          leaf "switch" {
            tailf:info "Switch the host is connected to";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP Address of the Switch the host "+
                "is connected to";
            }
          }

          // evpn / evi * / network-controller / host * / gateway
          container gateway {
            tailf:info "Gateway for the host";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ip-address {
              tailf:cli-drop-node-name;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Gateway IP Address for the host";
                }
                type inet:ipv4-prefix {
                  tailf:info "A.B.C.D/prefix;;Gateway IPv4 Address/prefix";
                }
              }
            }
            leaf netmask {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP subnet mask";
              }
            }
          }

          // evpn / evi * / network-controller / host * / vlan
          leaf vlan {
            tailf:info "VLAN the host is on";
            type uint16 {
              tailf:info "<1-4094>;;VLAN the host is on";
              range "1..4094";
            }
          }
        }
      }
    }

    // evpn / timers
    uses evpn-timers-grouping;

    // evpn / interface *
    list interface {
      tailf:info "Assign interface to EVPN";
      tailf:cli-mode-name "config-evpn-ac";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // evpn / interface * / ethernet-segment
      container ethernet-segment {
        tailf:info "Ethernet Segment configuration commands";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-evpn-ac-es";

        // evpn / interface * / ethernet-segment / identifier type 0
        container identifier {
          tailf:info "Ethernet Segment identifier (ESI)";
          list "type" {
            tailf:info "ESI Type";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key esi-type;
            leaf esi-type {
              type enumeration {
                enum "0" {
                  tailf:info "Type 0 (arbitrary 9-octet ESI value)";
                }
              }
            }
            leaf esi-identifier  {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<0-ff>.;;9-octet ESI value";
              }
            }
          }
        }

        // evpn / interface * / ethernet-segment / bgp route-target
        container bgp {
          tailf:info "Configure BGP";
          leaf route-target {
            tailf:info "Set ES-Import Route Target";
            type string {
              tailf:info "H.H.H;;Route Target value (6-octet)";
            }
          }
        }
      }
    }

    // evpn / virtual neighbor * pw-id *
    container virtual {
      tailf:info "Virtual Access Segment to EVPN";

      // evpn / virtual neighbor * pw-id *
      list neighbor {
        tailf:info "Specify the peer to cross connect";
        tailf:cli-mode-name "config-evpn-ac-pw";
        key "address pw-id";
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address of the peer";
          }
        }
        leaf pw-id {
          tailf:info "Specify the pseudowire id";
          tailf:cli-expose-key-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Pseudowire ID";
            range "1..4294967295";
          }
        }
        uses evpn-virtual-grouping;
      }

      // evpn / virtual vfi *
      list vfi {
        tailf:info "Specify the virtual forwarding interface name";
        tailf:cli-mode-name "config-evpn-ac-vfi";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the Virtual Forwarding Interface";
          }
        }
        uses evpn-virtual-grouping;
      }
    }
  }


  /// ========================================================================
  /// l2vpn
  /// ========================================================================

  container l2vpn {
    tailf:info "Configure l2vpn commands";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-l2vpn";
    tailf:cli-explicit-exit;
    presence true;

    // l2vpn / router-id
    leaf router-id {
      tailf:info "Global L2VPN Router ID";
      tailf:cli-full-command;
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IP Address";
      }
    }

    // l2vpn / nsr
    leaf nsr {
      tailf:info "Configure Non-Stop Routing";
      tailf:cli-full-command;
      type empty;
    }

    // l2vpn / pw-grouping
    leaf pw-grouping {
      tailf:info "Enable PW-Grouping";
      tailf:cli-full-command;
      type empty;
    }

    // l2vpn / pw-status
    container pw-status {
      tailf:info "Configure PW status";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Disable PW status";
        type empty;
      }
    }

    // l2vpn / autodiscovery bgp
    container autodiscovery {
      tailf:info "Configure global auto-discovery attributes";
      container bgp {
        tailf:info "auto discovery type bgp";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-l2vpn-ad";

        // l2vpn / autodiscovery bgp / signaling-protocol bgp
        container signaling-protocol {
          tailf:info "Configure global signaling protocol attributes";
          container bgp {
            tailf:info "signaling protocol type bgp";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-l2vpn-ad-sig";

            // l2vpn / autodiscovery bgp /signaling-protocol bgp / mtu mismatch ignore
            container mtu {
              tailf:info "mtu";
              container mismatch {
                tailf:info "mtu mismatch";
                leaf ignore {
                  tailf:info "Ignore MTU mismatch for auto-discovered PWs";
                  type empty;
                }
              }
            }
          }
        }
      }
    }

    // l2vpn / logging
    container logging {
      tailf:info "Configure l2vpn logging commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-log";
      tailf:cli-delete-when-empty;
      presence true;

      // l2vpn / logging / nsr
      leaf nsr {
        tailf:info "Enable Non-Stop Routing logging";
        tailf:cli-full-command;
        type empty;
      }

      // l2vpn / logging / pseudowire
      container pseudowire {
        tailf:info "Enable pseudowire logging";
        tailf:cli-delete-when-empty;
        presence true;
        leaf "status" {
          type empty;
        }
      }
    }

    // l2vpn / load-balancing
    container load-balancing {
      tailf:info "Global L2VPN Load Balancing";
      leaf flow {
        tailf:info "Enable Flow based load balancing";
        type enumeration {
          enum src-dst-ip {
            tailf:info "Use source and destination IP addresses for hashing";
          }
          enum src-dst-mac {
            tailf:info "Use source and destination MAC addresses for hashing";
          }
        }
      }
    }

    // l2vpn / capability
    leaf capability {
      tailf:info "Global capability mode";
      tailf:cli-full-command;
      type enumeration {
        enum high-mode {
          tailf:info "Compute global capability as the highest node capability";
        }
        enum single-mode {
          tailf:info "Disable global capability re-computation";
        }
      }
    }

    // l2vpn / ignore-mtu-mismatch
    leaf ignore-mtu-mismatch {
      tailf:info "Ignore MTU mismatch for all L2VPN(cisco-support)";
      tailf:cli-full-command;
      type empty;
    }

    // l2vpn / redundancy
    container redundancy {
      tailf:info "Redundancy";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-red";

      // l2vpn / redundancy / iccp group *
      container iccp {
        tailf:info "Inter-Chassis Communication Protocol";
        list group {
          tailf:info "Group configuration";
          tailf:cli-mode-name "config-l2vpn-red-grp";
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-4294967295>;;Enter group number";
            }
          }

          // l2vpn / redundancy / iccp group * / multi-homing node-id
          container multi-homing {
            tailf:info "ICCP-based service multi-homing";
            leaf node-id {
              tailf:info "Enter multi-homing node ID";
              type uint8 {
                tailf:info "<0-254>;;Node ID";
                range "0..254";
              }
            }
          }

          // l2vpn / redundancy / iccp group * / interface *
          list interface {
            tailf:info "Interface name";
            tailf:cli-mode-name "config-l2vpn-red-grp-intf";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }

            // l2vpn / redundancy / iccp group * / interface * / primary vlan
            container primary {
              tailf:info "Primary VLAN configuration";
              leaf-list vlan {
                tailf:info "Assign primary VLANs";
                tailf:cli-range-list-syntax;
                tailf:cli-replace-all;
                type uint16 {
                  tailf:info "WORD;;List of VLAN IDs in the form of 1-3,5,8-11";
                  range "1..4094";
                }
              }
            }

            // l2vpn / redundancy / iccp group * / interface * / secondary vlan
            container secondary {
              tailf:info "Secondary VLAN configuration";
              leaf-list vlan {
                tailf:info "Assign secondary VLANs";
                tailf:cli-range-list-syntax;
                tailf:cli-replace-all;
                type uint16 {
                  tailf:info "WORD;;List of VLAN IDs in the form of 1-3,5,8-11";
                  range "1..4094";
                }
              }
            }

            // l2vpn / redundancy / iccp group * / interface * / recovery delay
            container recovery {
              tailf:info "Failure recovery reversion delay timer.  "+
                "Default is revertive after 180 seconds.";
              leaf delay {
                tailf:info "Specify delay before recovery reversion after failure clears";
                type uint16 {
                  tailf:info "<30-3600>;;input time in seconds";
                  range "30..3600";
                }
              }
            }
          }
        }
      }
    }

    // l2vpn / pw-class *
    list pw-class {
      tailf:info "Pseudowire class template";
      tailf:cli-mode-name "config-l2vpn-pwc";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Pseudowire-class name";
        }
      }
      container encapsulation {
        tailf:info "Pseudowire encapsulation";

        // l2vpn / pw-class * / encapsulation l2tpv3
        container l2tpv3 {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-l2vpn-pwc-l2tpv3";

          // l2vpn / pw-class * / encapsulation l2tpv3 / protocol l2tpv3
          leaf protocol {
            tailf:info "Set the dynamic pseudowire signaling protocol";
            type enumeration {
              enum l2tpv3 {
                tailf:info "Set L2TPv3 as the signaling protocol for "
                  +"this pseudowire class";
              }
            }
          }
          // l2vpn / pw-class * / encapsulation l2tpv3 / ttl
          leaf ttl {
            tailf:info "Set the Time To Live (TTL)";
            type uint8 {
              tailf:info "<1-255>;;TTL value";
              range "1..255";
            }
          }
        }

        // l2vpn / pw-class * / encapsulation mpls
        container mpls {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-l2vpn-pwc-mpls";

          // l2vpn / pw-class * / encapsulation mpls / protocol ldp
          container protocol {
            tailf:info "Set the dynamic pseudowire signaling protocol";
            leaf ldp {
              tailf:info "Set LDP as the signaling protocol for this "+
                "pseudowire class";
              type empty;
            }
          }

          // l2vpn / pw-class * / encapsulation mpls / control-word
          leaf control-word {
            tailf:info "Enable Control word";
            type empty;
          }

          // l2vpn / pw-class * / encapsulation mpls / vccv
          container vccv {
            tailf:info "VCCV settings";
            container verification-type {
              tailf:info "Enable or disable VCCV verification type";
              leaf none {
                tailf:info "No VCCV verification";
                type empty;
              }
            }
          }

          // l2vpn / pw-class * / encapsulation mpls / transport-mode
          container transport-mode {
            tailf:info "Remote transport mode";
            choice transport-mode-choice {
              leaf ethernet {
                tailf:info "Ethernet port mode";
                type empty;
              }
              container vlan {
                tailf:info "Vlan tagged mode";
                tailf:cli-delete-when-empty;
                presence true;
                leaf passthrough {
                  tailf:info "passthrough incoming tags";
                  type empty;
                }
              }
            }
          }

          // l2vpn / pw-class * / encapsulation mpls / load-balancing
          container load-balancing {
            tailf:info "PW class Load Balancing";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-l2vpn-pwc-mpls-load-bal";

            // l2vpn / pw-class * / encapsulation mpls / load-balancing / flow-label
            container flow-label {
              tailf:info "Flow label based load balancing setting";

              // l2vpn / pw-class * / encapsulation mpls / load-balancing / flow-label both
              container both {
                tailf:info "Insert/Discard Flow label on transmit/recceive";
                tailf:cli-delete-when-empty;
                tailf:cli-reset-container;
                presence true;
                leaf static {
                  tailf:info "Set Flow label parameters statically";
                  type empty;
                }
              }
            }
          }

          // l2vpn / pw-class * / encapsulation mpls / preferred-path
          container preferred-path {
            tailf:info "Preferred path tunnel settings";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf interface {
              tailf:info "Use tunnel interface for preferred path";
              tailf:cli-incomplete-command;
              type enumeration {
                enum tunnel-ip {
                  tailf:info "Specify IP tunnel interface name for preferred path";
                }
                enum tunnel-te {
                  tailf:info "Specify TE tunnel interface name for preferred path";
                }
                enum tunnel-tp {
                  tailf:info "Specify TP tunnel interface name for preferred path";
                }
              }
            }
            leaf id {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-65535>;;Specify tunnel number for preferred path";
              }
            }
            // l2vpn / pw-class * / encapsulation mpls / preferred-path fallback
            leaf fallback {
              tailf:info "Fallback option for preferred path";
              type enumeration {
                enum disable {
                  tailf:info "Disable fallback for preferred path";
                }
              }
            }
          }

          // l2vpn / pw-class * / encapsulation mpls / ipv4 source
          container ipv4 {
            tailf:info "Set the local source IPv4 address";
            leaf source {
              tailf:info "The local source IPv4 address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;The source address";
              }
            }
          }

          // l2vpn / pw-class * / encapsulation mpls / redundancy
          container redundancy {
            tailf:info "PW redundancy settings";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-l2vpn-pwc-mpls-pw";
            leaf one-way {
              tailf:info "Force one-way PW redundancy behavior in "+
                "Redundancy Group";
              type empty;
            }
          }
        }
      }
    }

    // l2vpn / xconnect
    container xconnect {
      tailf:info "Configure cross connect commands";

      // l2vpn / xconnect group *
      list group {
        tailf:info "Specify the group the cross connects belong to";
        tailf:cli-mode-name "config-l2vpn-xc";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the cross connects group";
          }
        }

        // l2vpn / xconnect group * / mp2mp *
        list mp2mp {
          tailf:info "Specify the MP2MP instance name";
          tailf:cli-mode-name "config-l2vpn-xc-mp2mp";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the MP2MP instance";
            }
          }

          // l2vpn / xconnect group * / mp2mp * / vpn-id
          leaf vpn-id {
            tailf:info "VPN Identifier (VPN ID)";
            type uint32 {
              tailf:info "<1-4294967295>;;Value of the VPN ID";
              range "1..4294967295";
            }
          }

          // l2vpn / xconnect group * / mp2mp * / mtu
          leaf mtu {
            tailf:info "Set maximum transmission unit (payload) for this VPN MP2MP Instance";
            type uint32 {
              tailf:info "<64-4294967295>;;Value of the MTU";
              range "64..4294967295";
            }
          }

          // l2vpn / xconnect group * / mp2mp * / l2-encapsulation
          leaf l2-encapsulation {
            tailf:info "Configure the L2 encapsulation for this L2VPN MP2MP Instance";
            type enumeration {
              enum ethernet {
                tailf:info "Ethernet encapsulation";
              }
              enum vlan {
                tailf:info "Ethernet VLAN encapsulation";
              }
            }
          }

          // l2vpn / xconnect group * / mp2mp * / control-word
          container control-word {
            tailf:info "Set control-word option for this VPN MP2MP Instance";
            leaf disable {
              tailf:info "Disable control-word";
              type empty;
            }
          }

          // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp
          container autodiscovery {
            tailf:info "Enable auto-discovery in this MP2MP";
            container bgp {
              tailf:info "Enable BGP auto-discovery in this MP2MP";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-l2vpn-xc-mp2mp-ad";

              // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / rd
              leaf rd {
                tailf:info "route distinguisher";
                type string {
                  tailf:info "WORD;;AS-number, IPv4 address:index or 'auto'";
                }
              }

              // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / route-target
              uses route-target-import-export-grouping;

              // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / signaling-protocol bgp
              container signaling-protocol {
                tailf:info "Enable signaling protocol in this MP2MP";
                container bgp {
                  tailf:info "Enable BGP signaling protocol this MP2MP";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-l2vpn-xc-mp2mp-ad-sig";

                  // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / signaling-protocol bgp / ce-id *
                  list ce-id {
                    tailf:cli-mode-name "config-l2vpn-xc-mp2mp-ad-sig-ce";
                    key id;
                    leaf id {
                      type uint16 {
                        tailf:info "<1-16384>;;Value of the local CE ID";
                        range "1..16384";
                      }
                    }

                    // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / signaling-protocol bgp / ce-id * / interface * remote-ce-id
                    list interface {
                      tailf:info "Specify the attachment circuit";
                      tailf:cli-suppress-mode;
                      tailf:cli-delete-when-empty;
                      tailf:cli-incomplete-command;
                      key name;
                      leaf name {
                        type string {
                          tailf:info "WORD;;Interface Name";
                        }
                      }
                      leaf remote-ce-id {
                        tailf:info "Remote Customer Edge Identifier";
                        type uint16 {
                          tailf:info "<1-16384>;;Value of the remote CE ID";
                          range "1..16384";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        // l2vpn / xconnect group * / p2p *
        list p2p {
          tailf:info "Configure point to point cross connect commands";
          tailf:cli-mode-name "config-l2vpn-xc-p2p";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the point to point cross connect";
            }
          }

          // l2vpn / xconnect group * / p2p * / interface
          list interface {
            tailf:info "Specify the attachment circuit";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
          }

          // l2vpn / xconnect group * / p2p * / monitor-session
          leaf monitor-session {
            tailf:info "Specify the monitor session";
            type string {
              tailf:info "WORD;;Name of the monitor session";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:monitor-session/name";
            }
          }

          // l2vpn / xconnect group * / p2p * / neighbor *
          list neighbor {
            tailf:info "Specify the peer to cross connect";
            tailf:cli-mode-name "config-l2vpn-xc-p2p-pw";
            key "address pw-id";
            leaf address {
              type string {
                tailf:info "IP address of the peer";
              }
            }
            leaf pw-id {
              tailf:info "Specify the pseudowire id";
              tailf:cli-expose-key-name;
              type uint32 {
                tailf:info "<1-4294967295>;;Pseudowire ID";
              }
            }
            leaf ip-version {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type enumeration {
                enum ipv4 {
                  tailf:info "Specify IPv4 address or hostname";
                }
                enum ipv6 {
                  tailf:info "Specify IPv6 address or host name";
                }
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / mpls
            container mpls {
              tailf:info "MPLS L2VPN PW command";
              container static {
                tailf:info "MPLS L2VPN static settings";
                container label {
                  tailf:info "MPLS L2VPN static labels";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf local {
                    tailf:info "Local pseudowire label";
                    tailf:cli-incomplete-command;
                    type uint32 {
                      tailf:info "<16-1048575>;;Local pseudowire label";
                      range "16..1048575";
                    }
                  }
                  leaf remote {
                    tailf:info "Remote pseudowire label";
                    type uint32 {
                      tailf:info "<16-1048575>;;Remote pseudowire label";
                      range "16..1048575";
                    }
                  }
                }
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / pw-class
            leaf pw-class {
              tailf:info "PW class template name to use for this XC";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Pseudowire-class name";
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / tag-impose
            container tag-impose {
              tailf:info "tag impose mode";
              leaf vlan {
                tailf:info "vlan tagged mode";
                type uint16 {
                  tailf:info "<1-4094>;;vlan tagged mode";
                  range "1..4094";
                }
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / l2tp
            container l2tp {
              tailf:info "L2TP PW";
              container static {
                tailf:info "L2TP PW static";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-l2vpn-xc-p2p-pw-l2tp";
                container local {
                  tailf:info "L2TP PW static local";
                  container cookie {
                    tailf:info "L2TP PW static local cookie settings";
                    tailf:cli-flatten-container;
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf size {
                      tailf:info "L2TP PW static local cookie size settings";
                      type enumeration {
                        enum 0 {
                          tailf:info "The cookie size is zero bytes";
                        }
                        enum 4 {
                          tailf:info "The cookie size is four bytes";
                        }
                        enum 8 {
                          tailf:info "The cookie size is eight bytes";
                        }
                      }
                    }
                    container "value" {
                      tailf:info "The value of the cookie";
                      tailf:cli-flatten-container;
                      tailf:cli-compact-syntax;
                      tailf:cli-sequence-commands;
                      when "../size != 0";
                      leaf value-1 {
                        tailf:cli-drop-node-name;
                        type string {
                          tailf:info "<0x0-0xffffffff>;;Lower 4 bytes value";
                        }
                      }
                      leaf value-2 {
                        tailf:cli-drop-node-name;
                        when "../../size != 4";
                        type string {
                          tailf:info "<0x0-0xffffffff>;;Higher 4 bytes value";
                        }
                      }
                    }
                  }
                }
                container remote {
                  tailf:info "L2TP PW static remote";
                  container cookie {
                    tailf:info "L2TP PW static remote cookie settings";
                    tailf:cli-flatten-container;
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf size {
                      tailf:info "L2TP PW static remote cookie size settings";
                      type enumeration {
                        enum 0 {
                          tailf:info "The cookie size is zero bytes";
                        }
                        enum 4 {
                          tailf:info "The cookie size is four bytes";
                        }
                        enum 8 {
                          tailf:info "The cookie size is eight bytes";
                        }
                      }
                    }
                    container "value" {
                      tailf:info "The value of the cookie";
                      tailf:cli-flatten-container;
                      tailf:cli-compact-syntax;
                      tailf:cli-sequence-commands;
                      when "../size != 0";
                      leaf value-1 {
                        tailf:cli-drop-node-name;
                        type string {
                          tailf:info "<0x0-0xffffffff>;;Lower 4 bytes value";
                        }
                      }
                      leaf value-2 {
                        tailf:cli-drop-node-name;
                        when "../../size != 4";
                        type string {
                          tailf:info "<0x0-0xffffffff>;;Higher 4 bytes value";
                        }
                      }
                    }
                  }
                }
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / source
            leaf source {
              tailf:info "Source address of PW";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Source IPv6 address of PW";
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / backup
            container backup {
              tailf:info "Backup pseudowire for the cross connect";

              // l2vpn / xconnect group * / p2p * / neighbor * / backup neighbor *
              list neighbor {
                tailf:info "Specify the peer to cross connect";
                tailf:cli-mode-name "config-l2vpn-xc-p2p-pw-backup";
                key "address pw-id";
                leaf address {
                  type string {
                    tailf:info "IP address of the peer";
                  }
                }
                leaf pw-id {
                  tailf:info "Specify the pseudowire id";
                  tailf:cli-expose-key-name;
                  type uint32 {
                    tailf:info "<1-4294967295>;;Pseudowire ID";
                  }
                }
                // l2vpn / xconnect group * / p2p * / neighbor * / ..
                // .. backup neighbor * / pw-class
                leaf pw-class {
                  tailf:info "PW class template name to use for this XC backup";
                  tailf:cli-full-command;
                  type string {
                    tailf:info "WORD;;Pseudowire-class name";
                  }
                }
              }
            }
          }

          // l2vpn / xconnect group * / p2p * / description
          leaf "description" {
            tailf:info "Description for cross connect";
            tailf:cli-full-command;
            // note: not a multi-vale string, needs "" if whitespaces
            type string {
              tailf:info "WORD;;Cross connect description string";
            }
          }
        }
      }
    }

    // l2vpn / bridge
    container bridge {
      tailf:info "Configure bridge commands";

      // l2vpn / bridge group *
      list group {
        tailf:info "Specify the group the bridge belongs to";
        tailf:cli-mode-name "config-l2vpn-bg";
        key group-name;
        leaf group-name {
          tailf:info "Name of the bridge group";
          type string {
            tailf:info "WORD;;Name of the bridge group";
          }
        }

        // l2vpn / bridge group * / bridge-domain *
        list bridge-domain {
          tailf:info "Configure bridge domain";
          tailf:cli-mode-name "config-l2vpn-bg-bd";
          key bridge-domain-name;
          leaf bridge-domain-name {
            tailf:info "Name of the bridge domain";
            type string {
              tailf:info "WORD;;Name of the bridge domain";
            }
          }

          // l2vpn / bridge group * / bridge-domain * / storm-control
          uses storm-control-grouping;


          // l2vpn / bridge group * / bridge-domain * / interface *
          list interface {
            tailf:info "Assign interface to bridge domain";
            tailf:cli-mode-name "config-l2vpn-bg-bd-ac";
            key name;
            leaf name {
              tailf:info "Interface Name";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }

            // l2vpn / bridge group * / bridge-domain * / interface * / mac
            container mac {
              tailf:info "MAC configuration commands";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-l2vpn-bg-bd-ac-mac";
              uses l2vpn-bridge-domain-mac-grouping;
            }

            // l2vpn / bridge group * / bridge-domain * / interface * / storm-control
            uses storm-control-grouping;

            // l2vpn / bridge group * / bridge-domain * / interface * / igmp
            container igmp {
              tailf:info "IGMP protocol";
              container snooping {
                tailf:info "Set the snooping profile";
                leaf profile {
                  tailf:info "Attach a IGMP profile";
                  type string {
                    tailf:info "WORD;;IGMP Snooping profile name";
                  }
                }
              }
            }

            // .. / split-horizon group
            container split-horizon {
              tailf:info "Configure split horizon group";
              leaf group {
                tailf:info "Configure split horizon group";
                type empty;
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / mac
          container mac {
            tailf:info "MAC configuration commands";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-l2vpn-bg-bd-mac";

            // l2vpn / bridge group * / bridge-domain * / mac / aging
            container aging {
              tailf:info "MAC-Aging configuration commands";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-l2vpn-bg-bd-mac-aging";
              leaf time {
                tailf:info "Mac aging";
                type uint16 {
                  tailf:info "<300-30000>;;MAC address aging time in seconds";
                  range "300..3000";
                }
              }
            }

            // l2vpn / bridge group * / bridge-domain * / mac / learning
            // l2vpn / bridge group * / bridge-domain * / mac / limit
            // l2vpn / bridge group * / bridge-domain * / mac / secure
            uses l2vpn-bridge-domain-mac-grouping;

            // l2vpn / bridge group * / bridge-domain * / mac / withdraw
            container withdraw {
              tailf:info "MAC withdraw";
              choice withdraw-choice {
                leaf state-down {
                  tailf:info "MAC withdraw sent on bridge port down";
                  type empty;
                }
                leaf optimize {
                  tailf:info "Optimized LDP MAC withdraw (when port goes down)";
                  type empty;
                }
                leaf disable {
                  tailf:info "Disable MAC withdraw";
                  type empty;
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / flooding
          container flooding {
            tailf:info "Traffic flooding";

            // l2vpn / bridge group * / bridge-domain * / flooding disable
            leaf disable {
              tailf:info "Disable flooding";
              type empty;
            }

            // l2vpn / bridge group * / bridge-domain * / flooding unknown-unicast disable
            container unknown-unicast {
              tailf:info "Traffic flooding unknown unicast";
              leaf disable {
                tailf:info "Disable Unknown Unicast flooding";
                type empty;
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / mtu
          leaf mtu {
            tailf:info "Maximum transmission unit (payload) for this "+
              "Bridge Domain";
            type uint16 {
              tailf:info "<46-65535>;;Maximum transmission unit size "+
                "(payload) in bytes";
              range "46..65535";
            }
          }

          // l2vpn / bridge group * / bridge-domain * / igmp snooping
          container igmp {
            tailf:info "IGMP protocol";
            container snooping {
              tailf:info "Set the snooping profile";
              leaf profile {
                tailf:info "Attach an IGMP profile";
                type string {
                  tailf:info "WORD;;IGMP Snooping profile name";
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / neighbor *
          list neighbor {
            tailf:info "Specify the peer to cross connect";
            tailf:cli-mode-name "config-l2vpn-bg-bd-pw";
            key "address pw-id";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address of the peer";
              }
            }
            leaf pw-id {
              tailf:info "Specify the pseudowire id";
              tailf:cli-expose-key-name;
              type uint32 {
                tailf:info "<1-4294967295>;;Pseudowire ID";
                range "1..4294967295";
              }
            }

            // l2vpn / bridge group * / bridge-domain * / neighbor * / mpls
            container mpls {
              tailf:info "MPLS L2VPN PW command";
              container static {
                tailf:info "MPLS L2VPN static settings";
                container label {
                  tailf:info "MPLS L2VPN static labels";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf local {
                    tailf:info "Local pseudowire label";
                    tailf:cli-incomplete-command;
                    type uint32 {
                      tailf:info "<16-1048575>;;Local pseudowire label";
                      range "16..1048575";
                    }
                  }
                  leaf remote {
                    tailf:info "Remote pseudowire label";
                    type uint32 {
                      tailf:info "<16-1048575>;;Remote pseudowire label";
                      range "16..1048575";
                    }
                  }
                }
              }
            }

            // l2vpn / bridge group * / bridge-domain * / neighbor * / pw-class
            leaf pw-class {
              tailf:info "PW class template name to use for this pseudowire";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Pseudowire-class name";
              }
            }

            // l2vpn / bridge group * / bridge-domain * / neighbor * / storm-control
            uses storm-control-grouping;

            // l2vpn / bridge group * / bridge-domain * / neighbor * / split-horizon
            container split-horizon {
              tailf:info "Configure split horizon group";
              leaf group {
                tailf:info "Configure split horizon group";
                type empty;
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / access-vfi *
          list access-vfi {
            tailf:info "Specify the access virtual forwarding interface name";
            tailf:cli-mode-name "config-l2vpn-bg-bd-accessvfi";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Name of the Access Virtual Forwarding Interface";
              }
            }

            // l2vpn / bridge group * / bridge-domain * / access-vfi * / neighbor *
            list neighbor {
              tailf:info "Specify the peer to cross connect";
              tailf:cli-mode-name "config-l2vpn-bg-bd-accessvfi-pw";
              key "address pw-id";
              leaf address {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address of the peer";
                }
              }
              leaf pw-id {
                tailf:cli-expose-key-name;
                tailf:info "Specify the pseudowire id";
                type uint32 {
                  tailf:info "<1-4294967295>;;Pseudowire ID";
                  range "1..4294967295";
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / routed
          container routed {
            tailf:info "Bridge domain L3 interface";
            list interface {
              tailf:info "Assign interface to bridge domain";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "BVI;;Bridge-Group Virtual Interface";
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / vfi *
          list vfi {
            tailf:info "Specify the virtual forwarding interface name";
            tailf:cli-mode-name "config-l2vpn-bg-bd-vfi";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Name of the Virtual Forwarding Interface";
              }
            }

            // l2vpn / bridge group * / bridge-domain * / vfi * / vpn-id
            leaf vpn-id {
              tailf:info "VPN Identifier (VPN ID)";
              type uint32 {
                tailf:info "<1-4294967295>;;Value of the VPN ID";
                range "1..4294967295";
              }
            }

            // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp
            container autodiscovery {
              tailf:info "Enable auto-discovery in this VFI";
              container bgp {
                tailf:info "Enable BGP auto-discovery in this VFI";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-l2vpn-bg-bd-vfi-ad";

                // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / rd
                leaf rd {
                  tailf:info "route distinguisher";
                  tailf:cli-full-command;
                  type string {
                    tailf:info "WORD;;AS-number, IPv4 address:index or 'auto'";
                  }
                }

                // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / route-target *
                // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / route-target import *
                // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / route-target export *
                uses route-target-import-export-grouping;

                // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / signaling-protocol
                container signaling-protocol {
                  tailf:info "Enable signaling protocol for this VFI";

                  // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / signaling-protocol bgp
                  container bgp {
                    tailf:info "Enable BGP signaling protocol for this VFI";
                    tailf:cli-add-mode;
                    tailf:cli-mode-name "config-l2vpn-bg-bd-vfi-ad-sig";
                    presence true;

                    // .. / signaling-protocol bgp / ve-id
                    leaf ve-id {
                      tailf:info "Local Virtual Edge Identifier (VE ID)";
                      type uint16 {
                        tailf:info "<1-16384>;;Value of the local VE ID";
                        range "1..16384";
                      }
                    }

                    // .. / signaling-protocol bgp / ve-range
                    leaf ve-range {
                      tailf:info "Local Virtual Edge Block Configurable Range";
                      type uint16 {
                        tailf:info "<11-100>;;Value of the VE Range";
                        range "11..100";
                      }
                    }
                  }

                  // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / signaling-protocol ldp
                  container ldp {
                    tailf:info "Enable LDP signaling protocol for this VFI";
                    tailf:cli-add-mode;
                    tailf:cli-mode-name "config-l2vpn-bg-bd-vfi-ad-sig";
                    presence true;
                    leaf vpls-id {
                      tailf:info "VPLS ID";
                      type union {
                        type string {
                          tailf:info "<1-65535>;;Two Byte AS number";
                        }
                        type inet:ipv4-address {
                          tailf:info "A.B.C.D;;IP address";
                        }
                      }
                    }
                  }
                }
              }
            }

            // l2vpn / bridge group * / bridge-domain * / vfi * / neighbor *
            list neighbor {
              tailf:info "Specify the peer to cross connect";
              tailf:cli-mode-name "config-l2vpn-bg-bd-vfi-pw";
              key "address pw-id";
              leaf address {
                type string {
                  tailf:info "IP address of the peer";
                }
              }
              leaf pw-id {
                tailf:info "Specify the pseudowire id";
                tailf:cli-expose-key-name;
                type uint32 {
                  tailf:info "<1-4294967295>;;Pseudowire ID";
                }
              }
              // l2vpn / bridge group * / bridge-domain * / vfi * / neighbor * / pw-class
              leaf pw-class {
                tailf:info "PW class template name to use for this pseudowire";
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;Pseudowire-class name";
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / pbb
          container pbb {
            tailf:info "Configure Provider Backbone Bridge";

            // l2vpn / bridge group * / bridge-domain * / pbb edge *
            list edge {
              tailf:info "PBB edge bridge domain";
              tailf:cli-mode-name "config-l2vpn-bg-bd-pbb-edge";
              key "i-sid core-bridge";
              leaf i-sid {
                tailf:cli-expose-key-name;
                tailf:info "Configure Service Instance Identifier";
                type uint32 {
                  tailf:info "<256-16777214>;;Service Instance ID";
                  range "256..16777214";
                }
              }
              leaf core-bridge {
                tailf:cli-expose-key-name;
                tailf:info "Specifiy PBB core bridge domain to associate with";
                type string {
                  tailf:info "WORD;;Name of the PBB core bridge domain";
                }
              }

              // l2vpn / bridge group * / bridge-domain * / pbb edge * /
              // ... unknown-unicast-bmac
              leaf unknown-unicast-bmac {
                tailf:info "Unknown Unicast backbone MAC address";
                type string {
                  tailf:info "H.H.H;;Unknown Unicast backbone MAC address";
                }
              }
            }

            // l2vpn / bridge group * / bridge-domain * / pbb core
            container core {
              tailf:info "PBB core bridge domain";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-l2vpn-bg-bd-pbb-core";
              presence true;

              // l2vpn / bridge group * / bridge-domain * / pbb core / evi
              leaf evi {
                tailf:info "Ethernet VPN identifier";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<1-65534>;;Ethernet VPN ID to set";
                  range "1..65534";
                }
              }

              // l2vpn / bridge group * / bridge-domain * / pbb core / evpn evi
              container evpn {
                tailf:info "Specify the Ethernet VPN interface name [deprecated?]";
                leaf evi {
                  tailf:info "Ethernet VPN identifier";
                  type uint16 {
                    tailf:info "<1-65534>;;Ethernet VPN ID to set";
                    range "1..65534";
                  }
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / evpn evi
          container evpn {
            tailf:info "Specify the Ethernet VPN interface name";
            leaf evi {
              tailf:info "Ethernet VPN identifier";
              type uint16 {
                tailf:info "<1-65534>;;Ethernet VPN ID to set";
                range "1..65534";
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / evi *
          list evi {
            tailf:info "Ethernet VPN identifier";
            tailf:cli-mode-name "config-l2vpn-bg-bd-evi";
            max-elements 1;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65534>;;Ethernet VPN ID to set";
                range "1..65534";
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / member vni *
          container member {
            tailf:info "Bridge domain member";
            list vni {
              tailf:info "Assign VxLAN Network Identifier to bridge domain";
              tailf:cli-mode-name "config-l2vpn-bg-bd-vni";
              max-elements 1;
              key id;
              leaf id {
                type uint32 {
                  tailf:info "<1-16777215>;;Specify VxLAN Network Identifier value";
                  range "1..16777215";
                }
              }
            }
          }
        }
      }
    }

    // l2vpn / pbb
    container pbb {
      tailf:info "PBB configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-pbb";

      // l2vpn / pbb / backbone-source-mac
      leaf backbone-source-mac {
        tailf:info "Backbone Source MAC";
        type string {
          tailf:info "H.H.H;;Backbone Source MAC address";
          pattern '[0-9a-f]{4}\.[0-9a-f]{4}\.[0-9a-f]{4}';
        }
      }
    }
  }


  /// ========================================================================
  /// extcommunity-set
  /// ========================================================================

  container extcommunity-set {
    tailf:info "Define an extended community set";

    // extcommunity-set rt *
    list rt {
      tailf:info "BGP Route Target (RT) extended community";
      tailf:cli-mode-name "config-ext";
      tailf:cli-exit-command "end-set";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Route Target type extcommunity set name";
        }
      }
      uses set-list-grouping;
    }

    // extcommunity-set soo *
    list soo {
      tailf:info "BGP Site of Origin (SoO) extended community";
      tailf:cli-mode-name "config-ext";
      tailf:cli-exit-command "end-set";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Site of Origin type extcommunity set name";
        }
      }
      uses set-list-grouping;
    }
  }


  /// ========================================================================
  /// rd-set
  /// ========================================================================

  // rd-set *
  list rd-set {
    tailf:info "Define a BGP VPN route-distinguisher set";
    tailf:cli-mode-name "config-rd";
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Route Distinguisher set name";
      }
    }
    uses set-list-grouping;
  }


  /// ========================================================================
  /// prefix-set
  /// ========================================================================

  // prefix-set *
  list prefix-set {
    tailf:info "Define a prefix set";
    tailf:cli-mode-name "config-pfx";
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Prefix setname";
      }
    }
    uses set-list-grouping;
  }


  /// ========================================================================
  /// as-path-set
  /// ========================================================================

  // as-path-set *
  list as-path-set {
    tailf:info "Define an AS-path set";
    tailf:cli-mode-name "config-as";
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;AS-path set name";
      }
    }
    uses set-list-grouping;
  }


  /// ========================================================================
  /// community-set
  /// ========================================================================

  // community-set *
  list community-set {
    tailf:info "Define a community set";
    tailf:cli-mode-name "config-comm";
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Community set name";
      }
    }
    uses set-list-grouping;
  }


  /// ========================================================================
  /// rpl
  /// ========================================================================

  container rpl {
    tailf:info "RPL commands";

    // rpl editor
    leaf editor {
      tailf:info "Set default RPL editor";
      type enumeration {
        enum emacs {
          tailf:info "Set default RPL editor to Emacs";
        }
        enum nano {
          tailf:info "Set default RPL editor to nano";
        }
        enum vim {
          tailf:info "Set default RPL editor to Vim";
        }
      }
    }
  }


  /// ========================================================================
  /// route-policy
  /// ========================================================================

  list route-policy {
    tailf:info "Define a route policy";
    tailf:cli-mode-name "config-rpl";
    tailf:cli-delete-when-empty;
    tailf:cli-exit-command "end-policy";
    tailf:cli-full-command;
    tailf:cli-reset-container;
    tailf:meta-data "string-remove-quotes" {
      tailf:meta-value "route-policy <STRING>";
    }
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Route Policy name";
      }
    }

    leaf "value" {
      tailf:cli-drop-node-name;
      type string {
        tailf:info "WORD;;route-policy contents as a single quoted string.";
      }
    }
  }


  /// ========================================================================
  /// generic-interface-list
  /// ========================================================================

  list generic-interface-list {
    tailf:info "Interface list";
    tailf:cli-mode-name "config-gen-if-list";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Interface-list name";
      }
    }

    // generic-interface-list / interface *
    list interface {
      tailf:info "Specify an interface";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type ifname;
      }
    }
  }


  /// ========================================================================
  /// ospf
  /// ========================================================================

  container ospf {
    tailf:info "Global OSPF configuration commands";
    tailf:cli-explicit-exit;

    // ospf name-lookup
    leaf name-lookup {
      tailf:info "Display OSPF router ids as DNS names";
      type empty;
    }
  }


  /// ========================================================================
  /// router-convergence
  /// ========================================================================

  container router-convergence {
    tailf:info "Configure Router Convergence Monitoring";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-rcmd";
    tailf:cli-explicit-exit;

    // router-convergence / collect-diagnostics *
    list collect-diagnostics {
      tailf:info "Collect diagnostics on specified node";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Specified location";
        }
      }
    }
  }


  /// ========================================================================
  /// router
  /// ========================================================================

  container router {
    tailf:info "Enable a routing process";
    tailf:cli-explicit-exit;

    /// router static
    // router static
    container static {
      tailf:info "Static route configuration subcommands";
      tailf:cli-add-mode;
      uses router-static-grouping;

      // router static / vrf *
      list vrf {
        tailf:info "VRF Static route configuration subcommands";
        tailf:cli-mode-name "config-static-vrf";
        key name;
        leaf name {
          tailf:info "VRF name";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses router-static-grouping;
      }
    }

    /// router igmp
    // router igmp
    container igmp {
      tailf:info "IPv4 Address Family";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-igmp";
      presence true;
      uses router-igmp-grouping;

      // router igmp / vrf *
      list vrf {
        tailf:info "VRF configs";
        tailf:cli-mode-name "config-igmp-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter VRF name";
          }
        }
        uses router-igmp-grouping;
      }
    }

    /// router isis
    // router isis *
    container isis {
      tailf:info "ISO IS-IS";
      tailf:cli-incomplete-command;
      list tag {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-isis";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;ISO routing area tag";
          }
        }

        // router isis * / set-overload-bit
        container set-overload-bit {
          tailf:info "Signal other routers not to use us in SPF";
          tailf:cli-delete-when-empty;
          presence true;

          // router isis * / set-overload-bit on-startup
          leaf on-startup {
            tailf:info "Set overload-bit temporarily after reboot";
            type union {
              type uint32 {
                tailf:info "<5-86400>;;Time in seconds to advertise "
                  +"ourself as overloaded after reboot";
                range "5..86400";
              }
              type enumeration {
                enum wait-for-bgp {
                  tailf:info "Let BGP decide when to unset the overload bit";
                }
              }
            }
          }

          // router isis * / set-overload-bit
          list level-list {
            tailf:info "Set overload-bit for one level only";
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-sequence-commands;
            key level;
            leaf level {
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<1-2>;;Level";
                range "1..2";
              }
            }

            // router isis * / set-overload-bit level * on-startup
            leaf on-startup {
              tailf:info "Set overload-bit temporarily after reboot";
              tailf:cli-prefix-key;
              type union {
                type uint32 {
                  tailf:info "<5-86400>;;Time in seconds to advertise "
                    +"ourself as overloaded after reboot";
                  range "5..86400";
                }
                type enumeration {
                  enum wait-for-bgp {
                    tailf:info "Let BGP decide when to unset the overload bit";
                  }
                }
              }
            }

            // router isis * / set-overload-bit level * advertise
            container advertise {
              tailf:info "If overload-bit set advertise the following "+
                "types of IP prefixes";
              tailf:cli-compact-syntax;
              leaf external {
                tailf:info "If overload-bit set advertise IP prefixes "+
                  "learned from other protocols";
                type empty;
              }
              leaf interlevel {
                tailf:info "If overload-bit set advertise IP prefixes "+
                  "learned from another ISIS level";
                type empty;
              }
            }
          }

          // router isis * / set-overload-bit suppress
          container suppress {
            tailf:info "If overload-bit set, suppress the following "
              +"types of IP prefixes";
            tailf:cli-compact-syntax;
            leaf external {
              tailf:info "If overload-bit set, don't advertise IP "
                +"prefixes learned from other protocols";
              type empty;
            }
            leaf interlevel {
              tailf:info "If overload-bit set, don't advertise IP "
                +"prefixes learned from another ISIS level";
              type empty;
            }
          }
        }

        // router isis * / is-type
        leaf is-type {
          tailf:info "IS Level for this routing process (OSI only)";
          type enumeration {
            enum level-1 {
              tailf:info "Act as a station router only";
            }
            enum level-1-2 {
              tailf:info "Act as both a station router and an area router";
            }
            enum level-2-only {
              tailf:info "Act as an area router only";
            }
          }
        }

        // router isis * / net *
        list net {
          tailf:info "A Network Entity Title for this process (OSI only)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type string {
              tailf:info "XX.XXXX. ... .XXX.XX;;Network entity title (NET)";
            }
          }
        }

        // router isis * / nsf
        container nsf {
          tailf:info "Non-stop forwarding";

          choice nsf-choice {
            container advertise {
              tailf:info "Send information to neighbors";
              leaf holdtime {
                tailf:info "Adjust holdtime advertised in IIH when RR set";
                type uint16 {
                  tailf:info "<5-3600>;;Seconds";
                  range "5..3600";
                }
              }
            }
            leaf cisco {
              tailf:info "Checkpoint method";
              type empty;
            }
            leaf ietf {
              tailf:info "IETF method";
              type empty;
            }
            container interface {
              tailf:info "Interface properties";
              leaf wait {
                tailf:info "Maximum time to wait for interface up";
                type uint8 {
                  tailf:info "<1-60>;;Seconds";
                  range "1..60";
                }
              }
            }
            leaf interval {
              tailf:info "Minimum required stable interval between restarts";
              type uint16 {
                tailf:info "<0-1440>;;Minutes";
                range "0..1440";
              }
            }
            container t3 {
              tailf:info "Time to set overload-bit if LSPDB "
                +"synchronization not completed (T3 expiration)";
              choice t3-choice {
                leaf adjacency {
                  tailf:info "Use minimum advertised adjacency holdtime"
                    +" for NSF T3 timeout";
                  type empty;
                }
                leaf manual {
                  tailf:info "Manually configure NSF T3 timeout";
                  type uint16 {
                    tailf:info "<5-3600>;;Seconds";
                    range "5..3600";
                  }
                }
              }
            }
          }

          // router isis * / nsf lifetime
          leaf lifetime {
            tailf:info "Maximum route lifetime following restart (seconds)";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<5-300>;;second";
              range "5..300";
            }
          }

          // router isis * / nsf interface-timer
          leaf interface-timer {
            tailf:info "Timer used to wait for a restart ACK (seconds)";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1-20>;;seconds";
              range "1..20";
            }
          }
        }

        // router isis * / nsr
        leaf nsr {
          tailf:info "Enable NSR";
          tailf:cli-full-command;
          type empty;
        }

        // router isis * / distribute bgp-ls
        container distribute {
          tailf:info "Distribute routing information to external services";
          container bgp-ls {
            tailf:info "Set external routing service to BGP-LS";
            tailf:cli-compact-syntax;
            leaf level {
              tailf:info "Set distribution for one level only";
              type uint8 {
                tailf:info "<1-2>;;Level";
                range "1..2";
              }
            }
            leaf throttle {
              tailf:info "Set throttle update in seconds";
              type uint8 {
                tailf:info "<5-20>;;Seconds";
                range "5..20";
              }
            }
          }
        }

        // router isis * / log
        container log {
          tailf:info "Log changes in adjacency state";
          container adjacency {
            tailf:info "Enable logging of adjacency state";
            leaf changes {
              tailf:info "Enable logging adjacency state changes";
              type empty;
            }
          }
          container pdu {
            tailf:info "Enable PDU logging";
            leaf drops {
              tailf:info "Enable logging PDU drops";
              type empty;
            }
          }
        }

        // router isis * / lsp-gen-interval
        container lsp-gen-interval {
          tailf:info "System and Pseudonode LSP generation scheduling "+
            "parameters";
          tailf:cli-compact-syntax;
          leaf maximum-wait {
            tailf:info "Maximum delay before generating an LSP";
            type uint32 {
              tailf:info "<0-120000>;;Delay in milliseconds";
              range "0..120000";
            }
          }
          leaf initial-wait {
            tailf:info "Initial delay before generating an LSP";
            type uint32 {
              tailf:info "<0-120000>;;Delay in milliseconds";
              range "0..120000";
            }
          }
          leaf secondary-wait {
            tailf:info "Secondary delay before generating an LSP";
            type uint32 {
              tailf:info "<0-120000>;;Delay in milliseconds";
              range "0..120000";
            }
          }
        }

        // router isis * / lsp-check-interval
        leaf lsp-check-interval {
          tailf:info "Set LSP checksum check interval(cisco-support)";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<10-65535>;;LSP checksum check interval time in seconds";
            range "10..65535";
          }
        }

        // router isis * / lsp-refresh-interval
        leaf lsp-refresh-interval {
          tailf:info "Set LSP refresh interval";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-65535>;;LSP refresh time in seconds";
            range "1..65535";
          }
        }

        // router isis * / lsp-mtu
        leaf lsp-mtu {
          tailf:info "Set maximum LSP size";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<128-4352>;;Max LSP size in bytes";
            range "128..4352";
          }
        }

        // router isis * / lsp-password
        container lsp-password {
          tailf:info "Configure the area password";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf auth-type {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum hmac-md5 {
                tailf:info "Use HMAC-MD5 authentication";
              }
              enum text {
                tailf:info "Use cleartext password authentication";
              }
            }
          }
          leaf enc-type {
            tailf:info "The encryption type";
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum clear {
                tailf:info "Specifies an unencrypted password will follow";
              }
              enum encrypted {
                tailf:info "Specifies an encrypted password will follow";
              }
            }
          }
          choice password-choice {
            leaf password {
              tailf:info "The password";
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;The unencrypted (clear text) LSP/SNP password";
              }
            }
            leaf keychain {
              tailf:info "Specifies a Key Chain name will follow";
              tailf:non-strict-leafref {
                path "/cisco-ios-xr:key/chain/name";
              }
              type string {
                tailf:info "WORD;;The Key Chain name";
              }
            }
          }
          leaf level {
            tailf:cli-break-sequence-commands;
            tailf:info "Set lsp-password for one level only";
            type uint8 {
              tailf:info "<1-2>;;Set lsp-password for LSPs/SNPs "+
                "at this level only";
              range "1..2";
            }
          }
          leaf send-only  {
            tailf:info "Authenticate outgoing LSPs/SNPs only";
            type empty;
          }
          leaf snp {
            tailf:info "Specify SNP packets authentication mode";
            type empty;
          }
        }

        // router isis * / max-lsp-lifetime
        leaf max-lsp-lifetime {
          tailf:info "Set maximum LSP lifetime";
          type uint16 {
            tailf:info "<1-65535>;;Maximum LSP lifetime in seconds";
            range "1..65535";
          }
        }

        // router isis * / address-family
        container address-family {
          tailf:info "Enter the IS-IS address-family "+
            "configuration submode";

          // router isis * / address-family ipv4 unicast
          container ipv4 {
            tailf:info "IPV4 address family";
            container unicast {
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-isis-af";
              presence true;
              uses router-isis-common-grouping;
              uses router-isis-common-af-grouping;
              uses router-isis-af-grouping;
            }
          }

          // router isis * / address-family ipv6 unicast
          container ipv6 {
            tailf:info "IPV6 address family";
            container unicast {
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-isis-af";
              presence true;
              uses router-isis-common-grouping;
              uses router-isis-common-af-grouping;
              uses router-isis-af-grouping;
            }
          }
        }

        // router isis * / interface *
        list interface {
          tailf:info "Enter the IS-IS interface configuration submode";
          tailf:cli-mode-name "config-isis-if";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }

          // router isis / interface * / interface-type
          leaf interface-type {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type enumeration {
              enum active {
              }
              enum passive {
                tailf:info "Do not establish adjacencies over this interface";
              }
              enum suppressed {
                tailf:info "Do not advertise connected prefixes of "+
                  "this interface";
              }
              enum shutdown {
                tailf:info "Shutdown IS-IS on this interface";
              }
            }
          }

          // router isis / interface * / circuit-type
          leaf circuit-type {
            tailf:info "Configure circuit type for interface";
            type enumeration {
              enum level-1 {
                tailf:info "Form level-1 adjacencies only";
              }
              enum level-1-2 {
                tailf:info "Form level-1 and level-2 adjacencies";
              }
              enum level-2-only {
                tailf:info "Form level-2 adjacencies only";
              }
            }
          }

          // router isis / interface * / bfd
          container bfd {
            tailf:info "Configure BFD parameters";
            leaf fast-detect {
              tailf:info "Enable Fast detection";
              tailf:cli-full-command;
              type enumeration {
                enum ipv4 {
                  tailf:info "Address Family";
                }
                enum ipv6 {
                  tailf:info "Address Family";
                }
                enum disable {
                }
              }
            }
            leaf minimum-interval {
              tailf:info "Hello interval";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<3-30000>;;hello interval in milli-seconds";
              }
            }
            leaf multiplier {
              tailf:info "Detect multiplier";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<2-50>;;Detect multiplier";
              }
            }
          }

          // router isis / interface * / priority
          leaf priority {
            tailf:info "Set priority for Designated Router election";
            type uint8 {
              tailf:info "<0-127>;;Priority value";
              range "0..127";
            }
          }

          // router isis / interface * / point-to-point
          leaf point-to-point {
            tailf:info "Treat active LAN interface as point-to-point";
            tailf:cli-full-command;
            type empty;
          }

          // router isis * / interface * / lsp-interval
          container lsp-interval {
            tailf:info "Set LSP transmission interval";
            leaf milliseconds {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<1-4294967295>;;LSP transmission interval (milliseconds)";
                range "1..4294967295";
              }
            }
          }

          // router isis * / interface * / hello-interval
          leaf hello-interval {
            tailf:info "Set Hello interval in seconds";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Hello interval value";
            }
          }

          // router isis / interface * / hello-padding
          leaf hello-padding {
            tailf:info "Add padding to IS-IS hello packets";
            tailf:cli-full-command;
            type enumeration {
              enum disable {
                tailf:info "Disable hello-padding";
              }
              enum enable {
                tailf:info "Enable hello-padding during adjacency "+
                  "formation only";
              }
              enum sometimes {
                tailf:info "Enable hello-padding during adjacency "+
                "formation only";
              }
            }
          }

          // router isis / interface * / hello-password
          container hello-password {
            tailf:info "Configure the IIH password";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-incomplete-command;
            choice authentication-choice {
              leaf keychain {
                tailf:info "Specifies a Key Chain name will follow";
                tailf:cli-optional-in-sequence;
                tailf:cli-disallow-value "keychain|accept|hmac-md5|text|clear|encrypted";
                type string {
                  tailf:info "WORD;;The Key Chain name";
                }
              }
              leaf accept {
                tailf:info "Use password for incoming authentication only";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              leaf hmac-md5 {
                tailf:info "Use HMAC-MD5 authentication";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              leaf text {
                tailf:info "Use cleartext password authentication";
                tailf:cli-optional-in-sequence;
                type empty;
              }
            }
            choice password-choice {
              leaf clear {
                when "not(../keychain)" {
                  tailf:dependency "../keychain";
                }
                tailf:info "Specifies an unencrypted password will follow";
                type string {
                  tailf:info "WORD;;The unencrypted (clear text) hello password";
                }
              }
              leaf encrypted {
                when "not(../keychain)" {
                  tailf:dependency "../keychain";
                }
                tailf:info "Specifies an encrypted password will follow";
                type string {
                  tailf:info "WORD;;The encrypted hello password";
                }
              }
              leaf password {
                when "not(../keychain)" {
                  tailf:dependency "../keychain";
                }
                tailf:cli-drop-node-name;
                tailf:cli-disallow-value "keychain|accept|hmac-md5|text"+
                  "|clear|encrypted|level|send-only";
                type string {
                  tailf:info "WORD;;The unencrypted (clear text) hello password";
                }
              }
            }
            leaf level {
              tailf:info "Set hello-password for one level only";
              tailf:cli-optional-in-sequence;
              type uint8 {
                tailf:info "<1-2>;;Set hello-password for IIHs at this level only";
                range "1..2";
              }
            }
            leaf send-only {
              tailf:info "Do not require authentication of incoming IIHs";
              type empty;
            }
          }

          // router isis / interface * / link-down
          container link-down {
            tailf:info "Configure interface down event parameters";
            leaf fast-detect {
              tailf:info "Enable high priority detection";
              type empty;
            }
          }

          // router isis / interface * / retransmit-throttle-interval
          container retransmit-throttle-interval {
            tailf:info "Minimum interval betwen retransissions of different LSPs";
            leaf milliseconds {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<0-65535>;;(milliseconds)";
              }
            }
            // router isis / interface * / retransmit-throttle-interval ? level 1
            // router isis / interface * / retransmit-throttle-interval ? level 2
          }

          // router isis / interface * / address-family
          container address-family {
            tailf:info "Enter the IS-IS interface address-family "+
              "configuration submode";

            // router isis * / interface * / address-family ipv4 unicast
            container ipv4 {
              tailf:info "IPV4 address family";
              container unicast {
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-isis-if-af";
                presence true;
                uses router-isis-common-af-grouping;
                uses router-isis-if-af-grouping;
              }
            }

            // router isis * / interface * / address-family ipv6 unicast
            container ipv6 {
              tailf:info "IPV6 address family";
              container unicast {
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-isis-if-af";
                presence true;
                uses router-isis-common-af-grouping;
                uses router-isis-if-af-grouping;
              }
            }
          }
        }

        // router isis * / authentication
        container authentication {
          tailf:info "ISIS authentication for LSPs";
          container key-chain {
            tailf:info "Authentication key-chain";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf ref {
              tailf:cli-drop-node-name;
              type string {
              }
              tailf:non-strict-leafref {
                path "/cisco-ios-xr:key/chain/name";
              }
            }
            leaf level {
              tailf:cli-drop-node-name;
              type enumeration {
                enum level-1 {
                  tailf:info "ISIS authentication for level-1";
                }
                enum level-2 {
                  tailf:info "ISIS authentication for level-2";
                }
              }
            }
          }
          container mode {
            tailf:info "Authentication mode";
            choice mode-choice {
              container md5 {
                tailf:info "Keyed message digest";
                presence true;
                leaf level {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum level-1 {
                      tailf:info "ISIS authentication for level-1";
                    }
                    enum level-2 {
                      tailf:info "ISIS authentication for level-2";
                    }
                  }
                }
              }

              container text {
                tailf:info "Clear text password";
                presence true;
                leaf level {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum level-1 {
                      tailf:info "ISIS authentication for level-1";
                    }
                    enum level-2 {
                      tailf:info "ISIS authentication for level-2";
                    }
                  }
                }
              }
            }
          }
          //  send-only  Authentication send only, receive ignore
        }

        // router isis * / bfd
        container bfd {
          tailf:info "BFD configuration commands";
          leaf all-interfaces {
            tailf:info "Enable BFD on all interfaces";
            type empty;
          }
          leaf check-ctrl-plane-failure {
            tailf:info "BFD check control plane failure";
            type empty;
          }
        }

        // router isis * / mpls
        container mpls {
          tailf:info "Configure MPLS routing protocol parameters";

          // router isis * / mpls ldp
          leaf ldp {
            tailf:info "routing protocol commands for MPLS LDP";
            type enumeration {
              enum "sync" {
                tailf:info "Configure LDP-IGP Synchronization";
              }
            }
          }

          // router isis * / mpls traffic-eng
          container traffic-eng {
            tailf:info "routing protocol commands for MPLS Traffic Engineering";
            leaf level-1 {
              tailf:info "Run MPLS TE on IS-IS level 1 only";
              type empty;
            }
            leaf level-2 {
              tailf:info "Run MPLS TE on IS-IS level 2 only";
              type empty;
            }
            leaf multicast-intact {
              tailf:info "MPLS TE and PIM interaction";
              type empty;
            }
            leaf router-id {
              tailf:info "Traffic Engineering stable IP address for system";
              type empty;
            }
            leaf scanner {
              tailf:info "Timer parameters for TE database";
              type empty;
            }
          }
        }

        uses router-isis-common-grouping;
      }
    }

    /// router ospf *
    // router ospf *
    list ospf {
      tailf:info "OSPF configuration subcommands";
      tailf:cli-mode-name "config-ospf";
      key name;
      leaf name {
        tailf:info "Name for this OSPF process";
        type string {
          tailf:info "WORD;;Name for this OSPF process";
        }
      }

      uses router-ospf-authentication-grouping;

      uses router-ospf-grouping;

      // router ospf * / mpls
      container mpls {
        tailf:info "Configure MPLS routing protocol parameters";

        // router ospf * / mpls traffic-eng
        container traffic-eng {
          tailf:info "Routing protocol commands for MPLS Traffic Engineering";

          // router ospf * / mpls traffic-eng router-id
          container router-id {
            tailf:info "Traffic Engineering stable IP address for system";
            uses interface-name-grouping;
          }

          // router ospf * / mpls traffic-eng multicast-intact
          leaf multicast-intact {
            tailf:info "Publish multicast-intact paths to RIB";
            tailf:cli-full-command;
            type empty;
          }
        }

        // router ospf * / mpls ldp
        container ldp {
          tailf:info "Configure LDP parameters";

          // router ospf * / mpls ldp sync
          leaf sync {
            tailf:info "Enable LDP IGP synchronization";
            tailf:cli-full-command;
            type empty;
          }

          // router ospf * / mpls ldp auto-config
          leaf auto-config {
            tailf:info "Enable LDP IGP interface auto-configuration";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // router ospf * / vrf *
      list vrf {
        tailf:info "Enter the OSPF vrf configuration submode";
        tailf:cli-mode-name "config-ospf-vrf";
        key name;
        leaf name {
          tailf:info "Name for this OSPF vrf";
          type string {
            tailf:info "WORD;;Name for this OSPF vrf";
          }
        }
        // router ospf * / vrf * / ?
        uses router-ospf-grouping;
      }
    }

    /// router ospfv3 *
    // router ospfv3 *
    list ospfv3 {
      tailf:info "IPv6 Open Shortest Path First protocol (OSPFv3)";
      tailf:cli-mode-name "config-ospfv3";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name for this OSPFv3 process";
        }
      }

      uses router-ospfv3-grouping;

      // router ospfv3 * / vrf *
      list vrf {
        tailf:info "Enter the OSPFv3 vrf configuration submode";
        tailf:cli-mode-name "config-ospfv3-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name for this OSPFv3 vrf";
          }
        }
        // router ospfv3 * / vrf * / ?
        uses router-ospfv3-grouping;
      }

    }

    /// router bgp *
    // router bgp *
    container bgp {
      tailf:info "BGP configuration subcommand";

      // router bgp *
      list bgp-no-instance {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-bgp";
        key id;
        leaf id {
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;Autonomous system number";
              range "1..4294967295";
            }
            type string {
              tailf:info "<1.0-XX.YY>;;Autonomous system number";
              pattern '[0-9]+\.[0-9]+';
            }
          }
        }
        uses router-bgp-grouping {
          refine "session-group/password/password-choice/clear/clear" {
            tailf:meta-data "secret-password" {
              tailf:meta-value "router bgp <bgp-no-instance><NL><*> session-group <session-group><NL><*> ::   password <PASSWORD>";
            }
          }
          refine "neighbor-group/password/password" {
            tailf:meta-data "secret-password" {
              tailf:meta-value "router bgp <bgp-no-instance><NL><*> neighbor-group <neighbor-group><NL><*> ::   password <PASSWORD>";
            }
          }
          refine "neighbor/password/password" {
            tailf:meta-data "secret-password" {
              tailf:meta-value "router bgp <bgp-no-instance><NL><*> neighbor <neighbor><NL><*> ::   password <PASSWORD>";
            }
          }
          refine "vrf/neighbor/password/password" {
            tailf:meta-data "secret-password" {
              tailf:meta-value "router bgp <bgp-no-instance><NL><*> vrf <vrf><NL><*>  neighbor <neighbor><NL><*> ::    password <PASSWORD>";
            }
          }
        }
      }

      // router bgp * instance
      list bgp-instance {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-bgp";
        key "id instance";
        leaf id {
          tailf:info "Autonomous system number";
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;Autonomous system number";
              range "1..4294967295";
            }
            type string {
              tailf:info "<1.0-XX.YY>;;Autonomous system number";
              pattern '[0-9]+\.[0-9]+';
            }
          }
        }
        leaf instance {
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;instance name (maximum length 32 characters)";
          }
        }
        uses router-bgp-grouping;
      }
    }

    /// router mld
    // router mld
    container mld {
      tailf:info "IPv6 address family";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mld";

      uses router-mld-grouping;

      // router mld / vrf *
      list vrf {
        tailf:info "VRF configs";
        tailf:cli-mode-name "config-mld-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter VRF name";
          }
        }
        uses router-mld-grouping;
      }
    }

    /// router pim
    // router pim
    container pim {
      tailf:info "PIM configuration subcommands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-pim";

      uses router-pim-grouping;

      // router pim / vrf *
      list vrf {
        tailf:info "VRF configs";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter VRF name";
          }
        }
        uses router-pim-grouping;
      }
    }

    /// router rip
    // router rip
    container rip {
      tailf:info "RIP configuration subcommands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-rip";
      presence true;

      uses router-rip-grouping;

      // router rip / vrf *
      list vrf {
        tailf:info "VRF configs";
        tailf:cli-mode-name "config-rip-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter VRF name";
          }
        }
        uses router-rip-grouping;
      }
    }

    /// router eigrp *
    // router eigrp *
    list eigrp {
      tailf:info "EIGRP configuration subcommands";
      tailf:cli-mode-name "config-eigrp";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;AS number (1 - 65535) or Virtual instance name of the EIGRP process";
        }
      }
      uses router-eigrp-grouping;

      // router eigrp * / vrf *
      list vrf {
        tailf:info "EIGRP VRF configuration submode";
        tailf:cli-mode-name "config-eigrp-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses router-eigrp-grouping;
      }
    }

    /// router vrrp
    // router vrrp
    container vrrp {
      tailf:info "VRRP configuration subcommands";
      tailf:cli-add-mode;

      // router vrrp / interface *
      list interface {
        tailf:cli-mode-name "config-vrrp-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // router vrrp / interface * / bfd
        container bfd {
          tailf:info "Configure BFD parameters";

          // router vrrp / interface * / bfd minimum-interval
          leaf minimum-interval {
            tailf:info "Hello interval";
            type uint16 {
              tailf:info "<3-30000>;;hello interval in milli-seconds";
              range "3..30000";
            }
          }

          // router vrrp / interface * / bfd multiplier
          leaf multiplier {
            tailf:info "Detect multiplier";
            type uint8 {
              tailf:info "<2-50>;;Detect multiplier";
              range "2..50";
            }
          }
        }

        // router vrrp / interface * / address-family
        container address-family {
          tailf:info "VRRP address family";

          // router vrrp / interface * / address-family ipv4
          container ipv4 {
            tailf:info "IPv4 address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrrp-address-family";

            // router vrrp / interface * / address-family ipv4 / vrrp *
            list vrrp {
              tailf:cli-mode-name "config-vrrp-virtual-router";
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<1-255>;;VRID Virtual Router Identifier";
                  range "1..255";
                }
              }

              uses router-vrrp-if-af-vrrp-grouping;

              // router vrrp / interface * / address-family ipv4 / vrrp * / address *
              list address {
                tailf:info "Enable VRRP and specify IP address(es)";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                key ip;
                leaf ip {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;VRRP IPv4 address";
                  }
                }
                leaf secondary {
                  tailf:info "Set Secondary VRRP IP address";
                  type empty;
                }
              }

              // router vrrp / interface * / address-family ipv4 / vrrp * / bfd
              container bfd {
                tailf:info "Configure BFD parameters";
                container fast-detect {
                  tailf:info "Enable Fast detection";
                  container peer {
                    tailf:info "Information about VRRP peer for BFD monitoring";
                    leaf ipv4 {
                      tailf:info "BFD peer interface IPv4 address";
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;VRRP BFD remote interface IP address";
                      }
                    }
                  }
                }
              }

              // router vrrp / interface * / address-family ipv4 / vrrp * / text-authentication
              leaf text-authentication {
                tailf:info "Set plain text authentication string";
                type string {
                  tailf:info "WORD;;Authentication password, 8 chars max";
                  length "1..8";
                }
              }
            }
          }

          // router vrrp / interface * / address-family ipv6
          container ipv6 {
            tailf:info "IPv6 address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrrp-address-family";

            // router vrrp / interface * / address-family ipv6 / vrrp *
            list vrrp {
              tailf:cli-mode-name "config-vrrp-virtual-router";
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<1-255>;;VRID Virtual Router Identifier";
                  range "1..255";
                }
              }

              uses router-vrrp-if-af-vrrp-grouping;

              // router vrrp / interface * / address-family ipv6 / vrrp * / address
              container address {
                tailf:info "Enable VRRP and specify IP address(es)";

                // router vrrp / interface * / address-family ipv6 / vrrp * / address global *
                list global {
                  tailf:info "Global VRRP IPv6 address";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  key ip;
                  leaf ip {
                    type inet:ipv6-address {
                      tailf:info "X:X::X;;Set Global VRRP IPv6 address";
                    }
                  }
                }

                // router vrrp / interface * / address-family ipv6 / vrrp * / address linklocal
                leaf linklocal {
                  tailf:info "VRRP IPv6 linklocal address";
                  type union {
                    type inet:ipv6-address {
                      tailf:info "X:X::X;;VRRP IPv6 linklocal address ";
                    }
                    type enumeration {
                      enum autoconfig {
                        tailf:info "Autoconfigure the VRRP IPv6 linklocal address";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    /// router hsrp
    // router hsrp
    container hsrp {
      tailf:info "HSRP configuration subcommands";
      tailf:cli-add-mode;

      // router hsrp / interface *
      list interface {
        tailf:info "VRRP interface configuration subcommands";
        tailf:cli-mode-name "config-hsrp-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // router hsrp / interface * / hsrp
        container hsrp {
          tailf:info "HSRP configuration";

          // router hsrp / interface * / hsrp bfd
          container bfd {
            tailf:info "Configure BFD parameters";

            // router hsrp / interface * / hsrp bfd minimum-interval
            leaf minimum-interval {
              tailf:info "Hello interval";
              type uint16 {
                tailf:info "<3-30000>;;hello interval in milli-seconds";
                range "3..30000";
              }
            }

            // router hsrp / interface * / hsrp bfd multiplier
            leaf multiplier {
              tailf:info "Detect multiplier";
              type uint8 {
                tailf:info "<2-50>;;Detect multiplier";
                range "2..50";
              }
            }
          }

          // router hsrp / interface * / hsrp delay
          container delay {
            tailf:info "Set activation delay for hsrp";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf minimum {
              tailf:info "Set minimum delay on every interface up event";
              type uint16 {
                tailf:info "<0-10000>;;Minimum delay in seconds";
                range "0..10000";
              }
            }
            leaf reload {
              tailf:info "Set reload delay for first interface up even";
              type uint16 {
                tailf:info "<0-10000>;;Reload delay in seconds";
                range "0..10000";
              }
            }
          }

          // router hsrp / interface * / hsrp use-bia
          leaf use-bia {
            tailf:info "Use burned-in address";
            tailf:cli-full-command;
            type empty;
          }
        }

        // router hsrp / interface * / address-family
        container address-family {
          tailf:info "HSRP address family";

          // router hsrp / interface * / address-family ipv4
          container ipv4 {
            tailf:info "IPv4 address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-hsrp-ipv4";

            // router hsrp / interface * / address-family ipv4 / hsrp
            container hsrp {
              tailf:info "HSRP group configuration";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-hsrp-gp";
              uses router-hsrp-ipv4-group-grouping;
            }

            // router hsrp / interface * / address-family ipv4 / hsrp *
            container hsrp-version1-list {
              tailf:cli-drop-node-name;
              list hsrp {
                tailf:cli-mode-name "config-hsrp-gp";
                key id;
                leaf id {
                  type uint16 {
                    tailf:info "<0-4095>;;group number (version 1 0-255, version 2 0-4095)";
                    range "0..4095";
                  }
                }
                uses router-hsrp-ipv4-group-grouping;
              }
            }

            // router hsrp / interface * / address-family ipv4 / hsrp version 2
            container hsrp-version2 {
              tailf:cli-drop-node-name;
              container hsrp {
                tailf:info "HSRP group configuration";
                list version {
                  tailf:info "HSRP version";
                  tailf:cli-mode-name "config-hsrp-gp";
                  key version;
                  leaf version {
                    type enumeration {
                      enum "2" {}
                    }
                  }
                  uses router-hsrp-ipv4-group-grouping;
                }
              }
            }

            // router hsrp / interface * / address-family ipv4 / hsrp * version 2
            container hsrp-version2-list {
              tailf:cli-drop-node-name;
              list hsrp {
                tailf:cli-mode-name "config-hsrp-gp";
                key "id version";
                leaf id {
                  type uint16 {
                    tailf:info "<0-4095>;;group number (version 1 0-255, version 2 0-4095)";
                    range "0..4095";
                  }
                }
                leaf version {
                  tailf:info "HSRP version";
                  tailf:cli-expose-key-name;
                  type uint8 {
                    tailf:info "<2>;;HSRP version number";
                    range "2";
                  }
                }
                uses router-hsrp-ipv4-group-grouping;
              }
            }
          }

          // router hsrp / interface * / address-family ipv6
          container ipv6 {
            tailf:info "IPv6 address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-hsrp-ipv6";

            // router hsrp / interface * / address-family ipv6 / hsrp
            container hsrp {
              tailf:info "HSRP group configuration";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-hsrp-gp";
              uses router-hsrp-ipv6-group-grouping;
            }

            // router hsrp / interface * / address-family ipv6 / hsrp *
            container hsrp-version1-list {
              tailf:cli-drop-node-name;
              list hsrp {
                tailf:cli-mode-name "config-hsrp-gp";
                key id;
                leaf id {
                  type uint16 {
                    tailf:info "<0-4095>;;group number (version 1 0-255, version 2 0-4095)";
                    range "0..4095";
                  }
                }
                uses router-hsrp-ipv6-group-grouping;
              }
            }

            // router hsrp / interface * / address-family ipv6 / hsrp version 2
            container hsrp-version2 {
              tailf:cli-drop-node-name;
              container hsrp {
                tailf:info "HSRP group configuration";
                list version {
                  tailf:info "HSRP version";
                  tailf:cli-mode-name "config-hsrp-gp";
                  key version;
                  leaf version {
                    type enumeration {
                      enum "2" {}
                    }
                  }
                  uses router-hsrp-ipv6-group-grouping;
                }
              }
            }

            // router hsrp / interface * / address-family ipv6 / hsrp * version 2
            container hsrp-version2-list {
              tailf:cli-drop-node-name;
              list hsrp {
                tailf:cli-mode-name "config-hsrp-gp";
                key "id version";
                leaf id {
                  type uint16 {
                    tailf:info "<0-4095>;;group number (version 1 0-255, version 2 0-4095)";
                    range "0..4095";
                  }
                }
                leaf version {
                  tailf:info "HSRP version";
                  tailf:cli-expose-key-name;
                  type uint8 {
                    tailf:info "<2>;;HSRP version number";
                    range "2";
                  }
                }
                uses router-hsrp-ipv6-group-grouping;
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// service-policy
  /// ========================================================================

  container service-policy {
    tailf:info "Configure global service policy";

    // service-policy apply-order
    leaf-list apply-order {
      tailf:info "Configure service policy ordering";
      tailf:cli-flat-list-syntax;
      tailf:cli-replace-all;
      ordered-by user;
      type enumeration {
        enum pbr {
          tailf:info "Policy based routing";
        }
        enum qos {
          tailf:info "Quality of service";
        }
      }
    }
  }


  /// ========================================================================
  /// service-function-chaining
  /// ========================================================================

  container service-function-chaining {
    tailf:info "configure service function chaining";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-service-function-chain";
    tailf:cli-explicit-exit;

    // service-function-chaining / sf *
    list sf {
      tailf:info "service function";
      tailf:cli-mode-name "config-service-function-chain-sf";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;service function name";
        }
      }

      // service-function-chaining / sf * / locator *
      list locator {
        tailf:info "Specify service function locator id";
        tailf:cli-mode-name "config-service-function-chain-sfl";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Specify locator id";
            range "1..255";
          }
        }

        // service-function-chaining / sf * / locator * transport vxlan-gpe
        container transport {
          tailf:info "Choose SFL transport";
          container vxlan-gpe {
            tailf:info "transport vxlan-gpe";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-service-function-chain-vxl";
            tailf:cli-compact-syntax;
            // service-function-chaining / sf * / locator * transport vxlan-gpe /
            // .. source-address ipv4 ? destination-address ipv4 ? source-port ? vni ?
            container source-address {
              tailf:info "Local IP address";
              tailf:cli-flatten-container;
              leaf ipv4 {
                tailf:info "setup IPv4  path";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Local IP address";
                }
              }
            }
            container destination-address {
              tailf:info "Remote IP address";
              tailf:cli-flatten-container;
              leaf ipv4 {
                tailf:info "setup IPv4  path";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Remote IP address";
                }
              }
            }
            leaf source-port {
              tailf:info "Local port";
              type uint16 {
                tailf:info "<1-65535>;;Enter local port";
                range "1..65535";
              }
            }
            leaf vni {
              tailf:info "vni value";
              type uint16 {
                tailf:info "<1-65535>;;Enter vni value";
                range "1..65535";
              }
            }
          }
        }
      }
    }

    // service-function-chaining / sff *
    list sff {
      tailf:info "service function forwarder";
      tailf:cli-mode-name "config-service-function-chain-sf";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;service function name";
        }
      }

      // service-function-chaining / sff * / locator *
      list locator {
        tailf:info "Specify service function locator id";
        tailf:cli-mode-name "config-service-function-chain-sfl";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Specify locator id";
            range "1..255";
          }
        }

        // service-function-chaining / sff * / locator * transport vxlan-gpe
        container transport {
          tailf:info "Choose SFL transport";
          container vxlan-gpe {
            tailf:info "transport vxlan-gpe";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-service-function-chain-vxl";
            tailf:cli-compact-syntax;
            // service-function-chaining / sff * / locator * transport vxlan-gpe /
            // .. source-address ipv4 ? destination-address ipv4 ? source-port ? vni ?
            container source-address {
              tailf:info "Local IP address";
              tailf:cli-flatten-container;
              leaf ipv4 {
                tailf:info "setup IPv4  path";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Local IP address";
                }
              }
            }
            container destination-address {
              tailf:info "Remote IP address";
              tailf:cli-flatten-container;
              leaf ipv4 {
                tailf:info "setup IPv4  path";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Remote IP address";
                }
              }
            }
            leaf source-port {
              tailf:info "Local port";
              type uint16 {
                tailf:info "<1-65535>;;Enter local port";
                range "1..65535";
              }
            }
            leaf vni {
              tailf:info "vni value";
              type uint16 {
                tailf:info "<1-65535>;;Enter vni value";
                range "1..65535";
              }
            }
          }
        }
      }
    }

    // service-function-chaining / metadata *
    list metadata {
      tailf:info "metadata imposition";
      tailf:cli-mode-name "config-sfc-metadata";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;metadata profile name";
        }
      }

      // service-function-chaining / metadata * / type * format dc-allocation
      list "type" {
        tailf:info "Specify metadata type";
        tailf:cli-mode-name "config-sfc-metadata-type";
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type enumeration {
            enum "1" {
              tailf:info "Type 1 metadata";
            }
          }
        }
        leaf format {
          tailf:info "Specify metadata format";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum dc-allocation {
              tailf:info "format dc-allocation";
            }
          }
        }

        // service-function-chaining / metadata * / type * format dc-allocation / tenant-id
        leaf tenant-id {
          tailf:info "Specify tenant id";
          type uint32 {
            tailf:info "<1-16777215>;;Enter 24-bit tenant id";
            range "1..16777215";
          }
        }
      }
    }

    // service-function-chaining / path *
    list "path" {
      tailf:info "Configure service function path";
      tailf:cli-mode-name "config-service-function-chain-path";
      key id;
      leaf id {
        type uint32 {
          tailf:info "<1-16777215>;;Specify the service function path id";
          range "1..16777215";
        }
      }

      // service-function-chaining / path * / * terminate metadata-disposition ? default-action redirect ipv4 nexthop vrf|?
      list terminate-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Specify the id of service function";
            range "1..255";
          }
        }
        leaf terminate {
          tailf:info "Configure terminate";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf metadata-disposition {
          tailf:info "Specify metadata-disposition name";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;,metadata-disposition name";
          }
        }
        container default-action {
          tailf:info "Configure the default action for service function path";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          container redirect {
            tailf:info "Configure redirect action";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            container ipv4 {
              tailf:info "Enter ipv4 configuration";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              container nexthop {
                tailf:info "Configure the nexthop action";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                choice nexthop-choice {
                  leaf address {
                    tailf:cli-drop-node-name;
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;IPv4 nexthop address";
                    }
                  }
                  leaf vrf {
                    tailf:info "Enter vrf name for the nexthop";
                    type string {
                      tailf:info "WORD;;Enter VRF name";
                    }
                  }
                }
              }
            }
          }
        }
      }

      // service-function-chaining / path * / * sf *
      list sf-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "id sf";
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Specify the id of service function";
            range "1..255";
          }
        }
        leaf sf {
          tailf:info "service function";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;service function name";
          }
        }
      }

      // service-function-chaining / path * / * sff *
      list sff-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "id sff";
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Specify the id of service function";
            range "1..255";
          }
        }
        leaf sff {
          tailf:info "service function forwarder";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;service function name";
          }
        }
      }
    }

    // service-function-chaining / metadata-disposition *
    list metadata-disposition {
      tailf:info "metadata disposition";
      tailf:cli-mode-name "config-sfc-disposition";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;specify service disposition name";
        }
      }

      // service-function-chaining / metadata-disposition * / type * format dc-allocation
      list "type" {
        tailf:info "Specify disposition allocation type";
        tailf:cli-mode-name "config-sfc-metadata-type";
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type enumeration {
            enum "1" {
              tailf:info "Allocation format Type 1";
            }
          }
        }
        leaf format {
          tailf:info "Specify allocation format";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum dc-allocation {
              tailf:info "data center allocation";
            }
          }
        }

        // service-function-chaining / metadata * / type * format dc-allocation / match-entry *
        list match-entry {
          tailf:info "Specify the match entry name";
          tailf:cli-mode-name "config-sfc-disposition-match";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;match-entry name";
            }
          }

          // service-function-chaining / metadata * / type * format dc-allocation / match-entry * / tenant-id
          container tenant-id {
            tailf:info "Specify the tenant-ids";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-sfc-disposition-action";
            tailf:cli-incomplete-command;
            leaf id {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              type uint32 {
                tailf:info "<0-4294967295>;;tenant id";
              }
            }

            // service-function-chaining / metadata * / type * format dc-allocation / match-entry * / tenant-id ? /
            container redirect {
              tailf:info "Configure redirect action";
              container ipv4 {
                tailf:info "Enter ipv4 configuration";
                container nexthop {
                  tailf:info "Configure the nexthop action";
                  choice nexthop-choice {
                    leaf address {
                      tailf:cli-drop-node-name;
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;IPv4 nexthop address";
                      }
                    }
                    leaf vrf {
                      tailf:info "Enter vrf name for the nexthop";
                      type string {
                        tailf:info "WORD;;Enter VRF name";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// subscriber
  /// ========================================================================

  container subscriber {
    tailf:info "Subscriber Configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-subscriber";

    // subscriber / arp
    container arp {
      tailf:info "ARP Subscriber configuration option";

      // subscriber / arp scale-mode-enable
      leaf scale-mode-enable {
        tailf:info "Supressing ARP entry creation on subscribers interfaces";
        type empty;
      }
    }

    // subscriber / redundancy
    container redundancy {
      tailf:info "Subscriber Redundancy configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-subscr-red";

      // subscriber / redundancy / source-interface
      container source-interface {
        tailf:info "Source Interface for Redundancy Peer Communication";
        uses interface-name-grouping;
      }

      // subscriber / redundancy / group *
      list group {
        tailf:info "Redundancy Group configuration";
        tailf:cli-mode-name "config-subscr-red-group";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-500>;;Group ID";
            range "1..500";
          }
        }

        // subscriber / redundancy / group * / description
        uses description-grouping;

        // subscriber / redundancy / group * / preferred-role
        leaf preferred-role {
          tailf:info "Preferred Role for this Group";
          tailf:cli-full-command;
          type enumeration {
            enum master {
              tailf:info "Master Role";
            }
            enum slave {
              tailf:info "Slave Role";
            }
          }
        }

        // subscriber / redundancy / group * / virtual-mac
        leaf virtual-mac {
          tailf:info "Virtual MAC Address for this Group";
          tailf:cli-full-command;
          type string {
            tailf:info "H.H.H;;MAC address";
          }
        }

        // subscriber / redundancy / group * / slave-mode
        leaf slave-mode {
          tailf:info "Slave Mode for this Group";
          tailf:cli-full-command;
          type enumeration {
            enum hot {
              tailf:info "Hot Standby (Default)";
            }
            enum warm {
              tailf:info "Warm Standby";
            }
          }
        }

        // subscriber / redundancy / group * / peer
        container peer {
          tailf:info "Peer config for this Group";

          // subscriber / redundancy / group * / peer ?
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address";
              }
              type inet:ipv6-address {
                tailf:info "X:X::X;;IPv6 address";
              }
            }
          }

          // subscriber / redundancy / group * / peer route-disable
          leaf route-disable {
            tailf:info "Disable route addition on SRG Slave";
            type empty;
          }
        }

        // subscriber / redundancy / group * / core-tracking
        leaf core-tracking {
          tailf:info "Core Tracking Object for this Group";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Tracking Object Name";
          }
        }

        // subscriber / redundancy / group * / access-tracking BE102
        leaf access-tracking {
          tailf:info "Access Tracking Object for this Group";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Tracking Object Name";
          }
        }

        // subscriber / redundancy / group * / state-control-route
        container state-control-route {
          tailf:info "state control route config for this Group";

          // subscriber / redundancy / group * / state-control-route ipv4 10.253.0.0/16 tag 10
          container ipv4 {
            tailf:info "IPv4 route";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf "prefix" {
              tailf:cli-drop-node-name;
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;IPv4 Prefix";
              }
            }
            leaf tag {
              tailf:info "Set a tag value for the route";
              type uint32 {
                tailf:info "<1-4294967295>;;Tag value";
                range "1..4294967295";
              }
            }
          }

          // subscriber / redundancy / group * / state-control-route ipv6
          container ipv6 {
            tailf:info "IPv6 route";

            // subscriber / redundancy / group * / state-control-route ipv6 iapd
            container iapd {
              tailf:info "IAPD route";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf "prefix" {
                tailf:cli-drop-node-name;
                type tailf:ipv6-address-and-prefix-length {
                  tailf:info "X:X::X/length;;IPv6 address with prefix-length";
                }
              }
              leaf tag {
                tailf:info "Set a tag value for the route";
                type uint32 {
                  tailf:info "<1-4294967295>;;Tag value";
                  range "1..4294967295";
                }
              }
            }
          }
        }

        // subscriber / redundancy / group * / interface-list
        container interface-list {
          tailf:info "List of Interfaces for this Group";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-subscr-red-grp-intf";

          // subscriber / redundancy / group * / interface-list / interface *
          list interface {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type ifname;
            }
            leaf id {
              tailf:info "Map Identifier";
              type uint16 {
                tailf:info "<1-65535>;;ID for the interface to be mapped on to slave";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// flowspec
  /// ========================================================================

  container flowspec {
    tailf:info "FlowSpec configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-flowspec";

    // flowspec / local-install interface-all
    container local-install {
      tailf:info "Local installation of flowspec policy";
      leaf interface-all {
        tailf:info "Install flowspec policy on all interfaces";
        type empty;
      }
    }

    container address-family {
      tailf:info "Address Family Identifier Type (IPv4/IPv6)";

      // flowspec / address-family ipv4
      container ipv4 {
        tailf:info "IPv4 flow";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-flowspec-af";

        // flowspec / addres-family ipv4 / local-install interface-all
        container local-install {
          tailf:info "Local installation of flowspec policy";
          leaf interface-all {
            tailf:info "Install flowspec policy on all interfaces";
            type empty;
          }
        }

        // flowspec / address-family ipv4 / service-policy *
        list service-policy {
          tailf:info "Service Policy configuration";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-full-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Policy map name";
            }
          }
          leaf "type" {
            tailf:info "Type of the service policy";
            tailf:cli-prefix-key;
            type enumeration {
              enum pbr {
                tailf:info "PBR policy type";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// rsvp
  /// ========================================================================

  container rsvp {
    tailf:info "Global RSVP configuration commands";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;

    // rsvp / interface *
    list interface {
      tailf:info "Enable RSVP on an interface";
      tailf:cli-mode-name "config-rsvp-if";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // rsvp / interface * / bandwidth
      container bandwidth {
        tailf:info "Configure RSVP bandwidth parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-delete-when-empty;
        presence true;
        choice bandwidth-choice {
          // rsvp / interface * / bandwidth percentage
          case percentage-case {
            leaf percentage {
              tailf:info "Supply bandwidths as percentages of physical link bandwidth";
              type empty;
            }
            leaf total-reservable-percent {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-10000>;;Total reservable bandwidth as percentage of physical link bandwidth";
                range "0..10000";
              }
            }
          }

          case rsvp-case {
            leaf total-reservable {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-4294967295>;;Total reservable bandwidth "+
                  "(in Kbps, Mbps or Gbps)";
              }
            }
            leaf total-reservable-unit {
              when "../total-reservable" {
                tailf:dependency "../total-reservable";
              }
              tailf:cli-drop-node-name;
              type enumeration {
                enum Gbps {
                  tailf:info "BW in Gbps";
                }
                enum Kbps {
                  tailf:info "BW in Kbps (Default)";
                }
                enum Mbps {
                  tailf:info "BW in Mbps";
                }
              }
            }
          }

          // rsvp / interface * / bandwidth rdm
          case rdm-case {
            container rdm {
              tailf:info "Russian Doll Model";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf bc0 {
                tailf:info "BC0 pool";
                type uint32 {
                  tailf:info "<0-4294967295>;;Total reservable bandwidth";
                }
              }
              leaf largest-reservable-flow {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<0-4294967295>;;Largest reservable flow";
                }
              }
              leaf bc1 {
                tailf:info "BC1 pool";
                type uint32 {
                  tailf:info "<0-4294967295>;;Reservable bandwidth in sub-pool";
                }
              }
            }
          }
        }
      }

      // rsvp / interface * / signalling dscp
      container signalling {
        tailf:info "Configure RSVP signalling parameters";
        leaf dscp {
          tailf:info "Set DSCP for RSVP signalling messages";
          type uint8 {
            tailf:info "<0-63>;;Differentiated Services Code Point (DSCP)";
            range "0..63";
          }
        }
      }
    }

    // rsvp / signalling
    container signalling {
      tailf:info "Configure global RSVP signalling parameters";

      // rsvp / signalling graceful-restart
      container graceful-restart {
        tailf:info "Configure RSVP Graceful-Restart parameters";
        presence true;
      }

      // rsvp / signalling message-bundle disable
      container message-bundle {
        tailf:info "Sending bundled messages(cisco-support)";
        leaf disable {
          tailf:info "Disable bundling of outgoing RSVP messages";
          type empty;
        }
      }
    }

    // rsvp / authentication
    container authentication {
      tailf:info "Configure RSVP authentication parameters";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-rsvp-auth";
      container key-source {
        tailf:info "Specify key-source for authenticating RSVP "+
          "signalling messages";
        leaf key-chain {
          tailf:info "Use key-chain to authenticate RSVP signalling messages";
          type string {
            tailf:info "WORD;;Name of key-chain";
          }
        }
      }
    }

  }


  /// ========================================================================
  /// lmp
  /// ========================================================================

  container lmp {
    tailf:info "Configure OLM/LMP application settings";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-lmp";
    tailf:cli-explicit-exit;
    presence true;

    // lmp / gmpls optical-uni
    container gmpls {
      tailf:info "Configure LMP GMPLS application settings";
      container optical-uni {
        tailf:info "Configure GMPLS Optical UNI application settings";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-lmp-gmpls-uni";

        // lmp / gmpls optical-uni / controller *
        list controller {
          tailf:info "Enable LMP GMPLS UNI on a controller";
          tailf:cli-mode-name "config-lmp-gmpls-uni-cntl";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface/controller name";
            }
          }

          // lmp / gmpls optical-uni / controller * / neighbor
          container neighbor {
            tailf:info "Neighbor LMP GMPLS UNI configuration commands";

            // lmp / gmpls optical-uni / controller * / neighbor ?
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              tailf:cli-disallow-value "interface-id|link-id";
              type string {
                tailf:info "WORD;;LMP Neighbor name";
              }
            }

            // lmp / gmpls optical-uni / controller * / neighbor link-id
            container link-id {
              tailf:info "LMP Neighbor link identifier address";
              container ipv4 {
                tailf:info "Neighbor Link identifier address (IPv4 Address)";
                leaf unicast {
                  tailf:info "Unicast address";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Neighbor Link identifier address (IPv4 Address)";
                  }
                }
              }
            }

            // lmp / gmpls optical-uni / controller * / neighbor interface-id
            container interface-id {
              tailf:info "LMP Neighbor interface identifier";
              leaf unnumbered {
                tailf:info "Neighbor link unnumbered interface identifier";
                type uint32 {
                  tailf:info "<1-4294967295>;;Neighbor unnumbered interface identifier";
                  range "1..4294967295";
                }
              }
            }
          }

          // lmp / gmpls optical-uni / controller * / link-id
          container link-id {
            tailf:info "Local LMP GMPLS UNI link identifier address";
            container ipv4 {
              tailf:info "Local link identifier address (IPv4 Address)";
              leaf unicast {
                tailf:info "Unicast address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Local Link identifier address (IPv4 Address)";
                }
              }
            }
          }
        }

        // lmp / gmpls optical-uni / neighbor *
        list neighbor {
          tailf:info "The GMPLS UNI LMP neighbor configuration submode";
          tailf:cli-mode-name "config-lmp-gmpls-uni-nbr";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface/controller name";
            }
          }

          // lmp / gmpls optical-uni / neighbor * / ipcc routed
          container ipcc {
            tailf:info "IPCC manipulation commands";
            leaf routed {
              tailf:info "Create a routed IPCC";
              type empty;
            }
          }

          // lmp / gmpls optical-uni / neighbor * / router-id
          container router-id {
            tailf:info "GMPLS UNI LMP neighbor router ID";
            container ipv4 {
              tailf:info "IPv4 address";
              leaf unicast {
                tailf:info "Unicast address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Remote LMP neighbor router ID (IPv4 Address)";
                }
              }
            }
          }
        }

        // lmp / gmpls optical-uni / router-id ipv4 unicast
        container router-id {
          tailf:info "GMPLS UNI LMP local node ID";
          container ipv4 {
            tailf:info "IPv4 address";
            leaf unicast {
              tailf:info "Unicast address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;GMPLS UNI LMP router id address";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// mpls
  /// ========================================================================

  container mpls {
    tailf:info "Configure MPLS parameters";
    tailf:cli-explicit-exit;
    //tailf:cli-diff-dependency "/cisco-ios-xr:ipv4/access-list";

    // mpls label
    container label {
      tailf:info "Label properties";

      // mpls label protocol
      leaf protocol {
        tailf:info "Set platform default label distribution protocol";
        type enumeration {
          enum ldp {
            tailf:info "Use LDP (default)";
          }
          enum tdp {
            tailf:info "Use TDP";
          }
        }
      }

      // mpls label range
      container "range" {
        tailf:info "Label range";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf table {
          tailf:info "Specify label table";
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<0-0>;;Label table index";
            range "0";
          }
          default 0;
        }
        leaf min {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16000-1048575>;;Minimum label value";
            range "16000..1048575";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16000-1048575>;;Maximum label value";
            range "16000..1048575";
          }
        }
      }
    }

    // mpls traffic-eng
    container traffic-eng {
      tailf:info "Go into the MPLS-TE submode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mpls-te";

      // mpls traffic-eng / auto-tunnel
      container auto-tunnel {
        tailf:info "Automatically created tunnel configuration";

        // mpls traffic-eng / auto-tunnel p2p
        container p2p {
          tailf:info "Enter the auto-tunnel p2p configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-te-auto-p2p";

          // mpls traffic-eng / auto-tunnel p2p / tunnel-id
          container tunnel-id {
            tailf:info "Specify Tunnel ID range "+
              "(modify may result auto-tunnel delete)";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf min {
              tailf:info "Minimum tunnel ID for auto-tunnel p2p";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<0-65535>;;Minimum value of tunnel ID for auto-tunnel p2p";
              }
            }
            leaf max {
              tailf:info "Maximum tunnel ID for auto-tunnel p2p";
              type uint16 {
                tailf:info "<0-65535>;;Maximum value of tunnel ID for auto-tunnel p2p";
              }
            }
          }
        }

        // mpls traffic-eng / auto-tunnel pcc
        container pcc {
          tailf:info "Enter the auto-tunnel stateful PCE client configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-te-auto-pcc";

          // mpls traffic-eng / auto-tunnel pcc / tunnel-id
          container tunnel-id {
            tailf:info "Specify Tunnel ID range "+
              "(modify may result auto-tunnel delete)";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf min {
              tailf:info "Minimum tunnel ID for stateful PCE client "+
                "auto-tunnels";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<0-65535>;;Minimum tunnel ID value for stateful "+
                  "PCE client auto-tunnels";
              }
            }
            leaf max {
              tailf:info "Maximum tunnel ID for stateful PCE client "+
                "auto-tunnels";
              type uint16 {
                tailf:info "<0-65535>;;Maximum tunnel ID value for "+
                  "stateful PCE client auto-tunnels";
              }
            }
          }
        }

        // mpls traffic-eng / auto-tunnel backup
        container backup {
          tailf:info "Enter the auto-tunnel backup configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-mpls-te-auto-bk";

          // mpls traffic-eng / auto-tunnel backup / timers
          container timers {
            tailf:info "Auto-tunnel backups related timers";
            container removal {
              tailf:info "Auto-tunnel backups removal timers";
              leaf unused {
                tailf:info "Auto-tunnel backups unused removal timer";
                type uint16 {
                  tailf:info "<0-10080>;;Auto-tunnel backup unused timeout "+
                    "in minutes (0=never timeout)";
                  range "0..10080";
                }
              }
            }
          }

          // mpls traffic-eng / auto-tunnel backup / tunnel-id
          container tunnel-id {
            tailf:info "Specify Tunnel ID range (modify may result "+
              "auto-tunnel delete)";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf min {
              tailf:info "Minimum tunnel ID for auto-tunnel backups";
              type uint16 {
                tailf:info "<0-65535>;;Minimum value of tunnel ID for "+
                  "auto-tunnel backups";
              }
            }
            leaf max {
              tailf:info "Maximum tunnel ID for auto-tunnel backups";
              type uint16 {
                tailf:info "<0-65535>;;Maximum value of tunnel ID for "+
                  "auto-tunnel backups";
              }
            }
          }
        }

        // mpls traffic-eng / auto-tunnel mesh
        container mesh {
          tailf:info "Enter the auto-tunnel mesh configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-te-auto-mesh";

          // mpls traffic-eng / auto-tunnel mesh / group *
          list group {
            tailf:info "Enter the auto-tunnel mesh group configuration submode";
            tailf:cli-mode-name "config-te-mesh-group";
            key id;
            leaf id {
              type uint32 {
                tailf:info "<0-4294967295>;;Auto-tunnel mesh group ID";
              }
            }

            // mpls traffic-eng / auto-tunnel mesh / group * / onehop
            leaf onehop {
              tailf:info "Automatically create tunnel to all next-hops";
              type empty;
            }

            // mpls traffic-eng / auto-tunnel mesh / group * / attribute-set
            leaf attribute-set {
              tailf:info "Attribute-set name of type auto-mesh";
              type string {
                tailf:info "WORD;;Specify attribute-set name (max 64 char)";
              }
            }

            // mpls traffic-eng / auto-tunnel mesh / group * / destination-list
            leaf destination-list {
              tailf:info "Destination-list (prefix-list) name";
              type string {
                tailf:info "WORD;;Specify destination-list (prefix-list) "+
                  "(max 32 char)";
              }
            }
          }

          // mpls traffic-eng / auto-tunnel mesh / tunnel-id
          container tunnel-id {
            tailf:info "Specify Tunnel ID range "+
              "(modify may result auto-tunnel delete)";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf min {
              tailf:info "Minimum tunnel ID for auto-tunnel mesh";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<0-65535>;;Minimum value of tunnel ID for "+
                  "auto-tunnel mesh";
              }
            }
            leaf max {
              tailf:info "Maximum tunnel ID for auto-tunnel mesh";
              type uint16 {
                tailf:info "<0-65535>;;Maximum value of tunnel ID for "+
                  "auto-tunnel mesh";
              }
            }
          }
        }
      }

      // mpls traffic-eng / interface *
      list interface {
        tailf:info "Enable MPLS-TE on an interface";
        tailf:cli-mode-name "config-mpls-te-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // mpls traffic-eng / interface * / bfd fast-detect
        container bfd {
          tailf:info "Configure BFD parameters";
          leaf fast-detect {
            tailf:info "Enable Fast detection";
            type empty;
          }
        }

        // mpls traffic-eng / interface * / auto-tunnel backup
        container auto-tunnel {
          tailf:info "Auto-tunnel configuration";
          container backup {
            tailf:info "Enable the auto-tunnel backup feature on an interface";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-mpls-te-if-auto-backup";
            presence true;

            // mpls traffic-eng / interface * / auto-tunnel backup / exclude
            container exclude {
              tailf:info "Restrict auto-tunnel backup path based on "+
                "specific criteria.";
              container srlg {
                tailf:info "Backup requires SRLG exclusion from protected "+
                  "interface";
                tailf:cli-delete-when-empty;
                tailf:cli-reset-container;
                presence true;
                leaf preferred {
                  tailf:info "SRLG exclusion is preferred but not mandatory";
                  type empty;
                }
              }
            }
          }
        }

        // mpls traffic-eng / interface * / attribute-flags
        leaf attribute-flags {
          tailf:info "Set user defined interface attribute flags";
          type string {
            tailf:info "<0x0-0xffffffff>;;User defined interface attribute flags";
          }
        }

        // mpls traffic-eng / interface * / attribute-names
        container attribute-names {
          tailf:info "Specify one or more attribute names";
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "index";
            type string {
              tailf:info "WORD;;User defined attribute name";
            }
          }
          // mpls traffic-eng / interface * / attribute-names index *
          list index {
            tailf:info "Specify the entry index";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<1-8>;;Index number";
                range "1..8";
              }
            }
            leaf name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;User defined attribute name";
              }
            }
          }
        }

        // mpls traffic-eng / interface * / admin-weight
        leaf admin-weight {
          tailf:info "Set administrative weight for the interface";
          type uint32 {
            tailf:info "<0-4294967295>;;Administrative weight for the interface";
          }
        }

        // mpls traffic-eng / interface * / backup-path
        container "backup-path" {
          tailf:info "Configure an MPLS TE backup for this interface";
          leaf tunnel-te {
            tailf:info "Tunnel interface number";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-65535>;;Tunnel interface number";
              range "0..65535";
            }
          }
        }
      }

      // mpls traffic-eng / pce
      container pce {
        tailf:info "MPLS Traffic Engineering PCE functionality";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mpls-te-pce";

        // mpls traffic-eng / pce / peer
        container peer {
          tailf:info "PCE peer related configuration";

          // mpls traffic-eng / pce / peer source ipv4
          container source {
            tailf:info "Peer source";
            leaf ipv4 {
              tailf:info "IPv4 address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address of the source";
              }
            }
          }

          // mpls traffic-eng / pce / peer ipv4 *
          list ipv4 {
            tailf:info "IPv4 address";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key address;
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address of the peer";
              }
            }
          }
        }

        // mpls traffic-eng / pce / segment-routing
        leaf segment-routing {
          tailf:info "Enable segment-routing capability";
          type empty;
        }

        // mpls traffic-eng / pce / stateful-client
        container stateful-client {
          tailf:info "Enter the stateful PCE client configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-mpls-te-pce-stateful";

          // mpls traffic-eng / pce / stateful-client / instantiation
          leaf instantiation {
            tailf:info "Enable stateful instantiate capability";
            type empty;
          }

          // mpls traffic-eng / pce / stateful-client / cisco-extension
          leaf cisco-extension {
            tailf:info "Enable processing of PCEP Cisco extension";
            type empty;
          }
        }
      }

      // mpls traffic-eng / logging events
      container logging {
        tailf:info "MPLS Traffic-Eng. logging configuration";
        container events {
          tailf:info "Global logging events";

          // mpls traffic-eng / logging events all
          leaf all {
            tailf:info "Enable all logging for all events";
            tailf:cli-full-command;
            type empty;
          }

          // mpls traffic-eng / logging events frr-protection
          leaf frr-protection {
            tailf:info "Enable protection change Syslog";
            tailf:cli-full-command;
            type empty;
          }

          // mpls traffic-eng / logging events preemption
          leaf preemption {
            tailf:info "Enable Tunnel Preemption alarms";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // mpls traffic-eng / affinity-map *
      list affinity-map {
        tailf:info "Affinity Map Configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Affinity attribute name";
          }
        }

        // mpls traffic-eng / affinity-map * <value>
        leaf "value" {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type string {
            tailf:info "<0x1-0x80000000>;;Affinity attribute value";
          }
        }

        // mpls traffic-eng / affinity-map * bit-position
        leaf bit-position {
          tailf:info "Bit Position for Affinity attribute value";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-255>;;Bit Position";
          }
        }
      }

      // mpls traffic-eng / attribute-set path-option *
      // mpls traffic-eng / attribute-set auto-backup *
      // mpls traffic-eng / attribute-set auto-mesh *
      // mpls traffic-eng / attribute-set p2mp-te *
      // mpls traffic-eng / attribute-set p2p-te
      // mpls traffic-eng / attribute-set path-protection-aps
      // mpls traffic-eng / attribute-set xro
      list attribute-set {
        tailf:info "Specify attribute set";
        tailf:cli-mode-name "config-te-attribute-set";
        key "type pathname";
        leaf "type" {
          type enumeration {
            enum path-option {
              tailf:info "Attribute-set of a path option";
            }
            enum auto-backup {
              tailf:info "Attribute-set of auto-backup type";
            }
            enum auto-mesh {
              tailf:info "Attribute-set of auto mesh type";
            }
            enum p2mp-te {
              tailf:info "Attribute-set of p2mp-te type";
            }
            enum path-protection-aps {
              tailf:info "Attribute-set of path protection";
            }
            enum xro {
              tailf:info "An XRO attribute-set";
            }
            enum p2p-te {
              tailf:info "Attribute-set of p2p-te type";
            }
          }
        }
        leaf pathname {
          type string {
            tailf:info "WORD;;Specify attribute-set name";
          }
        }

        // mpls traffic-eng / attribute-set * affinity
        container affinity {
          tailf:info "Link attributes for links traversed by tunnel";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf "value" {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "<0x0-0xffffffff>;;Affinity value";
            }
          }
          leaf mask {
            type string {
              tailf:info "<0x0-0xffffffff>;;Affinity mask value";
            }
          }
        }

        // mpls traffic-eng / attribute-set * logging events lsp-status
        container logging {
          tailf:info "Per-interface logging configuration";
          container events {
            tailf:info "Per-interface logging events";
            uses logging-events-lsp-status-grouping;
          }
        }

        // mpls traffic-eng / attribute-set * bandwidth
        leaf bandwidth {
          tailf:info "Set the bandwidth of an interface";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-4294967295>;;bandwidth in kbps";
          }
        }

        // mpls traffic-eng / attribute-set * / priority
        container priority {
          tailf:info "Tunnel priority";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf setup {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;Setup Priority";
              range "0..7";
            }
          }
          leaf hold {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-7>;;Hold Priority";
              range "0..7";
            }
          }
        }

        // mpls traffic-eng / attribute-set * / signalled-bandwidth
        container signalled-bandwidth {
          tailf:info "Tunnel bandwidth requirement to be signalled";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf bw-req {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-4294967295>;;Bandwidth requirement in kbps";
              range "0..4294967295";
            }
          }
          leaf class-type {
            tailf:info "Specify the bandwidth class type";
            type uint8 {
              tailf:info "<0-1>;;Class type number";
              range "0..1";
            }
          }
        }

        // mpls traffic-eng / attribute-set * / autoroute announce
        container autoroute {
          tailf:info "Parameters for IGP routing over tunnel";
          leaf announce {
            tailf:info "Announce tunnel to IGP";
            type empty;
          }
        }

        // mpls traffic-eng / attribute-set * / fast-reroute
        container fast-reroute {
          tailf:info "Specify MPLS tunnel can be fast-rerouted";
          tailf:cli-delete-when-empty;
          presence true;
          leaf-list protect {
            tailf:info "Enable protection request";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type enumeration {
              enum node {
                tailf:info "Enable node protection request";
              }
              enum bandwidth {
                tailf:info "Enable bandwidth protection request";
              }
            }
          }
        }

        // mpls traffic-eng / attribute-set * / policy-class
        container policy-class {
          tailf:info "Specify class for policy-based tunnel selection";
          tailf:cli-delete-when-empty;
          presence true;
          leaf "value" {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-7>;;Tunnel policy class";
              range "1..7";
            }
          }
        }

        // mpls traffic-eng / attribute-set * / record-route
        leaf record-route {
          tailf:info "Record the route used by the tunnel";
          tailf:cli-full-command;
          type empty;
        }

        // mpls traffic-eng / attribute-set * / forward-class
        leaf forward-class {
          tailf:info "Specify tunnel forward class for policy based routing";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-7>;;Forward class for the tunnel (default value 0)";
            range "1..7";
          }
        }

        // mpls traffic-eng / attribute-set * exclude *
        list exclude {
          tailf:info "Specify exclusions for path diversity";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key "source destination tunnel-id extended-tunnel-id";
          leaf mode {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type enumeration {
              enum best-effort {
                tailf:info "Specified condition should be met if possible";
              }
              enum strict {
                tailf:info "Specified condition must be met";
              }
            }
          }
          leaf lsp {
            tailf:info "Specify path-diversity from another LSP";
            tailf:cli-prefix-key;
            type empty;
          }
          leaf source {
            tailf:info "The source of the LSP from which a diverse path is required";
            tailf:cli-expose-key-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;The LSP's source address";
            }
          }
          leaf destination {
            tailf:info "The destination of the LSP from which a diverse path is required";
            tailf:cli-expose-key-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;The LSP's destination address";
            }
          }
          leaf tunnel-id {
            tailf:info "The tunnel-id of the LSP from which a diverse path is required";
            tailf:cli-expose-key-name;
            type uint16 {
              tailf:info "<0-65535>;;The LSP's tunnel-id";
            }
          }
          leaf extended-tunnel-id {
            tailf:info "The extended tunnel-id of the LSP from which a diverse path is required";
            tailf:cli-expose-key-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;The LSP's extended tunnel-id";
            }
          }
          leaf lsp-id {
            tailf:info "The lsp-id of the LSP from which a diverse path is required";
            type uint16 {
              tailf:info "<0-65535>;;The LSP's lsp-id (optional)";
            }
          }
        }

        // mpls traffic-eng / attribute-set * pce
        container pce {
          tailf:info "Specify PCE Configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-te-attrset-pce";
          presence true;

          // mpls traffic-eng / attribute-set * pce / disjoint-path
          container disjoint-path {
            tailf:info "Disjoint Path Configuration";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf source {
              tailf:info "Source address";
              tailf:cli-incomplete-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 Address";
              }
            }
            leaf "type" {
              tailf:info "Disjointness type";
              tailf:cli-incomplete-command;
              type enumeration {
                enum link {
                  tailf:info "Link Disjointness";
                }
                enum node {
                  tailf:info "Node Disjointness";
                }
                enum srlg {
                  tailf:info "SRLG Disjointness";
                }
              }
            }
            leaf group-id {
              tailf:info "Group ID";
              type uint32 {
                tailf:info "<1-4294967295>;;Enter group-id";
              }
            }
          }
        }

        // mpls traffic-eng / attribute-set * path-selection
        container path-selection {
          tailf:info "Specify path selection";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-te-attrset-path-select";
          presence true;

          // mpls traffic-eng / attribute-set * path-selection / metric
          leaf metric {
            tailf:info "Metric type for path calculation";
            type enumeration {
              enum igp {
                tailf:info "Use IGP metric";
              }
              enum te {
                tailf:info "Use TE metric";
              }
            }
          }
        }
      }

      // mpls traffic-eng / ds-te
      container ds-te {
        tailf:info "Diff-Serv Traffic-Engineering Parameters";

        // mpls traffic-eng / ds-te mode ietf
        container mode {
          tailf:info "Diff-Serv Traffic-Engineering Mode";
          leaf ietf {
            tailf:info "IETF Standard Mode";
            type empty;
          }
        }

        // mpls traffic-eng / ds-te te-classes
        container te-classes {
          tailf:info "enter the DS-TE te-class map configuration mode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-te-class";

          // mpls traffic-eng / ds-te te-classes / te-class *
          list te-class {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<0-7>;;DS-TE class number";
                range "0..7";
              }
            }

            // mpls traffic-eng / ds-te te-classes / te-class *
            choice te-class-choice {
              leaf unused {
                tailf:info "Mark the TE-class as unused";
                type empty;
              }
              case used {
                leaf class-type {
                  tailf:info "Class type";
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<0-1>;;Class type number";
                    range "0..1";
                  }
                }
                leaf priority {
                  tailf:info "Class priority";
                  type uint8 {
                    tailf:info "<0-7>;;Class-type priority";
                    range "0..7";
                  }
                }
              }
            }
          }
        }
      }

      // mpls traffic-eng / soft-preemption
      container soft-preemption {
        tailf:info "Enable soft-preemption";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-soft-preemption";
        leaf timeout {
          tailf:info "Specify a timeout for soft-preempted LSP";
          type uint32 {
            tailf:info "<1-300>;;Timeout for soft-preempted LSP in seconds:"+
              "default 60";
            range "1..300";
          }
        }
      }

      // mpls traffic-eng / auto-bw
      container auto-bw {
        tailf:info "Auto-bandwidth configuration";
        container collect {
          tailf:info "Auto-bandwidth collection parameters";
          leaf frequency {
            tailf:info "Auto-bandwidth collection frequency parameter";
            type uint16 {
              tailf:info "<1-10080>;;Auto-bandwidth collection frequency "+
                "in minutes";
              range "1..10080";
            }
          }
        }
      }

      // mpls traffic-eng / reoptimize
      container reoptimize {
        tailf:info "MPLS TE Reoptimize config";
        leaf "value" {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-604800>;;Reoptimize timers frequency (secs)";
            range "0..604800";
          }
        }

        // mpls traffic-eng / reoptimize timers delay
        container timers {
          tailf:info "Reoptimization timers";
          container delay {
            tailf:info "Delay reoptimization action";

            // mpls traffic-eng / reoptimize timers delay cleanup
            leaf cleanup {
              tailf:info "Delay cleanup of reoptimized LSP";
              type uint16 {
                tailf:info "<0-300>;;Seconds to delay cleanup of "+
                  "reoptimized LSP";
                range "0..300";
              }
            }

            // mpls traffic-eng / reoptimize timers delay installation
            leaf installation {
              tailf:info "Delay replacement of current LSP by reoptimized LSP";
              type uint16 {
                tailf:info "<0-3600>;;Seconds to delay replacement of "+
                  "tunnel LSP";
                range "0..3600";
              }
            }

            // mpls traffic-eng / reoptimize timers delay after-frr
            leaf after-frr {
              tailf:info "Delay LSP reoptimization in the event of FRR";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<0-120>;;Seconds to delay re-opt initiation of tunnel after an FRR event";
                range "0..120";
              }
            }

            // mpls traffic-eng / reoptimize timers delay path-protection
            leaf path-protection {
              tailf:info "Time between path protection switchover event and "+
                "tunnel re-optimization";
              type uint32 {
                tailf:info "<0-604800>;;Seconds between path protection "+
                  "switchover event and tunnel re-optimization. "+
                  "Set to 0 to disable";
                range "0..604800";
              }
            }
          }
        }
      }

      // mpls traffic-eng / bfd
      container bfd {
        tailf:info "Configure BFD parameters";

        // mpls traffic-eng / bfd lsp
        container lsp {
          tailf:info "Configure parameters for BFD over LSP";

          // mpls traffic-eng / bfd lsp head down-action
          container head {
            tailf:info "Head end configuration";
            container down-action {
              tailf:info "Action to take for FRR enabled tunnel when BFD session down";

              // mpls traffic-eng / bfd lsp head down-action resetup
              leaf resetup {
                tailf:info "Teardown and resetup when received BFD session down event";
                type empty;
              }

              // mpls traffic-eng / bfd lsp head down-action reoptimize timeout
              container reoptimize {
                tailf:info "Reoptimize when received BFD session down event (default)";
                leaf timeout {
                  tailf:info "Timeout and teardown if failed to reoptimize";
                  type uint32 {
                    tailf:info "<120-4294967295>;;Reoptmization timeout in seconds (default 300)";
                    range "120..4294967295";
                  }
                }
              }
            }
          }
        }

        // mpls traffic-eng / bfd multiplier
        leaf multiplier {
          tailf:info "Detect multiplier";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<2-10>;;Detect multiplier";
            range "2..10";
          }
        }

        // mpls traffic-eng / bfd minimum-interval
        leaf minimum-interval {
          tailf:info "Hello interval";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<3-200>;;hello interval in milli-seconds";
            range "3..200";
          }
        }
      }

      // mpls traffic-eng / fast-reroute
      container fast-reroute {
        tailf:info "Fast-reroute config parameters";
        container timers {
          tailf:info "Configure fast-reroute timer";
          leaf promotion {
            tailf:info "Configure how often we scan for LSP backup promotion";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-604800>;;Seconds between promotions "+
                "(0 disables promotion)";
              range "0..604800";
            }
          }
        }
      }

      // mpls traffic-eng / link-management
      container link-management {
        tailf:info "MPLS Link Manager subcommands";
        container timers {
          tailf:info "MPLS Link Manager Timer subcommands";
          container preemption-delay {
            tailf:info "Delay LSP preemption";
            leaf bundle-capacity {
              tailf:info "Bundle capacity change preemption delay timer";
              type uint16 {
                tailf:info "<0-300>;;Bundle capacity change preemption "+
                  "timer value (seconds)";
                range "0..300";
              }
            }
          }
        }
      }

      // mpls traffic-eng / signalling advertise explicit-null
      container signalling {
        tailf:info "Signalling options";
        container advertise {
          tailf:info "Label advertising options";
          leaf explicit-null {
            tailf:info "Enable explicit-null advertising to PHOP";
            type empty;
          }
        }
      }

      // mpls traffic-eng / gmpls optical-uni
      container gmpls {
        tailf:info "GMPLS submode";
        container optical-uni {
          tailf:info "GMPLS-UNI submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-te-gmpls";

          // mpls traffic-eng / gmpls optical-uni / controller *
          list controller {
            tailf:cli-mode-name "config-te-gmpls-cntl";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface/controller name";
              }
            }

            // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties
            container tunnel-properties {
              tailf:info "Configure GMPLS-UNI tunnel head properties";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-te-gmpls-tun";

              // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties / signalled-name
              leaf signalled-name {
                tailf:info "The signaling name to assign to the tunnel";
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;The name to be included in signaling (max 64 characters)";
                }
              }

              // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties / tunnel-id
              leaf tunnel-id {
                tailf:info "GMPLS-UNI tunnel id";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<0-65535>;;Tunnel ID";
                }
              }

              // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties / destination
              container destination {
                tailf:info "Specify tunnel destination";
                container ipv4 {
                  tailf:info "Specify an IPv4 destination";
                  leaf unicast {
                    tailf:info "Specify an IPv4 unicast destination";
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;Tunnel destination address";
                    }
                  }
                }
              }

              // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties / path-option *
              list path-option {
                tailf:info "Configure a GMPLS-UNI path-option";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                tailf:cli-incomplete-command;
                key id;
                leaf id {
                  type uint16 {
                    tailf:info "<1-1000>;;Preference for this path option";
                    range "1..1000";
                  }
                }
                choice path-choice {
                  case explicit {
                    leaf explicit {
                      tailf:info "Setup based on preconfigured path";
                      tailf:cli-incomplete-command;
                      type empty;
                    }
                    leaf identifier {
                      tailf:info "Specify an explicit path by number";
                      tailf:cli-optional-in-sequence;
                      tailf:cli-incomplete-command;
                      type uint16 {
                        tailf:info "<1-65535>;;Explicit path number";
                        range "1..65535";
                      }
                    }
                    leaf name {
                      tailf:info "Specify an explicit path by name";
                      tailf:cli-incomplete-command;
                      when "not(../identifier)";
                      type string {
                        tailf:info "WORD;;Explicit path name";
                      }
                    }
                  }
                  case no-ero {
                    leaf no-ero {
                      tailf:info "No path configuration";
                      tailf:cli-incomplete-command;
                      type empty;
                    }
                  }
                }
                leaf signaled-label {
                  tailf:cli-break-sequence-commands;
                  tailf:info "Specify a fixed upstream label to be used";
                  type enumeration {
                    enum dwdm {
                      tailf:info "DWDM label (RFC 6205), 50GHz channel-spacing";
                    }
                  }
                }
                leaf wavelength {
                  when "../signaled-label";
                  tailf:info "DWDM wavelength";
                  type uint8 {
                    tailf:info "<1-89>;;DWDM channel number (ITU), 50GHz channel-spacing";
                    range "1..89";
                  }
                }
                leaf xro-attribute-set {
                  tailf:info "Attribute-set containing path exclusions";
                  type string {
                    tailf:info "WORD;;Specify attribute-set name (max 64 char)";
                  }
                }
                leaf lockdown {
                  tailf:info "Not a candidate for reoptimization";
                  type empty;
                }
                leaf verbatim {
                  tailf:info "Use explicit path to construct ERO directly";
                  type empty;
                }
              }
            }
          }
        }
      }

      // mpls traffic-eng / load-share unequal
      container load-share {
        tailf:info "Load-share configuration";
        leaf unequal {
          tailf:info "Enable unequal load-sharing across TE tunnels to the same destination";
          type empty;
        }
      }
    }

    // mpls ldp
    container ldp {
      tailf:info "Label Distribution Protocol";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ldp";

      // mpls ldp / log
      container log {
        tailf:info "Configure logging of LDP events";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-log";

        // mpls ldp / log / adjacency
        leaf adjacency {
          tailf:info "Adjacency events";
          tailf:cli-full-command;
          type empty;
        }

        // mpls ldp / log / neighbor
        leaf neighbor {
          tailf:info "Neighbor events";
          tailf:cli-full-command;
          type empty;
        }

        // mpls ldp / log / graceful-restart
        leaf graceful-restart {
          tailf:info "Graceful Restart events";
          tailf:cli-full-command;
          type empty;
        }

        // mpls ldp / log / session-protection
        leaf session-protection {
          tailf:info "Session Protection events";
          tailf:cli-full-command;
          type empty;
        }

        // mpls ldp / log / nsr
        leaf nsr {
          tailf:info "NSR synchronization events";
          tailf:cli-full-command;
          type empty;
        }
      }

      // mpls ldp / nsr
      leaf nsr {
        tailf:info "Configure Non-Stop Routing";
        tailf:cli-full-command;
        type empty;
      }

      // mpls ldp / graceful-restart
      container graceful-restart {
        tailf:info "Configure graceful restart feature";
        tailf:cli-delete-when-empty;
        presence true;
      }

      // mpls ldp / holdtime
      leaf holdtime {
        tailf:info "Configure session holdtime";
        type uint16 {
          tailf:info "<15-65535>;;Time (seconds)";
        }
      }

      // mpls ldp / session
      container session {
        tailf:info "Configure session parameters";

        // mpls ldp / session protection
        container protection {
          tailf:info "Configure session protection parameters";
          tailf:cli-delete-when-empty;
          presence true;
          leaf duration {
            tailf:info "Session protection duration after loss of link discovery";
            type union {
              type uint32 {
                tailf:info "<30-2147483>;;Holdup time in seconds";
                range "30..2147483";
              }
              type enumeration {
                enum infinite {
                  tailf:info "Protect session forever after loss of link discovery";
                }
              }
            }
          }
        }
      }

      // mpls ldp / signalling dscp
      container signalling {
        tailf:info "Configure signalling parameters";
        leaf dscp {
          tailf:info "Set DSCP for LDP control packets";
          type uint8 {
            tailf:info "<0-63>;;Differentiated Services Code Point (DSCP)";
            range "0..63";
          }
        }
      }

      // mpls ldp / igp sync delay
      container igp {
        tailf:info "Configure IGP related parameters";
        container sync {
          tailf:info "Configure LDP-IGP synchronization parameters";
          container delay-on-proc-restart {
            tailf:cli-drop-node-name;
            // mpls ldp / igp sync delay on-proc-restart
            container delay {
              tailf:info "Configure sync up delay after session up";
              leaf on-proc-restart {
                tailf:info "Global sync up delay to be used after process restart";
                type uint16 {
                  tailf:info "<60-600>;;Global sync-up delay (seconds)";
                  range "60..600";
                }
              }
            }
          }
          container delay {
            tailf:info "Configure sync up delay after session up";
            tailf:cli-compact-syntax;
            // mpls ldp / igp sync delay on-session-up
            leaf on-session-up {
              tailf:info "Interface sync-up delay after session up";
              type empty;
            }
            leaf delay-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<5-300>;;Interface sync-up delay (seconds)";
                range "5..300";
              }
            }
          }
        }
      }

      // mpls ldp / mldp
      container mldp {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-mldp";

        // mpls ldp / mldp / logging
        container logging {
          tailf:info "MLDP logging commands";
          // mpls ldp / mldp / logging notifications
          leaf notifications {
            tailf:info "MLDP logging notifications";
            type empty;
          }
          leaf internal {
            tailf:info "MLDP logging internal(cisco-support)";
            type empty;
          }
        }

        // mpls ldp / mldp / address-family ipv4
        container address-family {
          tailf:info "Configure Address Family and its parameters";
          container ipv4 {
            tailf:info "IPv4";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ldp-mldp-af";

            // mpls ldp / mldp / address-family ipv4 / make-before-break
            container make-before-break {
              tailf:info "Make Before Break";

              // mpls ldp / mldp / address-family ipv4 / make-before-break delay
              leaf delay {
                tailf:info "MBB delay";
                type uint8 {
                  tailf:info "<0-60>;;Delete delay in seconds";
                  range "0..60";
                }
              }
            }

            // mpls ldp / mldp / address-family ipv4 / recursive-fec
            container recursive-fec {
              tailf:info "MLDP Recursive FEC support";
              presence true;
            }
          }
        }
      }

      // mpls ldp / discovery
      container discovery {
        tailf:info "Configure discovery parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-disc";

        // mpls ldp / discovery / instance-tlv
        container instance-tlv {
          tailf:info "Control support for Neighbor instance TLV in "+
            "Hello messages";
          leaf disable {
            tailf:info "Disable transmit and receive processing for TLV";
            tailf:cli-full-command;
            type empty;
          }
        }

        // mpls ldp / discovery / hello
        container hello {
          tailf:info "LDP Link Hellos";
          leaf holdtime {
            tailf:info "Hello holdtime";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Time (seconds) - 65535 implies infinite";
              range "1..65535";
            }
          }
          leaf interval {
            tailf:info "Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Time (seconds)";
              range "1..65535";
            }
          }
        }

        // mpls ldp / discovery / targeted-hello
        container targeted-hello {
          tailf:info "LDP Targeted Hellos";
          container accept {
            tailf:info "Accept and respond to targeted hellos";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf from {
              tailf:info "IP Access list to specify acceptable targeted hello sources";
              type string {
                tailf:info "WORD;;access-list";
              }
            }
          }
        }
      }

      // mpls ldp / router-id
      leaf router-id {
        tailf:info "Configure router Id";
        tailf:cli-full-command;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address to be used";
          }
          type ifname;
        }
      }

      // mpls ldp / neighbor
      container neighbor {
        tailf:info "Configure neighbor parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-nbr";

        // mpls ldp / neighbor / password
        container password {
          tailf:info "Configure password for MD5 authentication for all neighbors";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf "type" {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum clear {
                tailf:info "Specifies an UNENCRYPTED password will follow";
              }
              enum encrypted {
                tailf:info "Specifies an ENCRYPTED password will follow";
              }
            }
          }
          leaf password {
            tailf:cli-drop-node-name;
            tailf:cli-reset-container;
            tailf:meta-data "secret-password" {
              tailf:meta-value "mpls ldp<NL><*> neighbor<NL><*> ::   password <PASSWORD>";
            }
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password";
            }
          }
        }

        // mpls ldp / neighbor / *
        list neighbor-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key id;
          leaf id {
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;DEPRECATED - LSR Id of neighbor";
              }
              type string {
                tailf:info "A.B.C.D:;;LDP Id of neighbor";
              }
            }
          }

          // mpls ldp / neighbor / * password
          container password {
            tailf:info "Configure password for MD5 authentication";

            choice password-choice {
              // mpls ldp / neighbor / * password disable
              leaf disable {
                tailf:info "Disables the global password from this neighbor";
                type empty;
              }

              // mpls ldp / neighbor / * password clear
              leaf clear {
                tailf:info "Specifies an UNENCRYPTED password will follow";
                tailf:meta-data "secret-password" {
                  tailf:meta-value "mpls ldp<NL><*> neighbor<NL><*> ::   <neighbor-list> password <PASSWORD>";
                }
                type string {
                  tailf:info "LINE;;The UNENCRYPTED (cleartext) neighbor password";
                }
              }

              // mpls ldp / neighbor / * password encrypted
              leaf encrypted {
                tailf:info "Specifies an encrypted password will follow";
                type string {
                  tailf:info "WORD;;The ENCRYPTED neighbor password string";
                }
              }
            }
          }
        }
      }

      // mpls ldp / redistribute / bgp / as
      container redistribute {
        tailf:cli-add-mode;
        container bgp {
          tailf:cli-add-mode;
          leaf as {
            type uint32;
          }
        }
      }

      // mpls ldp / password
      container password {
        tailf:info "Configure LDP MD5 password";
        //  fallback  Specifies a fallback password will follow
        container option {
          tailf:info "LDP password options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf sequence-nr {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-32767>;;Sequence number of the"
                +" LDP password option";
              range "1..32767";
            }
          }
          leaf "for" {
            tailf:info "IP access-list specifying control on LDP peers";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;IP standard access-list for LDP peers; "
                +"name or number (1-99)";
            }
          }
          leaf enc-type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum 0 {
                tailf:info "Specifies an UNENCRYPTED password will follow";
              }
              enum 7 {
                tailf:info "Specifies a HIDDEN password will follow";
              }
            }
          }
          leaf password {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password";
            }
          }
        }
        container required {
          tailf:info "MD5 password is required for the peer";
          tailf:cli-reset-container;
          presence true;
          leaf for {
            tailf:info "IP access-list specifying control on LDP peers";
            type string {
              tailf:info "WORD;;IP standard access-list for LDP peers; "
                +"name or number (1-99)";
            }
          }
        }
      }

      // mpls ldp / label
      container label {
        tailf:info "Configure label allocation, advertisement, and acceptance";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-lbl";

        // mpls ldp / label / allocate
        container allocate {
          tailf:info "Configure label allocation control";
          leaf "for" {
            tailf:info "Limit label allocation to a set of prefixes";
            type string {
              tailf:info "WORD;;IP access-list";
            }
          }
        }

        // mpls ldp / label / advertise
        container advertise {
          tailf:info "Configure outbound label advertisement control";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-ldp-lbl-advt";
          leaf disable {
            tailf:info "Disable label advertisement to all peers for all "+
              "prefixes";
            tailf:cli-full-command;
            type empty;
          }
          leaf "for" {
            tailf:info "Prefix centric outbound label filtering";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;IP access-list name or number (1-99)";
            }
          }
        }
      }

      // mpls ldp / address-family ipv4
      container address-family {
        tailf:info "Configure Address Family and its parameters";
        container ipv4 {
          tailf:info "IPv4";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-ldp-af";

          // mpls ldp / address-family ipv4 / discovery targeted-hello accept
          container discovery {
            tailf:info "Configure discovery parameters";
            container targeted-hello {
              tailf:info "LDP Targeted Hellos";
              container accept {
                tailf:info "Accept and respond to targeted hellos";
                tailf:cli-delete-when-empty;
                tailf:cli-reset-container;
                presence true;
                leaf from {
                  tailf:info "IP Access list to specify acceptable targeted "+
                    "hello sources";
                  type string {
                    tailf:info "WORD;;access-list";
                  }
                }
              }
            }
          }

          // mpls ldp / address-family ipv4 / label
          container label {
            tailf:info "Configure label control and policies";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ldp-af-lbl";

            // mpls ldp / address-family ipv4 / label / local
            container local {
              tailf:info "Configure local label control and policies";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-ldp-af-lbl-lcl";

              // mpls ldp / address-family ipv4 / label / local / allocate
              container allocate {
                tailf:info "Configure label allocation control";
                leaf "for" {
                  tailf:info "Limit label allocation to a set of prefixes";
                  type union {
                    type string {
                      tailf:info "WORD;;IP access-list";
                    }
                    type enumeration {
                      enum host-routes {
                        tailf:info "Allocate label for host routes only";
                      }
                    }
                  }
                }
              }

              // mpls ldp / address-family ipv4 / label / local / advertise
              container advertise {
                tailf:info "Configure outbound label advertisement control";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-ldp-af-lbl-lcl-advt";

                // mpls ldp / address-family ipv4 / label / local / advertise / explicit-null
                container explicit-null {
                  tailf:info "Configure explicit-null advertisement";
                  tailf:cli-compact-syntax;
                  tailf:cli-delete-when-empty;
                  presence true;
                  leaf "for" {
                    tailf:info "IP Access-list specifying controls on destination prefixes";
                    type string {
                      tailf:info "WORD;;IP access-list";
                    }
                  }
                  leaf to {
                    tailf:info "IP Access-list specifying controls on LDP Peers";
                    type string {
                      tailf:info "WORD;;IPv4 access-list (specify peer LSR Ids)";
                    }
                  }
                }

                // mpls ldp / address-family ipv4 / label / local / advertise / disable
                leaf disable {
                  tailf:info "Disable label advertisement to all peers for all prefixes";
                  type empty;
                }

                // mpls ldp / address-family ipv4 / label / local / advertise / for
                list "for" {
                  tailf:info "Prefix centric outbound label filtering";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key acl;
                  leaf acl {
                    tailf:info "WORD;;IP access-list";
                    type string {
                      tailf:info "WORD;;IP access-list";
                    }
                  }
                }
              }
            }
          }

          // mpls ldp / address-family ipv4 / traffic-eng
          container traffic-eng {
            tailf:info "Configure LDP parameters for MPLS Traffic-Engineering (TE)";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ldp-af-te";
            container auto-tunnel {
              tailf:info "Configure LDP TE auto-tunnel related parameters";
              // mpls ldp / address-family ipv4 / traffic-eng / auto-tunnel mesh
              container mesh {
                tailf:info "Configure TE auto-tunnel mesh groups";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-ldp-af-te-mesh";
                // mpls ldp / address-family ipv4 / traffic-eng / auto-tunnel mesh / group *
                list group {
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key id;
                  leaf id {
                    type union {
                      type enumeration {
                        enum all {
                          tailf:info "Enable LDP on all TE meshgroup interfaces";
                        }
                      }
                      type uint32 {
                        tailf:info "<0-4294967295>;;The TE mesh group ID on which to enable LDP";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      // mpls ldp / interface *
      list interface {
        tailf:info "Enable LDP on an interface and enter interface submode";
        tailf:cli-mode-name "config-ldp-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // mpls ldp / interface * / address-family ipv4
        container address-family {
          tailf:info "Configure Address Family and its parameters";
          container ipv4 {
            tailf:info "IPv4";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ldp-if-af";

            // mpls ldp / interface * / address-family ipv4 / mldp disable
            container mldp {
              tailf:info "Configure mLDP parameters";
              leaf disable {
                tailf:info "Disable mLDP on LDP enabled interface";
                type empty;
              }
            }
          }
        }
      }
    }

    // mpls oam
    container oam {
      tailf:info "OAM configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-oam";
      presence true;

      // mpls oam / echo
      container echo {
        tailf:info "Echo request attributes";

        // mpls oam / echo revision
        leaf "revision" {
          tailf:info "Echo packet default revision";
          type enumeration {
            enum "1" {
              tailf:info "draft-ietf-mpls-lsp-ping-03 (initial)";
            }
            enum "2" {
              tailf:info "draft-ietf-mpls-lsp-ping-03 (rev 1)";
            }
            enum "3" {
              tailf:info "draft-ietf-mpls-lsp-ping-03 (rev 2)";
            }
            enum "4" {
              tailf:info "draft-ietf-mpls-lsp-ping-09 (initial)";
            }
          }
        }

        // mpls oam / echo disable-vendor-extensio
        leaf disable-vendor-extension {
          tailf:info "Disable sending vendor extension TLV with echo req";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // mpls static
    container static {
      tailf:info "Configure static MPLS forwarding";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mpls-static";

      // mpls static / ipv4 *
      list ipv4 {
        tailf:info "Configure MPLS static IPv4 imposition";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-incomplete-command;
        key "address mask interface";
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 mask";
          }
        }
        leaf interface {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf nexthop {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address of next hop router";
          }
        }
        choice label-choice {
          leaf label {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<16-1048575>;;Outgoing label";
            }
          }
          leaf ipv4-explicit-null  {
            tailf:info "IPv4 explicit null";
            type empty;
          }
          leaf ipv6-explicit-null {
            tailf:info "IPv6 explicit null";
            type empty;
          }
          container pop {
            tailf:cli-compact-syntax;
            tailf:info "Pop label";
            presence true;
            choice pop-choice {
              leaf labelled {
                tailf:info "Pop label to MPLS only";
                type empty;
              }
              leaf unlabelled {
                tailf:info "Pop label to non-MPLS only";
                type empty;
              }
            }
          }
        }
      }

      // mpls static / interface *
      list interface {
        tailf:info "Enable MPLS Static on an interface";
        key name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        leaf name {
          type ifname;
        }
      }

      // mpls static / address-family ipv4 unicast
      container address-family {
        tailf:info "Configure Address Family and its parameters";
        list ipv4 {
          tailf:info "Configure IPv4 Address Family parameters";
          tailf:cli-mode-name "config-mpls-static-af";
          tailf:cli-full-command;
          key af-modifier;
          leaf af-modifier {
            type enumeration {
              enum unicast {
                tailf:code-name "ipv4_unicast";
                tailf:info "Unicast";
              }
            }
          }
          // mpls static / address-family ipv4 * / local-label *
          list local-label {
            tailf:info "Configure local label assignment and forwarding";
            tailf:cli-mode-name "config-mpls-static-af-lbl";
            tailf:cli-incomplete-command;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key id;
            leaf id {
              tailf:cli-suppress-range;
              type uint32 {
                tailf:info "<16-1048575>;;Label value";
                range "16..1048575";
              }
            }
            leaf allocate {
              tailf:info "Label Allocation Option";
              tailf:cli-hide-in-submode;
              type empty;
            }
            leaf per-prefix {
              tailf:info "For a given prefix";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;IPv4 Prefix";
              }
            }
            container forward {
              tailf:cli-break-sequence-commands;
              tailf:info "Configure forwarding rewrites";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-mpls-static-af-lbl-fwd";
              list "path" {
                tailf:info "Configure cross-connect path parameters";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                tailf:cli-incomplete-command;
                key id;
                leaf id {
                  type uint16 {
                    tailf:info "<1-1>;;Path count";
                  }
                }
                leaf nexthop {
                  tailf:info "nexthop";
                  tailf:cli-incomplete-command;
                  type ifname;
                }
                leaf nexthop-address {
                  tailf:cli-optional-in-sequence;
                  tailf:cli-incomplete-command;
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Next-hop IPv4 address";
                  }
                }
                leaf out-label {
                  tailf:info "output label";
                  type union {
                    type uint32 {
                      tailf:info "<16-1048575>;;Output MPLS label value";
                      range "16..1048575";
                    }
                    type enumeration {
                      enum exp-null {
                        tailf:info "Set the output label to explicit null";
                      }
                      enum pop {
                        tailf:info "Pop off the top of the label stack";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      // mpls static / vrf *
      list vrf {
        tailf:info "Configure VRF parameters";
        tailf:cli-mode-name "config-mpls-static-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Specify the VRF Name";
          }
        }

        // mpls static / vrf * / address-family ipv4 unicast
        container address-family {
          tailf:info "Configure Address Family and its parameters";
          list ipv4 {
            tailf:info "Configure IPv4 Address Family parameters";
            tailf:cli-mode-name "config-mpls-static-vrf-af";
            tailf:cli-full-command;
            key af-modifier;
            leaf af-modifier {
              type enumeration {
                enum unicast {
                  tailf:code-name "mpls_static_vrf_ipv4_unicast";
                  tailf:info "Unicast";
                }
              }
            }
            // mpls static / vrf * / address-family ipv4 unicast / local-label *
            list local-label {
              tailf:info "Configure local label assignment and forwarding";
              tailf:cli-mode-name "config-mpls-static-vrf-af-lbl";
              tailf:cli-incomplete-command;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key id;
              leaf id {
                tailf:cli-suppress-range;
                type uint32 {
                  tailf:info "<16-1048575>;;Label value";
                  range "16..1048575";
                }
              }
              leaf allocate {
                tailf:info "Label Allocation Option";
                tailf:cli-incomplete-command;
                tailf:cli-hide-in-submode;
                type empty;
              }
              choice allocate-choice {
                leaf per-prefix {
                  tailf:info "For a given prefix";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type ipv4-prefix {
                    tailf:info "A.B.C.D/length;;IPv4 Prefix";
                  }
                }
                leaf per-vrf {
                  tailf:info "For a VRF";
                  tailf:cli-hide-in-submode;
                  type empty;
                }
              }
              // mpls static / vrf * / address-family ipv4 unicast /
              //    local-label * / forward
              container forward {
                when "../per-vrf";
                tailf:cli-break-sequence-commands;
                tailf:info "Configure forwarding rewrites";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-mpls-static-vrf-af-lbl-fwd";
                list "path" {
                  tailf:info "Configure cross-connect path parameters";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-incomplete-command;
                  key id;
                  leaf id {
                    tailf:cli-suppress-range;
                    type uint8 {
                      tailf:info "<1-1>;;Path count";
                    }
                  }
                  leaf pop-and-lookup {
                    tailf:info "Pop and lookup";
                    type empty;
                  }
                }
              }
            }
          }
        }
      }
    }

    // mpls ip-ttl-propagate
    container ip-ttl-propagate {
      tailf:info "Propagate IP TTL into the label stack";
      container disable {
        tailf:info "Disable IP TTL propagation";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf disable-type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum forwarded {
              tailf:info "Disable IP TTL propagation for only forwarded "+
                "MPLS packets";
            }
            enum local {
              tailf:info "Disable IP TTL propagation for only locally "+
                "generated MPLS packets";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// segment-routing
  /// ========================================================================

  container segment-routing {
    tailf:info "Segment Routing";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-sr";

    // segment-routing / global-block
    container global-block {
      tailf:info "Prefix-SID Global label Block (SRGB)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf lower-bound {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<16000-1048574>;;The lower bound of the SRGB";
          range "16000..1048574";
        }
      }
      leaf upper-bound {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<16001-1048575>;;The upper bound of the SRGB";
          range "16001..1048575";
        }
      }
    }

    // segment-routing / mapping-server
    container mapping-server {
      tailf:info "Segment Routing Mapping Server (SRMS)";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-sr-sm";

      // segment-routing / mapping-server / prefix-sid-map
      container prefix-sid-map {
        tailf:info "Prefix SID Map";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-sr-sm-map";

        // segment-routing / mapping-server / prefix-sid-map / address-family
        container address-family {
          tailf:info "Address Family";

          // segment-routing / mapping-server / prefix-sid-map /
          // .. address-family ipv4
          container ipv4 {
            tailf:info "IP version 4";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-sr-sm-map-af";

            // segment-routing / mapping-server / prefix-sid-map /
            // .. address-family ipv4 / *
            list "prefix" {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key "prefix";
              leaf "prefix" {
                type inet:ipv4-prefix {
                  tailf:info "A.B.C.D/length;;IPv4 address with prefix";
                }
              }
              leaf SID-interval {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<0-1048575>;;Start of SID index range";
                  range "0..1048575";
                }
              }
              leaf "range" {
                tailf:info "Number of allocated SIDs";
                type uint32 {
                  tailf:info "<0-1048575>;;Number of allocated SIDs";
                  range "0..1048575";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// telemetry
  /// ========================================================================

  container telemetry {
    tailf:info "Telemetry configuration";
    tailf:cli-explicit-exit;

    // telemetry model-driven
    container model-driven {
      tailf:info "Model Driven Telemetry configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-model-driven";
      presence true;

      // telemetry model-driven / destination-group *
      list destination-group {
        tailf:info "Destination Id";
        tailf:cli-mode-name "config-model-driven-dest";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Destination Id string";
          }
        }

        // telemetry model-driven / destination-group * / address family
        container address-family {
          tailf:info "Destination address of the recepient of the telemetry information";

          // telemetry model-driven / destination-group * / address family ipv4 *
          list ipv4 {
            tailf:info "ipv4 address family";
            tailf:cli-mode-name "config-model-driven-dest-addr";
            key "address port";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Destination ipv4 address";
              }
            }
            leaf port {
              tailf:info "Destination Port configuration";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-65535>;;Port Number";
                range "1..65535";
              }
            }

            // telemetry model-driven / destination-group * / address family ipv4 * / protocol
            leaf protocol {
              tailf:info "Transport Protocol configuration";
              type enumeration {
                enum udp {
                  tailf:info "udp";
                }
                enum tcp {
                  tailf:info "tcp";
                }
                enum grpc {
                }
              }
            }
          }
        }
      }

      // telemetry model-driven / sensor-group *
      list sensor-group {
        tailf:info "Sensor group configuration";
        tailf:cli-mode-name "config-model-driven-snsr-grp";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Sensor Group Id";
          }
        }

        // telemetry model-driven / sensor-group * / sensor-path
        leaf sensor-path {
          tailf:info "Sensor Path";
          type string {
            tailf:info "WORD;;Sensor Path";
          }
        }
      }

      // telemetry model-driven / subscription *
      list subscription {
        tailf:info "Subscription Id";
        tailf:cli-mode-name "config-model-driven-subs";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Subscription Id string";
          }
        }
      }
    }

    // telemetry policy-driven
    container policy-driven {
      tailf:info "Telemetry policy-driven configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-telemetry-policydriven";

      // telemetry policy-driven / encoder
      container encoder {
        tailf:info "Encoder configuration";

        // telemetry policy-driven / encoder gpb
        container gpb {
          tailf:info "GPB encoder configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-telem-plcy-driven-gpb";
          uses telemetry-policy-driven-encoder-grouping;
        }

        // telemetry policy-driven / encoder json
        container json {
          tailf:info "JSON encoder configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-telem-plcy-driven-json";
          uses telemetry-policy-driven-encoder-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// multicast-routing
  /// ========================================================================

  container multicast-routing {
    tailf:info "Enable IP multicast forwarding";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-mcast";
    tailf:cli-explicit-exit;

    uses multicast-routing-grouping;

    // multicast-routing / vrf *
    list vrf {
      tailf:info "VRF configs";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Enter VRF name";
        }
      }
      uses multicast-routing-grouping;
    }
  }


  /// ========================================================================
  /// alias
  /// ========================================================================

  container alias {
    tailf:info "Create an alias for entity";

    // alias *
    list alias-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-disallow-value "exec|config";
        type string {
          tailf:info "WORD;;Alias name";
        }
      }
      leaf line {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Alias body with optional parameters e.g,(name) show $name";
        }
      }
    }

    // alias exec *
    list exec {
      tailf:info "Exec command alias";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Exec Alias name";
        }
      }
      leaf line {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Aliased exec command";
        }
      }
    }

    // alias config *
    list "config" {
      tailf:info "Config command alias";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Config Alias name";
        }
      }
      leaf line {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Aliased config command";
        }
      }
    }
  }


  /// ========================================================================
  /// cached-show
  /// ========================================================================
  /// Cached output of exec command show

  container cached-show {

    // show version
    container version {
      leaf version {
        type string;
      }
      leaf model {
        type string;
      }
    }
  }


  /// ========================================================================
  /// xyzroot
  /// ========================================================================

  leaf xyzroot {
    tailf:info "Internal state variable, do not modify.";
    tailf:cli-run-template "";
    tailf:cli-show-with-default;
    type uint16;
    default "0";
  }

}


/// ========================================================================
//                          EOF
/// ========================================================================
